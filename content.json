{"meta":{"title":"fyupeng","subtitle":"","description":"","author":"fyupeng","url":"http://fyupeng.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-06-24T18:09:11.552Z","updated":"2022-06-24T18:09:11.552Z","comments":false,"path":"/404.html","permalink":"http://fyupeng.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-12-29T06:12:43.262Z","updated":"2022-12-29T06:12:43.262Z","comments":false,"path":"about/index.html","permalink":"http://fyupeng.github.io/about/index.html","excerpt":"","text":"Hi there 👋我是一名程序员小白 fyupeng，目前还处于学习阶段，有不足之处，还请包涵。 我的公众号 Tony有话说 目前同步学习相关文章，文章内容深入浅出。 Languages and Tools: Github State:&nbsp; Open Source Projects: 基于SpringBoot + Rpc-Netty-Framework的分布式博客管理后端api项目 基于 Nacos 的 RPC 分布式微服务框架 基于 ZooKeeper 注册中心的 短视频微信小程序 api 接口 和 后台管理 项目 咖啡订餐系统 vue+vant实现的移动网页端 基于原生 JS + Servlet 的 博客 管理系统 基于主流框架 SpringBoot 的含有植物鉴别功能的 博客 管理系统 My Learning Blog： hexo 个性化博客（综合性博客，包括面经、Java笔记、Java学习框架、算法等等） CSDN（侧重点学习遇到的难题如何解决的点滴记录、环境部署遇到的问题、算法刷题等等） 51CTO（侧重点在于学习笔记记录等等） 博客园（侧重点在于收藏大佬的技术文章） 自建博客-镜像1（个人搭建的服务器博客项目、使用Nginx反向代理接口服务，博客放了一些个人刷过的 leetcode 算法常见题型，对移动端使用人群友好）、自建博客-镜像2（镜像2与镜像1数据不同步，可用Zookeeper实现静态资源同步）"},{"title":"分类","date":"2022-06-24T18:09:11.561Z","updated":"2022-06-24T18:09:11.561Z","comments":false,"path":"categories/index.html","permalink":"http://fyupeng.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-24T17:19:04.497Z","updated":"2022-06-24T17:19:04.497Z","comments":true,"path":"fonts/README.html","permalink":"http://fyupeng.github.io/fonts/README.html","excerpt":"","text":"Font AssetsIf you are providing web font files, this is the place to put them. The fonts task will copy them over to the destination specified in config.json, and file names will be reved in production builds (if enabled). If you don’t plan using web fonts, or are relying on an external service like Google Fonts, feel free to delete this folder and the tasks.fonts config in gulpfile.js/config.json. Tasks and Files1gulpfile.js/tasks/fonts All this task does is copy fonts from ./src/fonts to ./public/fonts. A sass +font-face mixin is included in ./src/stylesheets/base/mixins."},{"title":"","date":"2022-06-24T17:19:04.511Z","updated":"2022-06-24T17:19:04.511Z","comments":true,"path":"js/application.js","permalink":"http://fyupeng.github.io/js/application.js","excerpt":"","text":"$(function() { // bootstrap tooltip $('[data-toggle=\"tooltip\"]').tooltip(); // slimscroll if (typeof $.fn.slimScroll != 'undefined') { $(\".sidebar .slimContent\").slimScroll({ height: $(window).height(), color: \"rgba(0,0,0,0.15)\", size: \"5px\", position: 'right', // allowPageScroll: true }); } $('#collapseToc').on('shown.bs.collapse', function() { // do something… // slimscroll if (typeof $.fn.slimScroll != 'undefined') { $(\".sidebar .slimContent\").slimScroll().on('slimscroll'); } }); // geopattern 背景生成 $(\".geopattern\").each(function() { $(this).geopattern($(this).data('pattern-id')); }); // okayNav var navigation = $('#nav-main').okayNav({ swipe_enabled: false, // If true, you'll be able to swipe left/right to open the navigation }); // modal居中 // $('.modal').on('shown.bs.modal', function(e) { // $(this).show(); // var modalDialog = $(this).find(\".modal-dialog\"); // // Applying the top margin on modal dialog to align it vertically center // modalDialog.css(\"margin-top\", Math.max(0, ($(window).height() - modalDialog.height()) / 2)); // }); // sticky $('[data-stick-bottom]').keepInView({ fixed: false, parentClass: \"has-sticky\", customClass: \"sticky\", trigger: 'bottom', zindex: 42, edgeOffset: 0 }); $('[data-stick-top]').keepInView({ fixed: true, parentClass: \"has-sticky\", customClass: \"sticky\", trigger: 'top', zindex: 42, edgeOffset: 0 }); // menu auto highlight var menuHighlight = $(\"ul.main-nav\").hasClass('menu-highlight'); if (menuHighlight) { var currentPathname = location.pathname, $menuList = $(\"ul.main-nav>li\"), activeIndex = -1; for (var i = 0, length = $menuList.length; i < length; i++) { var itemHref = $($menuList[i]).find('a').attr('href'); if (currentPathname.indexOf(itemHref) > -1 || (currentPathname === '/' && (itemHref === '/.' || itemHref === '/' || itemHref === 'index.html' || itemHref === '/index.html'))) { activeIndex = i; } $($menuList[i]).removeClass('active'); } $menuList[activeIndex] && $($menuList[activeIndex]).addClass('active'); } });"},{"title":"","date":"2022-06-24T17:19:04.494Z","updated":"2022-06-24T17:19:04.494Z","comments":true,"path":"css/style.css","permalink":"http://fyupeng.github.io/css/style.css","excerpt":"","text":"@charset \"UTF-8\"; /** * global variables and mixins */ /** * font family */ /** * */ /* Mixins */ /** * bootstrap */ /*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ /*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */ html { font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; } body { margin: 0; } article, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary { display: block; } audio, canvas, progress, video { display: inline-block; vertical-align: baseline; } audio:not([controls]) { display: none; height: 0; } [hidden], template { display: none; } a { background-color: transparent; } a:active, a:hover { outline: 0; } abbr[title] { border-bottom: 1px dotted; } b, strong { font-weight: bold; } dfn { font-style: italic; } h1 { font-size: 2em; margin: 0.67em 0; } mark { background: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sup { top: -0.5em; } sub { bottom: -0.25em; } img { border: 0; } svg:not(:root) { overflow: hidden; } figure { margin: 1em 40px; } hr { -webkit-box-sizing: content-box; box-sizing: content-box; height: 0; } pre { overflow: auto; } code, kbd, pre, samp { font-family: monospace,monospace; font-size: 1em; } button, input, optgroup, select, textarea { color: inherit; font: inherit; margin: 0; } button { overflow: visible; } button, select { text-transform: none; } button, html input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"] { -webkit-appearance: button; cursor: pointer; } button[disabled], html input[disabled] { cursor: default; } button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; } input { line-height: normal; } input[type=\"checkbox\"], input[type=\"radio\"] { -webkit-box-sizing: border-box; box-sizing: border-box; padding: 0; } input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button { height: auto; } input[type=\"search\"] { -webkit-appearance: textfield; -webkit-box-sizing: content-box; box-sizing: content-box; } input[type=\"search\"]::-webkit-search-cancel-button, input[type=\"search\"]::-webkit-search-decoration { -webkit-appearance: none; } fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; } legend { border: 0; padding: 0; } textarea { overflow: auto; } optgroup { font-weight: bold; } table { border-collapse: collapse; border-spacing: 0; } td, th { padding: 0; } /*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */ * { -webkit-box-sizing: border-box; box-sizing: border-box; } *:before, *:after { -webkit-box-sizing: border-box; box-sizing: border-box; } html { font-size: 10px; -webkit-tap-highlight-color: transparent; } input, button, select, textarea { font-family: inherit; font-size: inherit; line-height: inherit; } a { color: #2196f3; text-decoration: none; } a:hover, a:focus { color: #0a6ebd; text-decoration: underline; } a:focus { outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } figure { margin: 0; } img { vertical-align: middle; } .img-responsive { display: block; max-width: 100%; height: auto; } .img-rounded { border-radius: 6px; } .img-thumbnail { padding: 4px; line-height: 1.57143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: all 0.2s ease-in-out; transition: all 0.2s ease-in-out; display: inline-block; max-width: 100%; height: auto; } .img-circle { border-radius: 50%; } hr { margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid #eeeeee; } .sr-only { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; } .sr-only-focusable:active, .sr-only-focusable:focus { position: static; width: auto; height: auto; margin: 0; overflow: visible; clip: auto; } [role=\"button\"] { cursor: pointer; } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 { font-family: inherit; font-weight: 500; line-height: 1.1; color: inherit; } h1 small, h1 .small, h2 small, h2 .small, h3 small, h3 .small, h4 small, h4 .small, h5 small, h5 .small, h6 small, h6 .small, .h1 small, .h1 .small, .h2 small, .h2 .small, .h3 small, .h3 .small, .h4 small, .h4 .small, .h5 small, .h5 .small, .h6 small, .h6 .small { font-weight: normal; line-height: 1; color: #777777; } h1, .h1, h2, .h2, h3, .h3 { margin-top: 21px; margin-bottom: 10.5px; } h1 small, h1 .small, .h1 small, .h1 .small, h2 small, h2 .small, .h2 small, .h2 .small, h3 small, h3 .small, .h3 small, .h3 .small { font-size: 65%; } h4, .h4, h5, .h5, h6, .h6 { margin-top: 10.5px; margin-bottom: 10.5px; } h4 small, h4 .small, .h4 small, .h4 .small, h5 small, h5 .small, .h5 small, .h5 .small, h6 small, h6 .small, .h6 small, .h6 .small { font-size: 75%; } h1, .h1 { font-size: 30px; } h2, .h2 { font-size: 26px; } h3, .h3 { font-size: 22px; } h4, .h4 { font-size: 18px; } h5, .h5 { font-size: 14px; } h6, .h6 { font-size: 12px; } p { margin: 0 0 10.5px; } .lead { margin-bottom: 21px; font-size: 16px; font-weight: 300; line-height: 1.4; } small, .small { font-size: 85%; } mark, .mark { background-color: #fcf8e3; padding: .2em; } .text-left { text-align: left; } .text-right { text-align: right; } .text-center { text-align: center; } .text-justify { text-align: justify; } .text-nowrap { white-space: nowrap; } .text-lowercase { text-transform: lowercase; } .text-uppercase, .initialism { text-transform: uppercase; } .text-capitalize { text-transform: capitalize; } .text-muted { color: #777777 !important; } .text-primary { color: #2196f3; } a.text-primary:hover, a.text-primary:focus { color: #0c7cd5; } .text-success { color: #3c763d; } a.text-success:hover, a.text-success:focus { color: #2b542c; } .text-info { color: #31708f; } a.text-info:hover, a.text-info:focus { color: #245269; } .text-warning { color: #8a6d3b; } a.text-warning:hover, a.text-warning:focus { color: #66512c; } .text-danger { color: #a94442; } a.text-danger:hover, a.text-danger:focus { color: #843534; } .bg-primary { color: #fff; } .bg-primary { background-color: #2196f3; } a.bg-primary:hover, a.bg-primary:focus { background-color: #0c7cd5; } .bg-success { background-color: #dff0d8; } a.bg-success:hover, a.bg-success:focus { background-color: #c1e2b3; } .bg-info { background-color: #d9edf7; } a.bg-info:hover, a.bg-info:focus { background-color: #afd9ee; } .bg-warning { background-color: #fcf8e3; } a.bg-warning:hover, a.bg-warning:focus { background-color: #f7ecb5; } .bg-danger { background-color: #f2dede; } a.bg-danger:hover, a.bg-danger:focus { background-color: #e4b9b9; } .page-header { padding-bottom: 9.5px; margin: 42px 0 21px; border-bottom: 1px solid #eeeeee; } ul, ol { margin-top: 0; margin-bottom: 10.5px; } ul ul, ul ol, ol ul, ol ol { margin-bottom: 0; } .list-unstyled { padding-left: 0; list-style: none; } .list-inline { padding-left: 0; list-style: none; margin-left: -5px; } .list-inline > li { display: inline-block; padding-left: 5px; padding-right: 5px; } dl { margin-top: 0; margin-bottom: 21px; } dt, dd { line-height: 1.57143; } dt { font-weight: bold; } dd { margin-left: 0; } .dl-horizontal dd:before, .dl-horizontal dd:after { content: \" \"; display: table; } .dl-horizontal dd:after { clear: both; } abbr[title], abbr[data-original-title] { cursor: help; border-bottom: 1px dotted #777777; } .initialism { font-size: 90%; } blockquote { padding: 10.5px 16px; margin: 0 0 21px; border: 1px dotted #eeeeee; border-left: 3px solid #eeeeee; background-color: #fbfbfb; } blockquote p:last-child, blockquote ul:last-child, blockquote ol:last-child { margin-bottom: 0; } blockquote footer, blockquote small, blockquote .small { display: block; font-size: 80%; line-height: 1.57143; color: #777777; } blockquote footer:before, blockquote small:before, blockquote .small:before { content: '\\2014 \\00A0'; } .blockquote-reverse, blockquote.pull-right { padding-right: 15px; padding-left: 0; border-right: 5px solid #eeeeee; border-left: 0; text-align: right; } .blockquote-reverse footer:before, .blockquote-reverse small:before, .blockquote-reverse .small:before, blockquote.pull-right footer:before, blockquote.pull-right small:before, blockquote.pull-right .small:before { content: ''; } .blockquote-reverse footer:after, .blockquote-reverse small:after, .blockquote-reverse .small:after, blockquote.pull-right footer:after, blockquote.pull-right small:after, blockquote.pull-right .small:after { content: '\\00A0 \\2014'; } address { margin-bottom: 21px; font-style: normal; line-height: 1.57143; } .container { margin-right: auto; margin-left: auto; padding-left: 15px; padding-right: 15px; } .container:before, .container:after { content: \" \"; display: table; } .container:after { clear: both; } .container-fluid { margin-right: auto; margin-left: auto; padding-left: 15px; padding-right: 15px; } .container-fluid:before, .container-fluid:after { content: \" \"; display: table; } .container-fluid:after { clear: both; } .row { margin-left: -15px; margin-right: -15px; } .row:before, .row:after { content: \" \"; display: table; } .row:after { clear: both; } .col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 { position: relative; min-height: 1px; padding-left: 15px; padding-right: 15px; } .col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 { float: left; } .col-xs-1 { width: 8.33333%; } .col-xs-2 { width: 16.66667%; } .col-xs-3 { width: 25%; } .col-xs-4 { width: 33.33333%; } .col-xs-5 { width: 41.66667%; } .col-xs-6 { width: 50%; } .col-xs-7 { width: 58.33333%; } .col-xs-8 { width: 66.66667%; } .col-xs-9 { width: 75%; } .col-xs-10 { width: 83.33333%; } .col-xs-11 { width: 91.66667%; } .col-xs-12 { width: 100%; } .col-xs-pull-0 { right: auto; } .col-xs-pull-1 { right: 8.33333%; } .col-xs-pull-2 { right: 16.66667%; } .col-xs-pull-3 { right: 25%; } .col-xs-pull-4 { right: 33.33333%; } .col-xs-pull-5 { right: 41.66667%; } .col-xs-pull-6 { right: 50%; } .col-xs-pull-7 { right: 58.33333%; } .col-xs-pull-8 { right: 66.66667%; } .col-xs-pull-9 { right: 75%; } .col-xs-pull-10 { right: 83.33333%; } .col-xs-pull-11 { right: 91.66667%; } .col-xs-pull-12 { right: 100%; } .col-xs-push-0 { left: auto; } .col-xs-push-1 { left: 8.33333%; } .col-xs-push-2 { left: 16.66667%; } .col-xs-push-3 { left: 25%; } .col-xs-push-4 { left: 33.33333%; } .col-xs-push-5 { left: 41.66667%; } .col-xs-push-6 { left: 50%; } .col-xs-push-7 { left: 58.33333%; } .col-xs-push-8 { left: 66.66667%; } .col-xs-push-9 { left: 75%; } .col-xs-push-10 { left: 83.33333%; } .col-xs-push-11 { left: 91.66667%; } .col-xs-push-12 { left: 100%; } .col-xs-offset-0 { margin-left: 0%; } .col-xs-offset-1 { margin-left: 8.33333%; } .col-xs-offset-2 { margin-left: 16.66667%; } .col-xs-offset-3 { margin-left: 25%; } .col-xs-offset-4 { margin-left: 33.33333%; } .col-xs-offset-5 { margin-left: 41.66667%; } .col-xs-offset-6 { margin-left: 50%; } .col-xs-offset-7 { margin-left: 58.33333%; } .col-xs-offset-8 { margin-left: 66.66667%; } .col-xs-offset-9 { margin-left: 75%; } .col-xs-offset-10 { margin-left: 83.33333%; } .col-xs-offset-11 { margin-left: 91.66667%; } .col-xs-offset-12 { margin-left: 100%; } .btn { display: inline-block; margin-bottom: 0; font-weight: normal; text-align: center; vertical-align: middle; -ms-touch-action: manipulation; touch-action: manipulation; cursor: pointer; background-image: none; border: 1px solid transparent; white-space: nowrap; padding: 6px 12px; font-size: 14px; line-height: 1.57143; border-radius: 4px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .btn:focus, .btn.focus, .btn:active:focus, .btn:active.focus, .btn.active:focus, .btn.active.focus { outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } .btn:hover, .btn:focus, .btn.focus { color: #333; text-decoration: none; } .btn:active, .btn.active { outline: 0; background-image: none; -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125); } .btn.disabled, .btn[disabled], fieldset[disabled] .btn { cursor: not-allowed; opacity: 0.65; filter: alpha(opacity=65); -webkit-box-shadow: none; box-shadow: none; } a.btn.disabled, fieldset[disabled] a.btn { pointer-events: none; } .btn-default { color: #333; background-color: #fff; border-color: #ccc; } .btn-default:focus, .btn-default.focus { color: #333; background-color: #e6e6e6; border-color: #8c8c8c; } .btn-default:hover { color: #333; background-color: #e6e6e6; border-color: #adadad; } .btn-default:active, .btn-default.active, .open > .btn-default.dropdown-toggle { color: #333; background-color: #e6e6e6; border-color: #adadad; } .btn-default:active:hover, .btn-default:active:focus, .btn-default:active.focus, .btn-default.active:hover, .btn-default.active:focus, .btn-default.active.focus, .open > .btn-default.dropdown-toggle:hover, .open > .btn-default.dropdown-toggle:focus, .open > .btn-default.dropdown-toggle.focus { color: #333; background-color: #d4d4d4; border-color: #8c8c8c; } .btn-default:active, .btn-default.active, .open > .btn-default.dropdown-toggle { background-image: none; } .btn-default.disabled:hover, .btn-default.disabled:focus, .btn-default.disabled.focus, .btn-default[disabled]:hover, .btn-default[disabled]:focus, .btn-default[disabled].focus, fieldset[disabled] .btn-default:hover, fieldset[disabled] .btn-default:focus, fieldset[disabled] .btn-default.focus { background-color: #fff; border-color: #ccc; } .btn-default .badge { color: #fff; background-color: #333; } .btn-primary { color: #fff; background-color: #2196f3; border-color: #0d8aee; } .btn-primary:focus, .btn-primary.focus { color: #fff; background-color: #0c7cd5; border-color: #064475; } .btn-primary:hover { color: #fff; background-color: #0c7cd5; border-color: #0a68b4; } .btn-primary:active, .btn-primary.active, .open > .btn-primary.dropdown-toggle { color: #fff; background-color: #0c7cd5; border-color: #0a68b4; } .btn-primary:active:hover, .btn-primary:active:focus, .btn-primary:active.focus, .btn-primary.active:hover, .btn-primary.active:focus, .btn-primary.active.focus, .open > .btn-primary.dropdown-toggle:hover, .open > .btn-primary.dropdown-toggle:focus, .open > .btn-primary.dropdown-toggle.focus { color: #fff; background-color: #0a68b4; border-color: #064475; } .btn-primary:active, .btn-primary.active, .open > .btn-primary.dropdown-toggle { background-image: none; } .btn-primary.disabled:hover, .btn-primary.disabled:focus, .btn-primary.disabled.focus, .btn-primary[disabled]:hover, .btn-primary[disabled]:focus, .btn-primary[disabled].focus, fieldset[disabled] .btn-primary:hover, fieldset[disabled] .btn-primary:focus, fieldset[disabled] .btn-primary.focus { background-color: #2196f3; border-color: #0d8aee; } .btn-primary .badge { color: #2196f3; background-color: #fff; } .btn-success { color: #fff; background-color: #5cb85c; border-color: #4cae4c; } .btn-success:focus, .btn-success.focus { color: #fff; background-color: #449d44; border-color: #255625; } .btn-success:hover { color: #fff; background-color: #449d44; border-color: #398439; } .btn-success:active, .btn-success.active, .open > .btn-success.dropdown-toggle { color: #fff; background-color: #449d44; border-color: #398439; } .btn-success:active:hover, .btn-success:active:focus, .btn-success:active.focus, .btn-success.active:hover, .btn-success.active:focus, .btn-success.active.focus, .open > .btn-success.dropdown-toggle:hover, .open > .btn-success.dropdown-toggle:focus, .open > .btn-success.dropdown-toggle.focus { color: #fff; background-color: #398439; border-color: #255625; } .btn-success:active, .btn-success.active, .open > .btn-success.dropdown-toggle { background-image: none; } .btn-success.disabled:hover, .btn-success.disabled:focus, .btn-success.disabled.focus, .btn-success[disabled]:hover, .btn-success[disabled]:focus, .btn-success[disabled].focus, fieldset[disabled] .btn-success:hover, fieldset[disabled] .btn-success:focus, fieldset[disabled] .btn-success.focus { background-color: #5cb85c; border-color: #4cae4c; } .btn-success .badge { color: #5cb85c; background-color: #fff; } .btn-info { color: #fff; background-color: #56CCF2; border-color: #3ec5f0; } .btn-info:focus, .btn-info.focus { color: #fff; background-color: #27beee; border-color: #0d7ea3; } .btn-info:hover { color: #fff; background-color: #27beee; border-color: #11aee0; } .btn-info:active, .btn-info.active, .open > .btn-info.dropdown-toggle { color: #fff; background-color: #27beee; border-color: #11aee0; } .btn-info:active:hover, .btn-info:active:focus, .btn-info:active.focus, .btn-info.active:hover, .btn-info.active:focus, .btn-info.active.focus, .open > .btn-info.dropdown-toggle:hover, .open > .btn-info.dropdown-toggle:focus, .open > .btn-info.dropdown-toggle.focus { color: #fff; background-color: #11aee0; border-color: #0d7ea3; } .btn-info:active, .btn-info.active, .open > .btn-info.dropdown-toggle { background-image: none; } .btn-info.disabled:hover, .btn-info.disabled:focus, .btn-info.disabled.focus, .btn-info[disabled]:hover, .btn-info[disabled]:focus, .btn-info[disabled].focus, fieldset[disabled] .btn-info:hover, fieldset[disabled] .btn-info:focus, fieldset[disabled] .btn-info.focus { background-color: #56CCF2; border-color: #3ec5f0; } .btn-info .badge { color: #56CCF2; background-color: #fff; } .btn-warning { color: #fff; background-color: #F09819; border-color: #e18b0f; } .btn-warning:focus, .btn-warning.focus { color: #fff; background-color: #c97c0d; border-color: #694107; } .btn-warning:hover { color: #fff; background-color: #c97c0d; border-color: #a7670b; } .btn-warning:active, .btn-warning.active, .open > .btn-warning.dropdown-toggle { color: #fff; background-color: #c97c0d; border-color: #a7670b; } .btn-warning:active:hover, .btn-warning:active:focus, .btn-warning:active.focus, .btn-warning.active:hover, .btn-warning.active:focus, .btn-warning.active.focus, .open > .btn-warning.dropdown-toggle:hover, .open > .btn-warning.dropdown-toggle:focus, .open > .btn-warning.dropdown-toggle.focus { color: #fff; background-color: #a7670b; border-color: #694107; } .btn-warning:active, .btn-warning.active, .open > .btn-warning.dropdown-toggle { background-image: none; } .btn-warning.disabled:hover, .btn-warning.disabled:focus, .btn-warning.disabled.focus, .btn-warning[disabled]:hover, .btn-warning[disabled]:focus, .btn-warning[disabled].focus, fieldset[disabled] .btn-warning:hover, fieldset[disabled] .btn-warning:focus, fieldset[disabled] .btn-warning.focus { background-color: #F09819; border-color: #e18b0f; } .btn-warning .badge { color: #F09819; background-color: #fff; } .btn-danger { color: #fff; background-color: #FF512F; border-color: #ff3c16; } .btn-danger:focus, .btn-danger.focus { color: #fff; background-color: #fb2900; border-color: #951800; } .btn-danger:hover { color: #fff; background-color: #fb2900; border-color: #d72300; } .btn-danger:active, .btn-danger.active, .open > .btn-danger.dropdown-toggle { color: #fff; background-color: #fb2900; border-color: #d72300; } .btn-danger:active:hover, .btn-danger:active:focus, .btn-danger:active.focus, .btn-danger.active:hover, .btn-danger.active:focus, .btn-danger.active.focus, .open > .btn-danger.dropdown-toggle:hover, .open > .btn-danger.dropdown-toggle:focus, .open > .btn-danger.dropdown-toggle.focus { color: #fff; background-color: #d72300; border-color: #951800; } .btn-danger:active, .btn-danger.active, .open > .btn-danger.dropdown-toggle { background-image: none; } .btn-danger.disabled:hover, .btn-danger.disabled:focus, .btn-danger.disabled.focus, .btn-danger[disabled]:hover, .btn-danger[disabled]:focus, .btn-danger[disabled].focus, fieldset[disabled] .btn-danger:hover, fieldset[disabled] .btn-danger:focus, fieldset[disabled] .btn-danger.focus { background-color: #FF512F; border-color: #ff3c16; } .btn-danger .badge { color: #FF512F; background-color: #fff; } .btn-link { color: #2196f3; font-weight: normal; border-radius: 0; } .btn-link, .btn-link:active, .btn-link.active, .btn-link[disabled], fieldset[disabled] .btn-link { background-color: transparent; -webkit-box-shadow: none; box-shadow: none; } .btn-link, .btn-link:hover, .btn-link:focus, .btn-link:active { border-color: transparent; } .btn-link:hover, .btn-link:focus { color: #0a6ebd; text-decoration: underline; background-color: transparent; } .btn-link[disabled]:hover, .btn-link[disabled]:focus, fieldset[disabled] .btn-link:hover, fieldset[disabled] .btn-link:focus { color: #777777; text-decoration: none; } .btn-lg { padding: 10px 16px; font-size: 18px; line-height: 1.33333; border-radius: 6px; } .btn-sm { padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .btn-xs { padding: 1px 5px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .btn-block { display: block; width: 100%; } .btn-block + .btn-block { margin-top: 5px; } input[type=\"submit\"].btn-block, input[type=\"reset\"].btn-block, input[type=\"button\"].btn-block { width: 100%; } .fade { opacity: 0; -webkit-transition: opacity 0.15s linear; transition: opacity 0.15s linear; } .fade.in { opacity: 1; } .collapse { display: none; } .collapse.in { display: block; } tr.collapse.in { display: table-row; } tbody.collapse.in { display: table-row-group; } .collapsing { position: relative; height: 0; overflow: hidden; -webkit-transition-property: height,visibility; transition-property: height,visibility; -webkit-transition-duration: 0.35s; transition-duration: 0.35s; -webkit-transition-timing-function: ease; transition-timing-function: ease; } .caret { display: inline-block; width: 0; height: 0; margin-left: 2px; vertical-align: middle; border-top: 4px dashed; border-top: 4px solid \\9; border-right: 4px solid transparent; border-left: 4px solid transparent; } .dropup, .dropdown { position: relative; } .dropdown-toggle:focus { outline: 0; } .dropdown-menu { position: absolute; top: 100%; left: 0; z-index: 1000; display: none; float: left; min-width: 160px; padding: 5px 0; margin: 2px 0 0; list-style: none; font-size: 14px; text-align: left; background-color: #fff; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, 0.15); border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175); background-clip: padding-box; } .dropdown-menu.pull-right { right: 0; left: auto; } .dropdown-menu .divider { height: 1px; margin: 9.5px 0; overflow: hidden; background-color: #e5e5e5; } .dropdown-menu > li > a { display: block; padding: 3px 20px; clear: both; font-weight: normal; line-height: 1.57143; color: #333333; white-space: nowrap; } .dropdown-menu > li > a:hover, .dropdown-menu > li > a:focus { text-decoration: none; color: #262626; background-color: #f5f5f5; } .dropdown-menu > .active > a, .dropdown-menu > .active > a:hover, .dropdown-menu > .active > a:focus { color: #fff; text-decoration: none; outline: 0; background-color: #2196f3; } .dropdown-menu > .disabled > a, .dropdown-menu > .disabled > a:hover, .dropdown-menu > .disabled > a:focus { color: #777777; } .dropdown-menu > .disabled > a:hover, .dropdown-menu > .disabled > a:focus { text-decoration: none; background-color: transparent; background-image: none; filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); cursor: not-allowed; } .open > .dropdown-menu { display: block; } .open > a { outline: 0; } .dropdown-menu-right { left: auto; right: 0; } .dropdown-menu-left { left: 0; right: auto; } .dropdown-header { display: block; padding: 3px 20px; font-size: 12px; line-height: 1.57143; color: #777777; white-space: nowrap; } .dropdown-backdrop { position: fixed; left: 0; right: 0; bottom: 0; top: 0; z-index: 990; } .pull-right > .dropdown-menu { right: 0; left: auto; } .dropup .caret, .navbar-fixed-bottom .dropdown .caret { border-top: 0; border-bottom: 4px dashed; border-bottom: 4px solid \\9; content: \"\"; } .dropup .dropdown-menu, .navbar-fixed-bottom .dropdown .dropdown-menu { top: auto; bottom: 100%; margin-bottom: 2px; } .input-group { position: relative; display: table; border-collapse: separate; } .input-group[class*=\"col-\"] { float: none; padding-left: 0; padding-right: 0; } .input-group .form-control { position: relative; z-index: 2; float: left; width: 100%; margin-bottom: 0; } .input-group .form-control:focus { z-index: 3; } .input-group-addon, .input-group-btn, .input-group .form-control { display: table-cell; } .input-group-addon:not(:first-child):not(:last-child), .input-group-btn:not(:first-child):not(:last-child), .input-group .form-control:not(:first-child):not(:last-child) { border-radius: 0; } .input-group-addon, .input-group-btn { width: 1%; white-space: nowrap; vertical-align: middle; } .input-group-addon { padding: 6px 12px; font-size: 14px; font-weight: normal; line-height: 1; color: #555555; text-align: center; background-color: #eeeeee; border: 1px solid #ccc; border-radius: 4px; } .input-group-addon.input-sm, .input-group-sm > .input-group-addon, .input-group-sm > .input-group-btn > .input-group-addon.btn { padding: 5px 10px; font-size: 12px; border-radius: 3px; } .input-group-addon.input-lg, .input-group-lg > .input-group-addon, .input-group-lg > .input-group-btn > .input-group-addon.btn { padding: 10px 16px; font-size: 18px; border-radius: 6px; } .input-group-addon input[type=\"radio\"], .input-group-addon input[type=\"checkbox\"] { margin-top: 0; } .input-group .form-control:first-child, .input-group-addon:first-child, .input-group-btn:first-child > .btn, .input-group-btn:first-child > .btn-group > .btn, .input-group-btn:first-child > .dropdown-toggle, .input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle), .input-group-btn:last-child > .btn-group:not(:last-child) > .btn { border-bottom-right-radius: 0; border-top-right-radius: 0; } .input-group-addon:first-child { border-right: 0; } .input-group .form-control:last-child, .input-group-addon:last-child, .input-group-btn:last-child > .btn, .input-group-btn:last-child > .btn-group > .btn, .input-group-btn:last-child > .dropdown-toggle, .input-group-btn:first-child > .btn:not(:first-child), .input-group-btn:first-child > .btn-group:not(:first-child) > .btn { border-bottom-left-radius: 0; border-top-left-radius: 0; } .input-group-addon:last-child { border-left: 0; } .input-group-btn { position: relative; font-size: 0; white-space: nowrap; } .input-group-btn > .btn { position: relative; } .input-group-btn > .btn + .btn { margin-left: -1px; } .input-group-btn > .btn:hover, .input-group-btn > .btn:focus, .input-group-btn > .btn:active { z-index: 2; } .input-group-btn:first-child > .btn, .input-group-btn:first-child > .btn-group { margin-right: -1px; } .input-group-btn:last-child > .btn, .input-group-btn:last-child > .btn-group { z-index: 2; margin-left: -1px; } .nav { margin-bottom: 0; padding-left: 0; list-style: none; } .nav:before, .nav:after { content: \" \"; display: table; } .nav:after { clear: both; } .nav > li { position: relative; display: block; } .nav > li > a { position: relative; display: block; padding: 10px 15px; } .nav > li > a:hover, .nav > li > a:focus { text-decoration: none; background-color: #eeeeee; } .nav > li.disabled > a { color: #777777; } .nav > li.disabled > a:hover, .nav > li.disabled > a:focus { color: #777777; text-decoration: none; background-color: transparent; cursor: not-allowed; } .nav .open > a, .nav .open > a:hover, .nav .open > a:focus { background-color: #eeeeee; border-color: #2196f3; } .nav .nav-divider { height: 1px; margin: 9.5px 0; overflow: hidden; background-color: #e5e5e5; } .nav > li > a > img { max-width: none; } .nav-tabs { border-bottom: 1px solid #f2f2f2; } .nav-tabs > li { float: left; margin-bottom: -1px; } .nav-tabs > li > a { margin-right: 2px; line-height: 1.57143; border: 1px solid transparent; border-radius: 4px 4px 0 0; } .nav-tabs > li > a:hover { border-color: #eeeeee #eeeeee #f2f2f2; } .nav-tabs > li.active > a, .nav-tabs > li.active > a:hover, .nav-tabs > li.active > a:focus { color: #555555; background-color: #fff; border: 1px solid #f2f2f2; border-bottom-color: transparent; cursor: default; } .nav-pills > li { float: left; } .nav-pills > li > a { border-radius: 4px; } .nav-pills > li + li { margin-left: 2px; } .nav-pills > li.active > a, .nav-pills > li.active > a:hover, .nav-pills > li.active > a:focus { color: #fff; background-color: #2196f3; } .nav-stacked > li { float: none; } .nav-stacked > li + li { margin-top: 2px; margin-left: 0; } .nav-justified, .nav-tabs.nav-justified { width: 100%; } .nav-justified > li, .nav-tabs.nav-justified > li { float: none; } .nav-justified > li > a, .nav-tabs.nav-justified > li > a { text-align: center; margin-bottom: 5px; } .nav-justified > .dropdown .dropdown-menu { top: auto; left: auto; } .nav-tabs-justified, .nav-tabs.nav-justified { border-bottom: 0; } .nav-tabs-justified > li > a, .nav-tabs.nav-justified > li > a { margin-right: 0; border-radius: 4px; } .nav-tabs-justified > .active > a, .nav-tabs.nav-justified > .active > a, .nav-tabs-justified > .active > a:hover, .nav-tabs.nav-justified > .active > a:hover, .nav-tabs-justified > .active > a:focus, .nav-tabs.nav-justified > .active > a:focus { border: 1px solid #f2f2f2; } .tab-content > .tab-pane { display: none; } .tab-content > .active { display: block; } .nav-tabs .dropdown-menu { margin-top: -1px; border-top-right-radius: 0; border-top-left-radius: 0; } .navbar { position: relative; min-height: 50px; margin-bottom: 21px; border: 1px solid transparent; } .navbar:before, .navbar:after { content: \" \"; display: table; } .navbar:after { clear: both; } .navbar-header:before, .navbar-header:after { content: \" \"; display: table; } .navbar-header:after { clear: both; } .navbar-collapse { overflow-x: visible; padding-right: 15px; padding-left: 15px; border-top: 1px solid transparent; -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1); box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1); -webkit-overflow-scrolling: touch; } .navbar-collapse:before, .navbar-collapse:after { content: \" \"; display: table; } .navbar-collapse:after { clear: both; } .navbar-collapse.in { overflow-y: auto; } .navbar-fixed-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { max-height: 340px; } .container > .navbar-header, .container > .navbar-collapse, .container-fluid > .navbar-header, .container-fluid > .navbar-collapse { margin-right: -15px; margin-left: -15px; } .navbar-static-top { z-index: 1000; border-width: 0 0 1px; } .navbar-fixed-top, .navbar-fixed-bottom { position: fixed; right: 0; left: 0; z-index: 1030; } .navbar-fixed-top { top: 0; border-width: 0 0 1px; } .navbar-fixed-bottom { bottom: 0; margin-bottom: 0; border-width: 1px 0 0; } .navbar-brand { float: left; padding: 14.5px 15px; font-size: 18px; line-height: 21px; height: 50px; } .navbar-brand:hover, .navbar-brand:focus { text-decoration: none; } .navbar-brand > img { display: block; } .navbar-toggle { position: relative; float: right; margin-right: 15px; padding: 10px 10px; margin-top: 8px; margin-bottom: 8px; background-color: transparent; background-image: none; border: 1px solid transparent; border-radius: 4px; } .navbar-toggle:focus { outline: 0; } .navbar-toggle .icon-bar { display: block; width: 22px; height: 2px; border-radius: 1px; } .navbar-toggle .icon-bar + .icon-bar { margin-top: 3px; } .navbar-nav { margin: 7.25px -15px; } .navbar-nav > li > a { padding-top: 10px; padding-bottom: 10px; line-height: 21px; } .navbar-form { margin-left: -15px; margin-right: -15px; padding: 10px 15px; border-top: 1px solid transparent; border-bottom: 1px solid transparent; -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1),0 1px 0 rgba(255, 255, 255, 0.1); box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1),0 1px 0 rgba(255, 255, 255, 0.1); margin-top: 7.5px; margin-bottom: 7.5px; } .navbar-nav > li > .dropdown-menu { margin-top: 0; border-top-right-radius: 0; border-top-left-radius: 0; } .navbar-fixed-bottom .navbar-nav > li > .dropdown-menu { margin-bottom: 0; border-top-right-radius: 4px; border-top-left-radius: 4px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .navbar-btn { margin-top: 7.5px; margin-bottom: 7.5px; } .navbar-btn.btn-sm { margin-top: 10px; margin-bottom: 10px; } .navbar-btn.btn-xs { margin-top: 14px; margin-bottom: 14px; } .navbar-text { margin-top: 14.5px; margin-bottom: 14.5px; } .navbar-default { background-color: #f8f8f8; border-color: #e7e7e7; } .navbar-default .navbar-brand { color: #777; } .navbar-default .navbar-brand:hover, .navbar-default .navbar-brand:focus { color: #5e5e5e; background-color: transparent; } .navbar-default .navbar-text { color: #777; } .navbar-default .navbar-nav > li > a { color: #777; } .navbar-default .navbar-nav > li > a:hover, .navbar-default .navbar-nav > li > a:focus { color: #333; background-color: transparent; } .navbar-default .navbar-nav > .active > a, .navbar-default .navbar-nav > .active > a:hover, .navbar-default .navbar-nav > .active > a:focus { color: #555; background-color: #e7e7e7; } .navbar-default .navbar-nav > .disabled > a, .navbar-default .navbar-nav > .disabled > a:hover, .navbar-default .navbar-nav > .disabled > a:focus { color: #ccc; background-color: transparent; } .navbar-default .navbar-toggle { border-color: #ddd; } .navbar-default .navbar-toggle:hover, .navbar-default .navbar-toggle:focus { background-color: #ddd; } .navbar-default .navbar-toggle .icon-bar { background-color: #888; } .navbar-default .navbar-collapse, .navbar-default .navbar-form { border-color: #e7e7e7; } .navbar-default .navbar-nav > .open > a, .navbar-default .navbar-nav > .open > a:hover, .navbar-default .navbar-nav > .open > a:focus { background-color: #e7e7e7; color: #555; } .navbar-default .navbar-link { color: #777; } .navbar-default .navbar-link:hover { color: #333; } .navbar-default .btn-link { color: #777; } .navbar-default .btn-link:hover, .navbar-default .btn-link:focus { color: #333; } .navbar-default .btn-link[disabled]:hover, .navbar-default .btn-link[disabled]:focus, fieldset[disabled] .navbar-default .btn-link:hover, fieldset[disabled] .navbar-default .btn-link:focus { color: #ccc; } .navbar-inverse { background-color: #222; border-color: #090909; } .navbar-inverse .navbar-brand { color: #9d9d9d; } .navbar-inverse .navbar-brand:hover, .navbar-inverse .navbar-brand:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-text { color: #9d9d9d; } .navbar-inverse .navbar-nav > li > a { color: #9d9d9d; } .navbar-inverse .navbar-nav > li > a:hover, .navbar-inverse .navbar-nav > li > a:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-nav > .active > a, .navbar-inverse .navbar-nav > .active > a:hover, .navbar-inverse .navbar-nav > .active > a:focus { color: #fff; background-color: #090909; } .navbar-inverse .navbar-nav > .disabled > a, .navbar-inverse .navbar-nav > .disabled > a:hover, .navbar-inverse .navbar-nav > .disabled > a:focus { color: #444; background-color: transparent; } .navbar-inverse .navbar-toggle { border-color: #333; } .navbar-inverse .navbar-toggle:hover, .navbar-inverse .navbar-toggle:focus { background-color: #333; } .navbar-inverse .navbar-toggle .icon-bar { background-color: #fff; } .navbar-inverse .navbar-collapse, .navbar-inverse .navbar-form { border-color: #101010; } .navbar-inverse .navbar-nav > .open > a, .navbar-inverse .navbar-nav > .open > a:hover, .navbar-inverse .navbar-nav > .open > a:focus { background-color: #090909; color: #fff; } .navbar-inverse .navbar-link { color: #9d9d9d; } .navbar-inverse .navbar-link:hover { color: #fff; } .navbar-inverse .btn-link { color: #9d9d9d; } .navbar-inverse .btn-link:hover, .navbar-inverse .btn-link:focus { color: #fff; } .navbar-inverse .btn-link[disabled]:hover, .navbar-inverse .btn-link[disabled]:focus, fieldset[disabled] .navbar-inverse .btn-link:hover, fieldset[disabled] .navbar-inverse .btn-link:focus { color: #444; } .pager { padding-left: 0; margin: 21px 0; list-style: none; text-align: center; } .pager:before, .pager:after { content: \" \"; display: table; } .pager:after { clear: both; } .pager li { display: inline; } .pager li > a, .pager li > span { display: inline-block; padding: 5px 14px; background-color: #fff; border: 1px solid #ddd; border-radius: 15px; } .pager li > a:hover, .pager li > a:focus { text-decoration: none; background-color: #eeeeee; } .pager .next > a, .pager .next > span { float: right; } .pager .previous > a, .pager .previous > span { float: left; } .pager .disabled > a, .pager .disabled > a:hover, .pager .disabled > a:focus, .pager .disabled > span { color: #777777; background-color: #fff; cursor: not-allowed; } .badge { display: inline-block; min-width: 10px; padding: 3px 7px; font-size: 12px; font-weight: bold; color: #fff; line-height: 1; vertical-align: middle; white-space: nowrap; text-align: center; background-color: #777777; border-radius: 10px; } .badge:empty { display: none; } .btn .badge { position: relative; top: -1px; } .btn-xs .badge, .btn-group-xs > .btn .badge { top: 0; padding: 1px 5px; } .list-group-item.active > .badge, .nav-pills > .active > a > .badge { color: #2196f3; background-color: #fff; } .list-group-item > .badge { float: right; } .list-group-item > .badge + .badge { margin-right: 5px; } .nav-pills > li > a > .badge { margin-left: 3px; } a.badge:hover, a.badge:focus { color: #fff; text-decoration: none; cursor: pointer; } .thumbnail { display: block; padding: 4px; margin-bottom: 21px; line-height: 1.57143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: border 0.2s ease-in-out; transition: border 0.2s ease-in-out; } .thumbnail > img, .thumbnail a > img { display: block; max-width: 100%; height: auto; margin-left: auto; margin-right: auto; } .thumbnail .caption { padding: 9px; color: #333333; } a.thumbnail:hover, a.thumbnail:focus, a.thumbnail.active { border-color: #2196f3; } .media { margin-top: 15px; } .media:first-child { margin-top: 0; } .media, .media-body { zoom: 1; overflow: hidden; } .media-body { width: 10000px; } .media-object { display: block; } .media-object.img-thumbnail { max-width: none; } .media-right, .media > .pull-right { padding-left: 10px; } .media-left, .media > .pull-left { padding-right: 10px; } .media-left, .media-right, .media-body { display: table-cell; vertical-align: top; } .media-middle { vertical-align: middle; } .media-middle .media-left, .media-middle .media-right, .media-middle .media-body { vertical-align: middle; } .media-bottom { vertical-align: bottom; } .media-bottom .media-left, .media-bottom .media-right, .media-bottom .media-body { vertical-align: bottom; } .media-heading { margin-top: 0; margin-bottom: 5px; } .media-list { padding-left: 0; list-style: none; } .embed-responsive { position: relative; display: block; height: 0; padding: 0; overflow: hidden; } .embed-responsive .embed-responsive-item, .embed-responsive iframe, .embed-responsive embed, .embed-responsive object, .embed-responsive video { position: absolute; top: 0; left: 0; bottom: 0; height: 100%; width: 100%; border: 0; } .embed-responsive-16by9 { padding-bottom: 56.25%; } .embed-responsive-4by3 { padding-bottom: 75%; } .well { min-height: 20px; padding: 19px; margin-bottom: 20px; background-color: #f5f5f5; border: 1px solid #e3e3e3; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05); box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05); } .well blockquote { border-color: #ddd; border-color: rgba(0, 0, 0, 0.15); } .well-lg { padding: 24px; border-radius: 6px; } .well-sm { padding: 9px; border-radius: 3px; } .close { float: right; font-size: 24px; line-height: 1; color: #000; text-shadow: 0 1px 0 #fff; opacity: 0.2; filter: alpha(opacity=20); } .close:hover, .close:focus { color: #000; text-decoration: none; cursor: pointer; opacity: 0.5; filter: alpha(opacity=50); } button.close { padding: 0; cursor: pointer; background: transparent; border: 0; -webkit-appearance: none; } .modal-open { overflow: hidden; } .modal { display: none; overflow: hidden; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1050; -webkit-overflow-scrolling: touch; outline: 0; } .modal.fade .modal-dialog { -webkit-transform: translate(0, -25%); -ms-transform: translate(0, -25%); transform: translate(0, -25%); -webkit-transition: -webkit-transform 0.3s ease-out; transition: -webkit-transform 0.3s ease-out; transition: transform 0.3s ease-out; transition: transform 0.3s ease-out,-webkit-transform 0.3s ease-out; } .modal.in .modal-dialog { -webkit-transform: translate(0, 0); -ms-transform: translate(0, 0); transform: translate(0, 0); } .modal-open .modal { overflow-x: hidden; overflow-y: auto; } .modal-dialog { position: relative; width: auto; margin: 10px; } .modal-content { position: relative; background-color: #fff; border-radius: 6px; -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, 0.05); box-shadow: 0 3px 9px rgba(0, 0, 0, 0.05); background-clip: padding-box; outline: 0; } .modal-backdrop { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1040; background-color: #000; } .modal-backdrop.fade { opacity: 0; filter: alpha(opacity=0); } .modal-backdrop.in { opacity: 0.5; filter: alpha(opacity=50); } .modal-header { padding: 15px; border-bottom: 1px solid #e5e5e5; } .modal-header:before, .modal-header:after { content: \" \"; display: table; } .modal-header:after { clear: both; } .modal-header .close { margin-top: -2px; } .modal-title { margin: 0; line-height: 1.57143; } .modal-body { position: relative; padding: 15px; } .modal-footer { padding: 15px; text-align: right; border-top: 1px solid #e5e5e5; } .modal-footer:before, .modal-footer:after { content: \" \"; display: table; } .modal-footer:after { clear: both; } .modal-footer .btn + .btn { margin-left: 5px; margin-bottom: 0; } .modal-footer .btn-group .btn + .btn { margin-left: -1px; } .modal-footer .btn-block + .btn-block { margin-left: 0; } .modal-scrollbar-measure { position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll; } .tooltip { position: absolute; z-index: 1070; display: block; font-family: \"PingHei\",\"PingFang SC\",Helvetica Neue,\"Work Sans\",\"Hiragino Sans GB\",\"Microsoft YaHei\",SimSun,sans-serif; font-style: normal; font-weight: normal; letter-spacing: normal; line-break: auto; line-height: 1.57143; text-align: left; text-align: start; text-decoration: none; text-shadow: none; text-transform: none; white-space: normal; word-break: normal; word-spacing: normal; word-wrap: normal; font-size: 12px; opacity: 0; filter: alpha(opacity=0); } .tooltip.in { opacity: 0.9; filter: alpha(opacity=90); } .tooltip.top { margin-top: -3px; padding: 5px 0; } .tooltip.right { margin-left: 3px; padding: 0 5px; } .tooltip.bottom { margin-top: 3px; padding: 5px 0; } .tooltip.left { margin-left: -3px; padding: 0 5px; } .tooltip-inner { max-width: 200px; padding: 3px 8px; color: #fff; text-align: center; background-color: #000; border-radius: 4px; } .tooltip-arrow { position: absolute; width: 0; height: 0; border-color: transparent; border-style: solid; } .tooltip.top .tooltip-arrow { bottom: 0; left: 50%; margin-left: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.top-left .tooltip-arrow { bottom: 0; right: 5px; margin-bottom: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.top-right .tooltip-arrow { bottom: 0; left: 5px; margin-bottom: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.right .tooltip-arrow { top: 50%; left: 0; margin-top: -5px; border-width: 5px 5px 5px 0; border-right-color: #000; } .tooltip.left .tooltip-arrow { top: 50%; right: 0; margin-top: -5px; border-width: 5px 0 5px 5px; border-left-color: #000; } .tooltip.bottom .tooltip-arrow { top: 0; left: 50%; margin-left: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .tooltip.bottom-left .tooltip-arrow { top: 0; right: 5px; margin-top: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .tooltip.bottom-right .tooltip-arrow { top: 0; left: 5px; margin-top: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .clearfix:before, .clearfix:after { content: \" \"; display: table; } .clearfix:after { clear: both; } .center-block { display: block; margin-left: auto; margin-right: auto; } .pull-right { float: right !important; } .pull-left { float: left !important; } .hide { display: none !important; } .show { display: block !important; } .invisible { visibility: hidden; } .text-hide { font: 0/0 a; color: transparent; text-shadow: none; background-color: transparent; border: 0; } .hidden { display: none !important; } .affix { position: fixed; } @-ms-viewport { width: device-width; } .visible-xs { display: none !important; } .visible-sm { display: none !important; } .visible-md { display: none !important; } .visible-lg { display: none !important; } .visible-xs-block, .visible-xs-inline, .visible-xs-inline-block, .visible-sm-block, .visible-sm-inline, .visible-sm-inline-block, .visible-md-block, .visible-md-inline, .visible-md-inline-block, .visible-lg-block, .visible-lg-inline, .visible-lg-inline-block { display: none !important; } .visible-print { display: none !important; } .visible-print-block { display: none !important; } .visible-print-inline { display: none !important; } .visible-print-inline-block { display: none !important; } /** * application */ /*! * IE10 viewport hack for Surface/desktop Windows 8 bug * Copyright 2014-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ /* * See the Getting Started docs for more information: * http://getbootstrap.com/getting-started/#support-ie10-width */ @-ms-viewport { width: device-width; } @-o-viewport { width: device-width; } @viewport { width: device-width; } /* * scrollbar */ ::-webkit-scrollbar { width: 6px; height: 4px; background: transparent; } ::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.15); } ::-webkit-scrollbar-thumb:window-inactive { background: rgba(0, 0, 0, 0.1); } ::-webkit-scrollbar-thumb:vertical { height: 4px; background: rgba(0, 0, 0, 0.15); } ::-webkit-scrollbar-thumb:horizontal { width: 4px; background: rgba(0, 0, 0, 0.15); } ::-webkit-scrollbar-thumb:vertical:hover { background-color: rgba(0, 0, 0, 0.3); } ::-webkit-scrollbar-thumb:vertical:active { background-color: rgba(0, 0, 0, 0.5); } ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); -webkit-box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1); box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1); } ::-webkit-scrollbar-track-piece { background: rgba(0, 0, 0, 0.15); } *, *:before, *:after { -webkit-box-sizing: border-box; box-sizing: border-box; } html, body { position: relative; overflow-x: hidden; } body { padding-right: 0 !important; font-family: \"PingHei\",\"PingFang SC\",Helvetica Neue,\"Work Sans\",\"Hiragino Sans GB\",\"Microsoft YaHei\",SimSun,sans-serif; font-size: 14px; line-height: 1.57143; color: #333333; background-color: #fff; } a { color: #333333; text-decoration: none; } a:focus, a:hover { color: #0a6ebd; text-decoration: none; } a.active { color: #0a6ebd; } .active > a { color: #0a6ebd; } input, button, select, textarea, .btn { outline: none !important; } input:focus, input:hover, input:active, button:focus, button:hover, button:active, select:focus, select:hover, select:active, textarea:focus, textarea:hover, textarea:active, .btn:focus, .btn:hover, .btn:active { outline: none !important; } /*------------------ Fluidity response ------------------------------*/ img, canvas, iframe, video, svg { max-width: 100%; height: auto; } /*------------------ clear ------------------------------*/ .clear { height: 0; font-size: 0; line-height: 0; overflow: hidden; clear: both; } .clearfix:before, .clearfix:after { display: table; line-height: 0; content: \"\"; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; } /*other*/ .clickable { cursor: pointer; } .scrollable { overflow-x: hidden; overflow-y: auto; } /*transform*/ .transform-no { -ms-transform: none !important; -webkit-transform: none !important; transform: none !important; } /*---------------------------------------------------- * color *---------------------------------------------------*/ .text-dark { color: #333 !important; } .text-grey { color: #999 !important; } /*text-white*/ .text-white { color: #fff !important; } .text-white a:hover, .text-white a:hover i, .text-white:hover { color: rgba(255, 255, 255, 0.8); } .text-white a.list-group-item.active i { color: #fff; } .text-white .accordion-list p { font-size: 12px; height: 84px; line-height: 21px; color: rgba(255, 255, 255, 0.8); } /*background-color*/ .bg-no { background: none !important; } .bg-alpha { background-color: transparent !important; } .bg-inverse, .bg-inverse a { color: #fff; } .btn.bg-inverse:hover, .btn.bg-inverse:focus, .btn.bg-inverse.focus { color: rgba(255, 255, 255, 0.8); } .bg { background-color: #f6f6f6 !important; } /*---------------------------------------------------- * z-index *---------------------------------------------------*/ .z-no { z-index: inherit; } .z1 { z-index: 1; } .z2 { z-index: 2; } .z3 { z-index: 3; } .z4 { z-index: 4; } .zmin { z-index: -1; } .zmax { z-index: 999; } /*---------------------------------------------------- * margin *---------------------------------------------------*/ /* All */ .m { margin: 5px !important; } .m-no { margin: 0 !important; } .m-0x { margin: 10px !important; } .m-1x { margin: 15px !important; } .m-2x { margin: 20px !important; } .m-3x { margin: 30px !important; } .m-4x { margin: 60px !important; } .m-5x { margin: 100px !important; } /* Vertical */ .mv { margin-top: 5px !important; margin-bottom: 5px !important; } .mv-no { margin-top: 0 !important; margin-bottom: 0 !important; } .mv-0x { margin-top: 10px !important; margin-bottom: 10px !important; } .mv-1x { margin-top: 15px !important; margin-bottom: 15px !important; } .mv-2x { margin-top: 20px !important; margin-bottom: 20px !important; } .mv-3x { margin-top: 30px !important; margin-bottom: 30px !important; } .mv-4x { margin-top: 60px !important; margin-bottom: 60px !important; } .mv-5x { margin-top: 100px !important; margin-bottom: 100px !important; } /* Horizontal */ .mh { margin-left: 5px !important; margin-right: 5px !important; } .mh-no { margin-left: 0 !important; margin-right: 0 !important; } .mh-0x { margin-left: 10px !important; margin-right: 10px !important; } .mh-1x { margin-left: 15px !important; margin-right: 15px !important; } .mh-2x { margin-left: 20px !important; margin-right: 20px !important; } .mh-3x { margin-left: 30px !important; margin-right: 30px !important; } .mh-4x { margin-left: 60px !important; margin-right: 60px !important; } .mh-5x { margin-left: 100px !important; margin-right: 100px !important; } /* margin Top */ .mt { margin-top: 5px !important; } .mt-no { margin-top: 0 !important; } .mt-0x { margin-top: 10px !important; } .mt-1x { margin-top: 15px !important; } .mt-2x { margin-top: 20px !important; } .mt-3x { margin-top: 30px !important; } .mt-4x { margin-top: 60px !important; } .mt-5x { margin-top: 100px !important; } /* margin Bottom */ .mb { margin-bottom: 5px !important; } .mb-no { margin-bottom: 0 !important; } .mb-0x { margin-bottom: 10px !important; } .mb-1x { margin-bottom: 15px !important; } .mb-2x { margin-bottom: 20px !important; } .mb-3x { margin-bottom: 30px !important; } .mb-4x { margin-bottom: 60px !important; } .mb-5x { margin-bottom: 100px !important; } /* margin left */ .ml { margin-left: 5px !important; } .ml-no { margin-left: 0 !important; } .ml-0x { margin-left: 10px !important; } .ml-1x { margin-left: 15px !important; } .ml-2x { margin-left: 20px !important; } .ml-3x { margin-left: 30px !important; } .ml-4x { margin-left: 60px !important; } .ml-5x { margin-left: 100px !important; } /* margin right */ .mr { margin-right: 5px !important; } .mr-no { margin-right: 0 !important; } .mr-0x { margin-right: 10px !important; } .mr-1x { margin-right: 15px !important; } .mr-2x { margin-right: 20px !important; } .mr-3x { margin-right: 30px !important; } .mr-4x { margin-right: 60px !important; } .mr-5x { margin-right: 100px !important; } /*---------------------------------------------------- * padding *---------------------------------------------------*/ /* All */ .p { padding: 5px !important; } .p-no { padding: 0 !important; } .p-0x { padding: 10px !important; } .p-1x { padding: 15px !important; } .p-2x { padding: 20px !important; } .p-3x { padding: 30px !important; } .p-4x { padding: 60px !important; } .p-5x { padding: 100px !important; } /* Vertical */ .pv { padding-top: 5px !important; padding-bottom: 5px !important; } .pv-no { padding-top: 0 !important; padding-bottom: 0 !important; } .pv-0x { padding-top: 10px !important; padding-bottom: 10px !important; } .pv-1x { padding-top: 15px !important; padding-bottom: 15px !important; } .pv-2x { padding-top: 20px !important; padding-bottom: 20px !important; } .pv-3x { padding-top: 30px !important; padding-bottom: 30px !important; } .pv-4x { padding-top: 60px !important; padding-bottom: 60px !important; } .pv-5x { padding-top: 100px !important; padding-bottom: 100px !important; } /* Horizontal */ .ph { padding-left: 5px !important; padding-right: 5px !important; } .ph-no { padding-left: 0 !important; padding-right: 0 !important; } .ph-0x { padding-left: 10px !important; padding-right: 10px !important; } .ph-1x { padding-left: 15px !important; padding-right: 15px !important; } .ph-2x { padding-left: 20px !important; padding-right: 20px !important; } .ph-3x { padding-left: 30px !important; padding-right: 30px !important; } .ph-4x { padding-left: 60px !important; padding-right: 60px !important; } .ph-5x { padding-left: 100px !important; padding-right: 100px !important; } /* padding Top */ .pt { padding-top: 5px !important; } .pt-no { padding-top: 0 !important; } .pt-0x { padding-top: 10px !important; } .pt-1x { padding-top: 15px !important; } .pt-2x { padding-top: 20px !important; } .pt-3x { padding-top: 30px !important; } .pt-4x { padding-top: 60px !important; } .pt-5x { padding-top: 100px !important; } /* padding Bottom */ .pb { padding-bottom: 5px !important; } .pb-no { padding-bottom: 0 !important; } .pb-0x { padding-bottom: 10px !important; } .pb-1x { padding-bottom: 15px !important; } .pb-2x { padding-bottom: 20px !important; } .pb-3x { padding-bottom: 30px !important; } .pb-4x { padding-bottom: 60px !important; } .pb-5x { padding-bottom: 100px !important; } /* padding left */ .pl { padding-left: 5px !important; } .pl-no { padding-left: 0 !important; } .pl-0x { padding-left: 10px !important; } .pl-1x { padding-left: 15px !important; } .pl-2x { padding-left: 20px !important; } .pl-3x { padding-left: 30px !important; } .pl-4x { padding-left: 60px !important; } .pl-5x { padding-left: 100px !important; } /* padding right */ .pr { padding-right: 5px !important; } .pr-no { padding-right: 0 !important; } .pr-0x { padding-right: 10px !important; } .pr-1x { padding-right: 15px !important; } .pr-2x { padding-right: 20px !important; } .pr-3x { padding-right: 30px !important; } .pr-4x { padding-right: 60px !important; } .pr-5x { padding-right: 100px !important; } /*---------------------------------------------------- * border *---------------------------------------------------*/ .b { border: 1px solid #ddd; } .b-no { border: none !important; } /*---------------------------------------------------- * border-radius *---------------------------------------------------*/ /*----------------------css border-radius----------------*/ .r-rounded { border-radius: 2em !important; padding-left: 1em; padding-right: 1em; overflow: hidden; } .r-circle { border-radius: 50% !important; overflow: hidden; } .r-no { border-radius: 0 !important; } /*---------------------------------------------------- * width and height *---------------------------------------------------*/ .w-auto { width: auto !important; } .w-full, .w-full img { width: 100% !important; max-width: 100% !important; } /*---------------------------------------------------- * text *---------------------------------------------------*/ .lh-2x { line-height: 2.0; } /*----------------- css text --------------------*/ .text-break { word-break: break-all !important; word-wrap: break-word !important; } .text-undecorate { text-decoration: none !important; } .text-underline { text-decoration: underline !important; } .text-through { text-decoration: line-through !important; } .text-sub { vertical-align: sub !important; } .text-super { vertical-align: super !important; } .text-indent, .text-indent p, .text-indent div { text-indent: 2em; } /*text wrap*/ .text-nowrap { /*display: block;*/ max-width: 100%; overflow: hidden !important; text-overflow: ellipsis !important; white-space: nowrap !important; word-wrap: normal !important; -moz-binding: url(\"ellipsis.xml\"); } .text-nowrap-1x { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 1; -webkit-box-flex: 1; line-height: 24px; height: 24px; word-break: break-all !important; word-wrap: break-word !important; } .text-nowrap-2x { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 2; line-height: 24px; height: 48px; word-break: break-all !important; word-wrap: break-word !important; } .text-nowrap-3x { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 3; line-height: 24px; height: 72px; word-break: break-all !important; word-wrap: break-word !important; } .text-nowrap-4x { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 4; line-height: 24px; height: 96px; word-break: break-all !important; word-wrap: break-word !important; } .text-nowrap-5x { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 5; line-height: 24px; height: 120px; word-break: break-all !important; word-wrap: break-word !important; } /*---------------------------------------------------- * thumb *---------------------------------------------------*/ .thumb { width: 16px; display: inline-block; overflow: hidden; } .thumb-xs { width: 32px; display: inline-block; overflow: hidden; } .thumb-sm { width: 48px; display: inline-block; overflow: hidden; } .thumb-md { width: 64px; display: inline-block; overflow: hidden; } .thumb-lg { width: 96px; display: inline-block; overflow: hidden; } .thumb-xl { width: 128px; display: inline-block; overflow: hidden; } .thumb-wrapper { padding: 2px; border: 1px solid #dbe2e7; } .thumb img, .thumb-0x img, .thumb-1x img, .thumb-2x img, .thumb-3x img, .thumb-4x img, .thumb-5x img, .thumb-6x img, .thumb-btn img { height: auto; max-width: 100%; vertical-align: middle; } /*---------------------------------------------------- * img hover style *---------------------------------------------------*/ /*img gray*/ img.img-gray, .img-gray img { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); -webkit-filter: gray; filter: gray; } img.img-gray:hover, .img-gray:hover img { -webkit-filter: grayscale(0); -moz-filter: grayscale(0); -ms-filter: grayscale(0); -o-filter: grayscale(0); filter: grayscale(0); } /*img-rotate*/ img.img-rotate, .img-rotate img { -webkit-transition: -webkit-transform 0.3s ease; transition: -webkit-transform 0.3s ease; transition: transform 0.3s ease; transition: transform 0.3s ease,-webkit-transform 0.3s ease; } img.img-rotate:hover, .img-rotate:hover img { transform: rotate(360deg); -ms-transform: rotate(360deg); /* IE 9 */ -moz-transform: rotate(360deg); /* Firefox */ -webkit-transform: rotate(360deg); /* Safari and Chrome */ -o-transform: rotate(360deg); } /*img-burn*/ img.img-burn, .img-burn img { position: relative; -webkit-transition: all 0.8s ease-in-out; transition: all 0.8s ease-in-out; } img.img-burn:hover, .img-burn:hover img { -webkit-transform: scale(1.2) rotate(2deg); -ms-transform: scale(1.2) rotate(2deg); transform: scale(1.2) rotate(2deg); } /*hover-up*/ img.hover-up, .hover-up img { position: relative; top: 0; -webkit-transition: top .3s ease-out; transition: top .3s ease-out; } img.hover-up:hover, .hover-up:hover img { top: -6px; } /*Button components*/ .text-active, .active > .text, .active > .auto .text, .collapsed > .text, .collapsed > .auto .text { display: none !important; } .active > .text-active, .active > .auto .text-active, .collapsed > .text-active, .collapsed > .auto .text-active { display: inline-block !important; } /*Button components end here*/ /** * paper */ .shadow-no { -webkit-box-shadow: none; box-shadow: none; } .shadow, .hover-shadow:hover { -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); } /*radio*/ .radio { margin-left: 20px; } .radio label { display: inline-block; position: relative; padding-left: 5px; } .radio label:before { content: \"\"; display: inline-block; position: absolute; width: 17px; height: 17px; left: 0; margin-left: -20px; border: 1px solid #cccccc; border-radius: 50%; background-color: #fff; -webkit-transition: border 0.15s ease-in-out; transition: border 0.15s ease-in-out; } .radio label:after { display: inline-block; position: absolute; content: \" \"; width: 11px; height: 11px; left: 3px; top: 3px; margin-left: -20px; border-radius: 50%; background-color: #555555; -webkit-transform: scale(0, 0); -ms-transform: scale(0, 0); transform: scale(0, 0); -webkit-transition: -webkit-transform 0.1s cubic-bezier(0.8, -0.33, 0.2, 1.33); transition: -webkit-transform 0.1s cubic-bezier(0.8, -0.33, 0.2, 1.33); transition: transform 0.1s cubic-bezier(0.8, -0.33, 0.2, 1.33); transition: transform 0.1s cubic-bezier(0.8, -0.33, 0.2, 1.33),-webkit-transform 0.1s cubic-bezier(0.8, -0.33, 0.2, 1.33); } .radio input[type=radio] { display: none; } .radio input[type=radio]:checked + label:after { -webkit-transform: scale(1, 1); -ms-transform: scale(1, 1); transform: scale(1, 1); } .radio input[type=radio]:disabled + label { opacity: 0.65; } .radio input[type=radio]:disabled + label:before { cursor: not-allowed; } .hover-grow { -webkit-transition: all .2s linear; transition: all .2s linear; } .hover-grow:hover { -webkit-transform: translate3d(0, -2px, 0); transform: translate3d(0, -2px, 0); } fieldset { padding: 0; margin: 0; border: 0; min-width: 0; } legend { display: block; width: 100%; padding: 0; margin-bottom: 21px; font-size: 21px; line-height: inherit; color: #333333; border: 0; border-bottom: 1px solid #e5e5e5; } label { display: inline-block; max-width: 100%; margin-bottom: 5px; font-weight: bold; } input[type=\"search\"] { -webkit-box-sizing: border-box; box-sizing: border-box; } input[type=\"radio\"], input[type=\"checkbox\"] { margin: 4px 0 0; margin-top: 1px \\9; line-height: normal; } input[type=\"file\"] { display: block; } input[type=\"range\"] { display: block; width: 100%; } select[multiple], select[size] { height: auto; } input[type=\"file\"]:focus, input[type=\"radio\"]:focus, input[type=\"checkbox\"]:focus { outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } output { display: block; padding-top: 7px; font-size: 14px; line-height: 1.57143; color: #555555; } .form-control { display: block; width: 100%; height: 35px; padding: 6px 12px; font-size: 14px; line-height: 1.57143; color: #555555; background-color: #fff; background-image: none; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075); -webkit-transition: border-color ease-in-out 0.15s,box-shadow ease-in-out 0.15s; -webkit-transition: border-color ease-in-out 0.15s,-webkit-box-shadow ease-in-out 0.15s; transition: border-color ease-in-out 0.15s,-webkit-box-shadow ease-in-out 0.15s; transition: border-color ease-in-out 0.15s,box-shadow ease-in-out 0.15s; transition: border-color ease-in-out 0.15s,box-shadow ease-in-out 0.15s,-webkit-box-shadow ease-in-out 0.15s; } .form-control:focus { border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 8px rgba(102, 175, 233, 0.6); box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 8px rgba(102, 175, 233, 0.6); } .form-control::-moz-placeholder { color: #999; opacity: 1; } .form-control:-ms-input-placeholder { color: #999; } .form-control::-webkit-input-placeholder { color: #999; } .form-control::-ms-expand { border: 0; background-color: transparent; } .form-control[disabled], .form-control[readonly], fieldset[disabled] .form-control { background-color: #eeeeee; opacity: 1; } .form-control[disabled], fieldset[disabled] .form-control { cursor: not-allowed; } textarea.form-control { height: auto; } input[type=\"search\"] { -webkit-appearance: none; } /* * Component: list * ---------------- */ .list-disc { list-style: disc !important; } .list-alpha { list-style: upper-alpha !important; } .list-decimal { list-style: decimal !important; } .list-outside { list-style-position: outside !important; } .list-inside { list-style-position: inside !important; } .list-square { list-style: none; } .list-square li:before { color: #ccc; content: \"▪\"; font-size: 12px; margin-right: 6px; -webkit-transition: 0.2s ease; transition: 0.2s ease; } .list-circle-num, .list-square-num { counter-reset: list1; } .list-circle-num > li, .list-square-num > li { list-style: none outside none; margin-bottom: 13px; } .list-circle-num > li:before { counter-increment: list1; content: counter(list1) \"\"; width: 24px; height: 24px; text-align: center; border-radius: 12px; font-size: 15px; border-width: 1px; border-style: solid; margin: 0 16px 0 0; display: inline-block; vertical-align: middle; } .list-square-num > li:before { counter-increment: list1; content: counter(list1) \"\"; width: 24px; height: 24px; text-align: center; border-radius: 5px; font-size: 15px; border-width: 1px; border-style: solid; margin: 0 16px 0 0; display: inline-block; vertical-align: middle; } .list-circle-num > li > ol, .list-square-num > li > ol { counter-reset: list2; } .list-circle-num > li > ol > li, .list-square-num > li > ol > li { margin-bottom: 13px; } .list-circle-num > li > ol > li:before { counter-increment: list2; content: counter(list1) \".\" counter(list2) \"\"; width: 24px; height: 24px; text-align: center; border-radius: 12px; font-size: 15px; border-width: 1px; border-style: solid; margin: 0 16px 0 0; display: inline-block; vertical-align: middle; } .list-square-num > li > ol > li:before { counter-increment: list2; content: counter(list1) \".\" counter(list2) \"\"; width: 24px; height: 24px; text-align: center; border-radius: 5px; font-size: 15px; border-width: 1px; border-style: solid; margin: 0 16px 0 0; display: inline-block; vertical-align: middle; } .list-circle-num[class*=\"list-full\"] > li::before, .list-square-num[class*=\"list-full\"] > li::before { background: #de4a32; color: #ffffff; } .label { display: inline-block; padding: .3em .6em; font-size: 75%; font-weight: bold; line-height: 1; color: #777777; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em; } .label:empty { display: none; } .btn .label { position: relative; top: -1px; } a.label:hover, a.label:focus { color: #333333; text-decoration: none; cursor: pointer; } .label-default { background-color: #eeeeee; } .label-default[href]:hover, .label-default[href]:focus { background-color: #d5d5d5; } .label-primary { background-color: #2196f3; color: #fff; } .label-primary[href]:hover, .label-primary[href]:focus { background-color: #0c7cd5; } .label-success { background-color: #5cb85c; color: #fff; } .label-success[href]:hover, .label-success[href]:focus { background-color: #449d44; } .label-info { background-color: #56CCF2; color: #fff; } .label-info[href]:hover, .label-info[href]:focus { background-color: #27beee; } .label-warning { background-color: #F09819; color: #fff; } .label-warning[href]:hover, .label-warning[href]:focus { background-color: #c97c0d; } .label-danger { background-color: #FF512F; color: #fff; } .label-danger[href]:hover, .label-danger[href]:focus { background-color: #fb2900; } .panel { margin-bottom: 21px; background-color: #fff; border: 1px solid #f2f2f2; } .panel .article-title { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 2; font-size: 18px; line-height: 32px; height: 64px; word-break: break-all !important; word-wrap: break-word !important; } .panel-body { padding: 15px; } .panel-body:before, .panel-body:after { content: \" \"; display: table; } .panel-body:after { clear: both; } .panel-heading { padding: 10px 15px; border-bottom: 1px solid #f2f2f2; } .panel-heading > .dropdown .dropdown-toggle { color: inherit; } .panel-title { margin-top: 0; margin-bottom: 0; font-size: 16px; color: inherit; } .panel-title > a, .panel-title > small, .panel-title > .small, .panel-title > small > a, .panel-title > .small > a { color: inherit; text-decoration: none; } .panel-footer { padding: 10px 15px; border-top: 1px solid #f2f2f2; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } /** * panel-group-base */ .panel.b-no { border: 0; margin-bottom: 0; } .panel.b-no .panel-heading, .panel.b-no .panel-body, .panel.b-no .panel-footer { border: 0; padding-left: 0; padding-right: 0; } /* Badger*/ .panel-badger { position: relative; } .panel-badger:after { content: \"\"; position: absolute; top: 0; width: 0; height: 0; border-width: 4px; border-style: solid; border-color: #777777 transparent transparent #777777; } .panel-badger:hover:after { border-color: #2196f3 transparent transparent #2196f3; } .badger-danger:after { border-color: #FF512F transparent transparent #FF512F; } .badger-warning:after { border-color: #F09819 transparent transparent #F09819; } .badger-success:after { border-color: #5cb85c transparent transparent #5cb85c; } .badger-info:after { border-color: #56CCF2 transparent transparent #56CCF2; } .badger-primary:after { border-color: #2196f3 transparent transparent #2196f3; } /* bg shortcodes */ .bg-gradient-info span, .bg-gradient-info:before { background: #56CCF2; background: -webkit-linear-gradient(left, #56CCF2 0%, #2F80ED 80%, #2F80ED 100%); background: -webkit-gradient(linear, left top, right top, from(#56CCF2), color-stop(80%, #2F80ED), to(#2F80ED)); background: linear-gradient(to right, #56CCF2 0%, #2F80ED 80%, #2F80ED 100%); } .bg-gradient-primary span, .bg-gradient-primary:before { background: #396afc; background: -webkit-linear-gradient(left, #396afc 0%, #2948ff 80%, #2948ff 100%); background: -webkit-gradient(linear, left top, right top, from(#396afc), color-stop(80%, #2948ff), to(#2948ff)); background: linear-gradient(to right, #396afc 0%, #2948ff 80%, #2948ff 100%); } .bg-gradient-success span, .bg-gradient-success:before { background: #44ea76; background: -webkit-linear-gradient(left, #44ea76 0%, #39fad7 80%, #39fad7 100%); background: -webkit-gradient(linear, left top, right top, from(#44ea76), color-stop(80%, #39fad7), to(#39fad7)); background: linear-gradient(to right, #44ea76 0%, #39fad7 80%, #39fad7 100%); } .bg-gradient-warning span, .bg-gradient-warning:before { background: #FF512F; background: -webkit-linear-gradient(left, #FF512F 0%, #F09819 80%, #F09819 100%); background: -webkit-gradient(linear, left top, right top, from(#FF512F), color-stop(80%, #F09819), to(#F09819)); background: linear-gradient(to right, #FF512F 0%, #F09819 80%, #F09819 100%); } .bg-gradient-danger span, .bg-gradient-danger:before { background: #FF512F; background: -webkit-linear-gradient(left, #FF512F 0%, #DD2476 80%, #DD2476 100%); background: -webkit-gradient(linear, left top, right top, from(#FF512F), color-stop(80%, #DD2476), to(#DD2476)); background: linear-gradient(to right, #FF512F 0%, #DD2476 80%, #DD2476 100%); } /* Button fancy */ .btn-fancy { display: inline-block; font-size: 17px; letter-spacing: 0.03em; text-transform: uppercase; color: #ffffff; position: relative; } .btn-fancy:before { content: ''; display: inline-block; height: 40px; position: absolute; bottom: -5px; left: 30px; right: 30px; z-index: -1; -webkit-filter: blur(20px) brightness(0.95); filter: blur(20px) brightness(0.95); -webkit-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transition: all 0.3s ease-out; transition: all 0.3s ease-out; } .btn-fancy i { margin-top: -1px; margin-right: 20px; font-size: 1.265em; vertical-align: middle; } .btn-fancy span { display: inline-block; padding: 18px 60px; border-radius: 50em; position: relative; z-index: 2; will-change: transform,filter; -webkit-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transition: all 0.3s ease-out; transition: all 0.3s ease-out; } .btn-fancy:focus, .btn-fancy:active { color: #ffffff; } .btn-fancy:hover { color: #ffffff; } .btn-fancy:hover span { -webkit-filter: brightness(1.05) contrast(1.05); filter: brightness(1.05) contrast(1.05); -webkit-transform: scale(0.95); -ms-transform: scale(0.95); transform: scale(0.95); } .btn-fancy:hover:before { bottom: 0; -webkit-filter: blur(10px) brightness(0.95); filter: blur(10px) brightness(0.95); } .btn-fancy.pop-onhover:before { opacity: 0; bottom: 10px; } .btn-fancy.pop-onhover:hover:before { bottom: -7px; opacity: 1; -webkit-filter: blur(20px); filter: blur(20px); } .btn-fancy.pop-onhover:hover span { -webkit-transform: scale(1.04); -ms-transform: scale(1.04); transform: scale(1.04); } .btn-fancy.pop-onhover:hover:active span { -webkit-filter: brightness(1) contrast(1); filter: brightness(1) contrast(1); -webkit-transform: scale(1); -ms-transform: scale(1); transform: scale(1); -webkit-transition: all 0.15s ease-out; transition: all 0.15s ease-out; } .btn-fancy.pop-onhover:hover:active:before { bottom: 0; -webkit-filter: blur(10px) brightness(0.95); filter: blur(10px) brightness(0.95); -webkit-transition: all 0.2s ease-out; transition: all 0.2s ease-out; } /* * Component: table * css like github * ---------------- */ table { border: 1px solid #f2f2f2; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td, table > tfoot > tr > th, table > tfoot > tr > td { border: 1px solid #f2f2f2; } table > tbody > tr:nth-of-type(odd) { background-color: #f8f8f8; } table > tbody > tr:hover { background-color: #fbfbfb; } table { padding: 0; width: 100%; max-width: 100%; margin: 10px 0; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td, table > tfoot > tr > th, table > tfoot > tr > td { padding: 6px 13px; } table > tbody + tbody { border-top: 2px solid #f2f2f2; } table table { background-color: #fff; } .modal button.close { position: absolute; right: 10px; top: 10px; z-index: 99; } .modal-small .modal-dialog { width: 480px; } @font-face { font-family: \"icon\"; src: url(\"iconfont.eot?t=1525101408939\"); /* IE9*/ src: url(\"iconfont.eot?t=1525101408939#iefix\") format(\"embedded-opentype\"),url(\"data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAD7sAAsAAAAAWwQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFZW806XY21hcAAAAYAAAANEAAAIGLFwHIlnbHlmAAAExAAANNEAAEiYkGD74GhlYWQAADmYAAAALwAAADYSZuy5aGhlYQAAOcgAAAAeAAAAJAkLBTVobXR4AAA56AAAAC0AAAGIiyoAAGxvY2EAADoYAAAAxgAAAMbA6a6WbWF4cAAAOuAAAAAfAAAAIAF5ATNuYW1lAAA7AAAAAUIAAAI9Divfm3Bvc3QAADxEAAACpwAAA/BaS1xneJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2Bk4WCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGBwYKt7MYW7438AQw9zI0AoUZgTJAQDiFQwleJzN1UlP1WccxfEvg6iIivMInehgi0oHWkoROg/SQmeQtohujG6Mm4ZYVi51KyUS2NSEdNU0hjRNF41peAO+BYzn/kl8C8aeh8PG2qQrk/LkQ+69yX24PM/5nQusAxqs0xr9cIo6P6L+e79at/p6A82rrzfWH/fzcd70e9qZVLsOqUvd6lW/BjWsMY1rQmd0Tud1QVO6omnN6LoWdVNLuqXbuqN7teZaW62jNlCbr0ariep0NVPNVgvVjWqpWl7pWbm0Mn937v59/51J4f07V/fv8/5DGlnb/+zq/hd1WVcf2H/5of3Hvf90de1f9390P3U+o3FmvX5aXQteP/PL2vp1dS3yG78/sP54aP3p9RdL/1hl/0520sEBenidY7zNcfp4i3c4xCv08wK7OcIEW9nHUV7mIG08xWO8xGZO8QYf8zgfsYkn2cOn1Pt+P2QLu3iGDbzL+wyxg/do4Tm284Rver9zMcAH7OV5PqObLuehZOBFmniVZxnmJNs4zHp6eZrP+YIv+YqvGWGUE4zxDZ+wkW/5jtcY9Mm0+l9oeqQ38B/X8z/5aSm/GufWnp2yyTX+iCLKXKoufOuoPnz/qCGcBNQYzgRaF04HagrnBK0PJwZtCGcHbQynCDWH84Q2hZOFWsIZQ5vDaUNbwrlDW8MJRK3hLKJt4VSi7eF8oh1Bed/OcGbRrnB60e5wjtGecKLR3nC20b5wytH+cN7RgXDy0cGgfPa2KGeu9vBcuG/CE4I6w7OCDoenBh0JytkcDU8S6grKZ+wOTxfqDcq99UXpWx0Lzx7qD8pZDgblDIbCk4mGg3JvI+FpRaPhuUUngvK+saCc8Xh4qtFElPTpTHjS0dmg3M+58PSj80E5pwtBOeOLUb4z9EO4JdBUuC/Q5aDc1ZVwh6Cr4TZB00E5s5mgnOX1KN89Wgy3DroZ5XtLS+EmQreCkvflcDuh2+GeQneCcpb3wt1FrTncYtTawn1GrSPcbNQGwh1HbT7cdlSj4d6jGg83INXJcBdSTYRbkep0uB+ppsNNSfVjUPabCbcn1bVwj1LNhhuVaiHcrVQ3wi1LtRTuW6rlcPOy0hPuYFYuhduYlflwL3N3Lmj9G/Y/t0h4nJW8CZwcVdU3XOferqqu7urqru7qqt737pq1e6bXZCaZmSQz2ZNJMplshKxsCQlLAiQYwho2UbYHH4UgO4OAig8gimIARWRRQRFFRMQHF1A/EUVZTBffudUzISrv9/6+6e5b5y516y7nnvM/594ajue4D39NH6EhLsC1cb3cMLeM40DohIxC4pA2q0XSCcE0HzQ0hZpZMy1mM0U6E4yMoOnlerVgCKLgBQUSUEmX62aRmFCrDpB+KOtxgHA0MubPx/z0anCFzMTF1kJyGwST2Zh3oNta0DWolVMB5x7Z7w/7/Z9yCjzvJMThVWCnoUu85BKsO3hvJPhIsp0kQQ6bkcVrPamof/Nl1VPieUMCOP98CERTyl2DakTF7zkRPeAPiz6PMxTxZHMa7PmNOxSQ44XXOfxjff0c/R49gVM4Pxflclw3x+XTatpM19K1rJpWKyqtpYOGAq2+5f+DIAm4wjoLoMd6/rPWWz+ZSRzHmJXKkmrVehqvSysVy9+6fhE+eczZx1g/ss6y/gR7HnnkEFSWVqtLK/Bv16l2XUV/SRcgpXN5bNV0bFehhGMaGACjCGYBB9mfhFqhzmNMF0QFQ0djAPKCbvSaWFTPNep+s+AQBQIe0emlYTLrIYlcdML4TbzLvMVJCXlDSgLZddWOlwZfgvtVojV7QdIdTl71wql3X+1zqdZlnz8QPUdwejUXXDxxtoMkJaoSnzX+kgT9T7696mLqvHNWu05vKUrCfUUSIQ6RD7vUq74AWxTJd9GN1mUc58C+fIk26Bjn5FQuwi3FnlQLLWZRpwh+imho2DGRdSeOnQ1qQqZQq9YbahF5qF7WMUFU640BvjaZAHszPZkjXzjQuvanonBZ+4ql5WhyePNwKhpN4SUZTc9Mm8VIyGWnZsKZTG8mQ34Ssq+1kF1HKFX3fnmJEQnnO3zeeqpneLgHU+CvH9HWj30Bl9cI53uSrUScL8omjV4MP+QkXDVxXC9T7GGmP4YiXLqra3ZXV9p6ZpIgOycJ+CGw6+wu+Pcr13rOh1+gr9JjuRncHG4hPqdShE6oD0KFPWAAGgV78Qk4RNCoGLqYVSBYUQDHUxR0lohfYwBKINYbAbViNJDBs6KZVSsw/kMSIA84iOMeQbFeBMPvWBMNh5Mk4fbM9K2nBA5pvp8LIVWfg5HuntUpNeV5gHjdB7oD/PuLkhfevmR8ezj6N1iYbxsZOckxyDs2ZR3p8bXVQcnB09LMC8fi/mm0tDVV2rYIZEo7BtLLOp8jc3quS8+ZDtc3G6tWkaebF82dS7qn+vobej3tQkrhOjguoGbVhs4EUcGeeYxWC9kMdjioZuu+mlkJZgdopaz/9ZGnoL8HStP7N/SRGx4p9uZ6ZeERgEfAHWrvz23eQ6LNZ0j9vo5p01Y2GlbNegSKM4bNuBq3nvgNRKOxFf5oyn/hkXm1yB2cmzO4TntexQTgADaKQHHhIYFRBWi9UcgeyauaglgEwl3+9oFT37jrHmvVGusLq3cTsnt1KwSfUyoPAwyXWRiIoDC7HW64bM/dVHzk2O0PWQFy1po1ZxE7BCOqAYxUKiMsdDq9AO32mrqc7qEVTuZ8nMYlcE3h0ugEsZbOFGZCPpiuTf2qdRTDOt0zt5y52TpUnkv+1vRM/eaWCS3PfaG9Ov+OO+ZX2588ePCpgwfH29qq8+dzBJ9xH/0RXYQ8jfVDfXKJNkATQciYUISZUK0zsW6ADqVQcVZ39yyd3GZYL4YGDWuxkSqmmqlRAx4wyHJjqFgcKhrWSynMNgx4UB/FzGIqZC0NcfaznkF5183N5bbis1B8FQFnFoQgjmgZmbZSNnRDr9iDiwOvgBHQgzjgGbNgtpggyyRCAwZYewIJvJq8zu5psLVQBFwUosAKl6CggG6QPxR8W5SuepdineeC6R356Oxb1y6Zt2FRLNcxDdw3CVqA52/iIar5Pcu3jY5veWCB7A9GHXCeGIzowmftfOs0X6F/7sJh0+fi3ZpL9mr9QzMrmuKWNJmX4G9zYvcYkYjR3KAHO6dBqG/ASM02YFpnKAi6JLg1yfqjJAej4F6QiQzPckM06JbIzW5ZdlvvYY0B15Mub5BA2OtijxMEp6gDCQioFh0BTWiN2x30V3QjF8SR4yTsp4kLHnCeUCZIKEEb9aqZwQXCmANlpsmYNJhFoaqyAQ6qOLwVlckKJFQ2vJhOX7RW4fgGdWtc8utSHK6FL7p0p3SbS4kGt0OlsMmswHYtCh5NgYp5E0SCqzB2E6aCBw7CV0AlRAVrmRTyO/H2q6zlKNFdobjisk7RYm+YVYCq+UZMg2tdCqZtYzdqWAMONurGigmfdSl2356ij9IZqJkZf5t1YhZyqPUM1HMGE6R5oWAWsYe6kQB6361rAts/YX3v7F3kjFMhuedWX3vC+t3aN9atgpV2mLplLyROO4PsOtv63idODqy91Ztof2ElrFr3xtqVZHzdG1My50rkw11IuVBbcRIVJcBv7+SFcFYOXoFXMtZca27mXyl6unWLdQts2mM9DPMi/0pxLT14M/013Yw6sMwNMOnNM+6tIeOabApwlaLAVnGC0qJAcRpVTTcqDDQ1cAmzqUFxR9NM+rEVjZrwKBoaPO+B21pDS8VAxhMBRAfWphvF7wTCEf833J5PYAfuCYQh4r/Yoi6PxwVNe/g/ojcR0Xsu3kV2YT1eTyzfvKpQg6sFxGphf/NKfxgU18bTBYyQXf6I9TtFU/D7ZOvCxg+V1IfvYx8FxI2IGUUtiBgxmzH1SrnBYIp9mYmrz16ryHJMuePSrjcEsU5fa59e3Hjh17fdeXkwcvmOoRP8mhqJjKxt72kvRRe+cDa/e8V4/+x+Y2g6ubu/Q1JHb7rmtNlryEpY3E9FZcc8apDoqkqteMxOwdBX7B7wZOYWhFabJuhZtMRtwAiqyXqBoadCBkU0qkVDCCJiEisMcuBMMAlufxuCzpSmXm/UCy3a0OuM3XShwWqo13SBFWNYjKWblewA0DPjca/qKK+Q+/+7Txyv86pvOpx+DkDa5Y8HZswcFuMeWZaMNf1EkKSYI97v8WpRXvYIKlnqcwBRnLCWBgRZCimiNC8k6U7F5eBDLoD9pxPatSxdX+IknS6fTyyBc7QxZ+36ywwIlRyS+wSXX1W8OTUfcWdnhb2y6vKHe86N1c8oKgGf43MrXXGy5hvgDfq6zyqnTy3FUrosK5nd5XhCDV3G5g6H6sM76S/oMahTOlDXTeNWcGP/qvFMjGTTNiibCVnGfP2g2rBMZczbCwIn6pxR5xoFzmTyNsMGplBloKNeZuOqaygJcBUdfM7heO5gK4QIuCXrXbffHXTKsjOIBEiSG6zfPWP9nefB/cwz4EZZ+/dnYNrM0RUPrhjdl85m0/ts8hMZJAfIn7GeG3/ocPzwRqzT2uuUNcnNhLAqg8Qqtd6VJXiH1XF0nYf/PPBvNbXImWw8RBtrvUZXo/wJIwbv5WZy49wqHBEGqkRbchotgZlVGYBqqKh0kL+yDOcZgXqRoM5JkEZAVwgqnQFi5As2LqszsTXAmMyGZQWzl8AfJ9IM6qUn/ti6/uCJJ34AzwlOp7BFEEVhJ0+9PmElTxWVHz+K/pATBCWbc/BtpsfpC3v6ZgrizLIcFujKP2At1vewtj9CV4Z6Ml2H73odpr3eJLAFAvEAtIJvOrSITHppMOwhTe6jCH1YCfHqzLaeJX4pHHE6MzuH6+vQsvPYcuw25JONXBVl2AZuO45IC4VpqG7LDUbohg057RRcQKh4mEKvtnrfQAvSrFAby+NCqjH2GGTjgSqeMuyfYakFLMgYJqjla9lgNlgJVmqVGrnkn+XdtaWN2nGBoNNheLountnomD3rwE1jy0mf2SkFNTmQVuLgj8blpTOSx67ZOn2GImfVaPuo5JPnOXlfutccCLRBPF0x+/0FOH/owIGhi+iGcNeiYxf34QrW3Wq0zQ96NrUqM7/SALJg7vqh0VRWCrclZDWttc3JNzriYvOCXE/fYoDOztmZkJ5wuj0SkF5YFg5lSE92wXC1ow2gO7dokXo9e8BFQzY/vUffow4uhnZ1FTXAPG4tt5ehnQFi23PY5YJoD5y9VNB+KwByx4Ct4hBjMmGFKoJJJCyMo1lHwd8QGC8lQMij8VTDHAbSKnVd1HRasO1wNh0NVtjQmWmAuVhFb71Afh9xCIFE6YCYJU46bfOJV9HpXqq/unc/cI32jdanz76F0lvOPvtWSm/93GkZAeTU3PPzhf7PG4mYHkkk5jq9TurzOR1wrksBx6Vut6K4Vyi819m5wMPLKGpkt9u3r0cXqYMGfR6Nmgfgk6JG52SzOcEdTZjDic6D0opt5JJtgrTlpBM2WPc5jlu+bKfIr1624mxo0y+TSK+WS/Y0rv0pCRZSlIQK8cU8KKqHetTXZInui4le3es+VnIrUJJEShyaxxcEgnZofG59luh2J/wgB6//PNfCSvfTP9ElnMl0LzIXGweUTzaMRz1rBFEjMLDUUgEKk3BmjUc7KSNmG6ilsJhRx1KFbEEIGij7xGwhqweNzcllHakqIYvqM1YAOXBcbVtHJTK3LdsGc+vzlwG5dPusU8pkJwCJGElI6BFKdqycvyCfSkVTkGork7KZInByrB2S2UI6GFq6YNPaSMS7VTMgFsuk/JGli7auz+e9a2JfhBBcALtPXg8Q107wQ753E8ZP/tJTk7r3egfQExGvcxDwQCDPB7rRCrkJtnzIzbCesJ6Y8SEHW+iJ1qOVD6xbJiZg0weV1n376Ad0O1dAlGXrROZMOEpUIUvZgspGXnYivXp2WdfTKXLuHbshEczx1OhNpYLGnEIuSeVZX3kcDqzP9xKh8FSHwZNYya9dd85ZUX8yrSwY7olAOBHqz3Rbb//gqdNmxI4xjfKUz+MK+hd6MhfFGaqhfbscG5exYWs2jU1gEpfBoNqkMlIxz8at2DZarqMxggZKHGUvczu1YiLOJRooR+fRuqCakI00r4tkgWwbhTNGTyKD+INto7y/DQbqcwHn7T2P3x/x+z3WpxihAqieb0wmwUsD0Ww2YhVHtxGsIIW1LB3dTqxn3oPhegPNtL/4PQc9qoqB/+Mo7Ksb+/ok/RX5E0oFr+136uGmc0u4Y7nN3PHcNhyMbA0FXsPgs2bDQMGXP8rWNKf8CPzHJZpZBvPTNsyvMVSJ2QHbKGxBRQOtpny6lga0lpnFDPPOqXVUuuGL+we7ezpqzc3lWYTMKvfOBpjdG83larkcebgVO5JWz+WKNcjHrFmxAtTInAo8ioZs1+F/yl6vTHk32qjepos83+yBQ9Om/Wb69L5t1WXxk46PLa7efqTu8qz7IYs11bMPfEya9zWsGgqx116rzCH4hOaXve473V47qJ0Kq6dPnz65pq+nH9LjuSJXYpLUzFMEdpRHUclTQW/keTRY6yZFa0gXuqFeyBdyBo9L38zXzV76T+qy7rqE1/hLrLtczNwcJaoEbdDmkHgnGQiqfv731g+g6L7A+gsP275n/Yjc/ikJkQ2Fv7lQ6A5KkvV4AgLi69Z9Lpl/4AFCBRe43bKHb1dfBs0tmJmXwZt7XZTsdXYL/V+6CbkbLTXbaIWWqK+oKNcrKi45ZGeRmWE12xbDhfa4dV22HOpSreuigkATqRHoKd9AIHR5CMj1ldJIKk4FAR6HfTm/37o4UXQ7vWD9rLqCQrtWIqQYtH5GV1ShHbxOd9HGeF+iL9AxtEHq3Gnck5AHtur7Icl7+RI/yEMlKXj5LJKOCjYs6VAxLmZLAibVBvnKIFEHBdMbDCYDg1opWEnqXqOk1waDvfAhcXhcEiUEqCSgCSs7eR5pJ0phmE2dTtmOAuZJHlkQHA4CvODyCtajDirxmOkUBNGBtzt4QVIkRXB5JBH/DqHd63Cg9BQw/VGnWwTCOwRJcLkTWjwfyIZC3nhEDfrdWCdFDO0QecEb0P2ReCgUiRQKWiKZTAQCBX8mbMQjAbdXERUXDwSrESWfx+ULo4L0hTOBWDze7pJDhpFJ68FEPB9OBTW/DxvLUwpAqVNyKj45EBRD4UggkEimu7JGLpTNdqWxdCASDnm1gM+FY8Cz4rzk8vvQhPOF1Hxc69DTmWzuJGQP7IQXx0IA7L0oeSWXTc9hAyU53W4Hi2L/eJcHR1DkYQFQh8Ppsn6L9r8bW+DyyE5JclBM5nnRDVTgnbbLlCfUjf0yBEFyYHYMCBXdoupV3ZG4kcpEAwENG62xtvpzmZQRjahej+zBGcMxc/AeJxaNRA1fKOLPmXEXDlo8EctGfKGEpqlurypKIk9nt8ZBwqJ6KhyLJYKpLj2Ec5Blo4bjHIs4Q3pQln2K2y2wcRAQiPtUOaiH1Eg8Hkym01kjFAoZ2XS6IxGLhX2GN4LGCtbusH2cbE0fpDfQDba3mIO0bRG3bORKGgc0kADUomBkyT4kYpFmXyQGeIW74m28i3+Zd/CHidR8OpgGIRak45G49XIwAkMO3vELzGfPcOIznkY7fzZK3zauHe3xCjfEzWK+aRAcCJ0MMY8gKtco5ALMtZQpgdhATVidNGSIJuSzLXmbEfhsgpQR+Rchg8s5qyXgSAw+fNb6Gz86EgR/3nwWPGjF/G3D9EWjqzIZ73eUyIxZM3ctWvql0UWnDww0n++JtUWjbTHgekE2woZsBx/2ePSI7rEDOpv/9d2rrms8tZF3/Pqeu3/dvKIUjfFk+DK9dM6lZ2+M4t/Gsw+c/YgWjbZHo0FPUFGCURYoH5EtO+9i+grdj+MbR0uvwQ1z61Dj4BDX0JizFYaqY6+BSaU0c76Zap5BoQF7B0cTKi1t8jGRALMJGy31bPsmbN1ELrXmrJ+vesg3PD4AV7SteS3Jj8C3SrqPB4vKTLuGVfVrssouX/fYl9uZtpy2CGDRNEYt30nIzk84Ti2RiF1ebv5cmpXqJDdZvGdcCGnthMhnq/KdHp/PcydW9DFU8/tYL6tv2iKCFNmxYvnOSb/M48hvPVwXog6GyhF1FEweTVUeOa6FL7A/jbztIGAaF7Vo/iPX7wC0PKNHfP5HCCoWBjXrEbQ3h7XBwsAYwNjA4AoC1j1ab3xgjJCxgXivBquArBhs5WZKpZFisflipljEK+nM4rVUIu5M/It+0//FeKZVA5Z3fNUfZLetIEH/Vx2ttIEVzb8Du2GkCN8DVgMShcmUqbX1M3qIdnMphvZA80JAC2o2f9s7LY2AbZDlkcuTwOt8owSqQQ95v1PSXe6335aDbih+R0mAstedcp0NnqT1mztfP/4Z+F9ZOWS94xCj4rnniogBnCAf8ro13nxH198x+Z/cnPlB858n28+/EzHeGi7EzcbnM+XHM3snYDIPbaBeKEEeBxYRN1qCqMWTgNaDgBZLI4/rjtcrZVTmhUFU5Ga+gFSWcPv5oAf0pyWJ9Lzvjrjf7yGS9DToniC/3y18UnBaT7sF8TWR1MCNchF03smD5uCdbqiB+CunIFvPuuknBTfNHJa9pP27Ushj/eEigTgvwkpC0nfbwSdDr8v6nUi7SND1suC2npU8QD5DyDUErb6aS/yFM0g7iRNCrskx/h96Iz0HUd0cW56Yk/b+pO1m23qGrgDzIjXqOUP384XGlD8AC7dMQMW2TGwYTk9uWG9f356TBW9ETqTP/VXRPGXfub/qDruJL6YTUVKmgXL9Zy9u/lVweldXqxWPsrraFgpvK9cDxKHLTpk4EwsLu+C0zxwoKbozEhLEgNvc+Yn9v+w2d+ybu1AJOrxK95pOzJ5mvdMTilTKsjJexdAd84zUNv/AmZQJSO7CX4/vHJ30k95s70MtQxt2i428EM4MMD9RlZlHLRJNhwLbCRFtj3uduf0wwTZPGcmsiiBKc7bGmGuwPrk/FUAUyzzZlJVj/ieU/EaFPkE72i5du/E6wemSne4v71g5ITol6nFqf1+x4u+a00MlpzixcseX3U7Z5RSu27Tu0rYOKnt6wOd+4BkqukSEB8qTd7t90OORrWTxvn1drsp3DsC1++4rHvhOxUVeIBBIlKME3KqLZIbmTQMi+ySAzQcu2kIIQgWAafOHMpjvk0m0ktAAQQlKogvcXs9mUaCEete6wesm58oqaSZiM1xkPjGHrLg0M0qGZ5nEtnG+RP8LMaCLC6Lemc2dgGOnC2bLhg82ipPW/wAEisQsiAoRE8TQmXskoFCR8UyRIosgnE2h+BECAsUibF+jyHxMzMtiDlBcH426wdziZJCfk9BV3exIzXCePi3XScjKk+Ze6G4Px+76fCiac6nVVObCcyveWi/vdIa13j2n9UfaSzlZ8VPX+TB8vkylE5VeGg77r/7BlWOSLBKECwwighpIuaPzT/753WszOEafyXX6XaWiJmR0eeassG/ErC6QVsN2r8bz0ZhDCHh9Gu9QfSLRmo8rfYUOORolLoccSGiN0yR+5UoaSJHUJutNNeGT5gd9Q6IvJBpe/v7slg4loqq8K+oKliOdcnbKz/w05egFnIaRYJbZdhUxq+KnVrFdyuTDtb3ZLxjX3HfNNXu2rqRnf7a9fcfd1lK4/+7928+c3Nd7hfwdbWWdMzguwLSehKPcOGJmqrxg5i8g/2yrg5WzsqTWthHqba14yS1bJfIO8rrVBGJW4VGr0cZc723wzLuC8I+pvYSH6Zt0K9omVa6v5Um1GdxsGdlTRFahRmsF1Bv2h4k3ZqMIBSYwUMN8M1gPt81Rgyi3Qs7qxYtCOQcJSUuvWDx+/elFWX/g0nT6lK9NV0I7SgLiZ+3weYHNwqw+y/3TheR2+Kos0/TSnqFzhtwO18JjlO7jah6nc7ROFlxy69ilDxj8zuND6sLdql/yeD/Vlpp+Rj90N0KHkEO5Dw/Rx+kgWqtxtFmKiBMWcxvQOt3HXfWvfmEDdYjtLDfYajfrDZ0imc2YVbNOy5hYqAWYx535+zCT2TeYg/xrn10whGDD9nJprGS2VQ8t1LBkkj2Fz7TumvyhYAywBIPVUrCrwacLhDt0mOcPH3qUhWlZjyBI0GJ9izxzl5WK9VmzR5IJ6Dwxk+5qJxek2nztCXHfSbEZghjJOrLtvhXWnlgKcm3ecFeb/5tX0FqXxxfJAHhmuB3gOuU8qJ09G9oWXlw7b7vsTar5/NZjgnr94adXj6QNrMKPKmLOYjVHB6Za8Oihwyc4xcEZfFqPqOXuWTet6zB81ni1IBNBaCOUVw1dtxZ3F9xBf3zWttUEMhGPO5s49vZ/dm+blojOmfdgMv+pbxupVK5LxDzdt8q6OZvtnzY7TrMl6YJyV2SuCDoF3SVtOA3kzuFKH2A5f1xs9E2/+dgZDWXSp3IPfYnOQG4UcR6jXIzxOiJjNa3a13rDFMRswcQxx2gtPUpPP3wVzTXN7URofgA/6unY3t54uLt/84y89Ta93WrSGVutAFxs7YPMIetbCzYVdh179qrCutEtWyb3EO7ju+lyzselEUkt43ZwZyKv9PTaZzumQS/bddRq+f9IyNicY29fijbeannRyw3dYSAOZzxTLSAgaAlKJuaYTGy0wFgLpqFZQBByT/lD4ctsIwFY8DtZZZQqAwo3T+cdO/sXCsLC/p13dMod4bZarc3QJNB++BxoTi1k1mr//KkjlPCJoaQX3px4BU1Ph8+TOGGgNJZMregZOD7p8aFh43gFdnnDoi8RFrzQw3bS3IqCwOIIdXs8dOxnc6GxWm0slPvssaE4DG4aBM/1/0PI/1zvYZFrZUkOhfFn3UwuOVXyGw2tqwqpGLJitUtrGJL/1EtgjiCFQzL+JuXe4/RHdJSbgfOYsLekapO7oGwzivkzcd0UbG8vAqYWqNCDCOcTYLu/2BERzhS4bnrvJ1UeTqhStV3saRhDuhTduRXKitdRWiRUD1Tc87sciqcCx+0MBB3yp75MeOuDJ5+03of9B/9YpqprmbDcbxiu8HicF/OR4N7lS/t7kCM7BEWRCkQc7ukbXbEn6O+NnSm6e/9045Mg8A7r/ck+3Iw68FjUf0yKtLYKjCk4zURewnY8tlJsD6RZLxDuijudrj6vInn8A1Qac0irnLE3c7k3Y85VkmNMogN+j6R4+1zOz9P18NyjwesqvdtFukpcvxEgHwqKaCwHQ3mAjevFVVTc3lv5jPbgz4+c8XiDNLkw8iy2KVBRGTuxoUJKRUY0xCzbNcyC2gIjeRQ5KrYqZMovP+Tr9D30c9ms/OlGIqwQ+BvertADd38tD59v3vfmjfmv3U2eaz5EB8LhAUoWNq/iZ7udTucIT25qPuaoJEmXb4XTucLX/Emy4miNzT10H92JdggXQP7XbaiLkzo1PLgyGNNXbZSIKczyZ4re9ssOwpGdOgUunt4XFN3UIagaXHvB6XsANi3vrkpKhuQLpRkAPkjFXV4XJU4qzg86vX7fouInbyPk0O1PP0MCC04Pi3qXS5YC9eyOGxzkrGP3TThgRnf9RDNXBLJ00OyBS/aU5p0v80Cd24bDM+bE28Dxo4nzH3Y4X+SOjOsh8lvbju+wfV62X1LVDNDL2LFqXmgd5dF4YKOroznSyqCKtU9yW2/KXpDgYrXb/2e1+Qe1O5PpzpD/svY55WG40ud7y86A1XCxE7sjW3+QndY+Vf2zv/slNcMKv8RyrF12MZZsy8Pz6SX0fNT6EW4Rt5o7EQe9YYgG+4mmaDbsX8MwGzTdSOcH7I0rtovCLBF2wKaCMItpaNRN9naKmGUGsMk2WVA7UV4stErTPLBjKq3ZsX158HuvV/ckvemar5b2JnK6z7cgsLNL+wJMA+t7pBgNSctcPQk5nnBmcdqcHm2nkXXIbtkbEkZ5t/uHXcWHZb/ZFn+4Vj4N+va4ZU8i5RSfsZ6Eb4em9Zf9eaVn8krqQU88i6KuQ+/o8Jh8Qg66IoETI016yhnuWuy1WJwSRzm2X3IKbYv2uwJAwKu8JhuOxV7we05KXZZoB+Kj2w8fpIQ4qnHDevcwQMAnJozqnvaAzxkPVfZMYpxX6Z9oBtdOlp2dhJpiL9lgIauiZdNix7rDUDPMGMgithINYPaByoQUvfbwQZ4/eLi72wOhXWpbLNam7oKQp8fKL3xw2PH4eQ4XHHCMfHWh7DjvcXLXJ8QTZPkE8RO0+SkHLbtSBNLuXuogZzS/2hYGMu5e5AxZaYi0kWjcucg9qf9epM9j+9xocdYQb6P1krcPB7UOEdFyvWYfQmSwjymh4KSzqdbaMGBYkO2rFYEv26cQWyUrU7exMxrkTYcR9dCL7XCOEgjE/AB+OKj4gYbCzTXJGA3EAtCTJYfT3ZjTPEZhu692qf9ixQOBGz0eERf3Wwq7NN8KKPBpr9/vtXYrgTMCysUhnZJQ9AIsq9ye64FU+mt2Ojle8fuV5kGWToCFzQ+VADfp07gN7bMN2G8NdcVx/4rXxMllJ+SzH3UV87PMjdHPOh1k6nkm49uK7dGYLMOOObB4J8uZLMM8ca37FCBc3xJClvS1wrhp9pkm3Ay+/71Li2l3/a/PbuTRUU2z1iD9yW965yCtzPF+85P/GiXSker6ljzL6uszT/j4mqai1kn/h7pa0am9pjvpT+hCmy/yXJnbhCNk71Cj6NcENhnZI6drjBZPfFzkKKdZkDnNivYpHSbmGGe0Tu0UmEJj53pglScQ8DzNWn4ZeGVrpexD3PhFmW2X/B9jvzr8bpodEL1BT4ArHJEh4G1+WdECXvJDdpzaGQq7gXSRzeC3GQqDS5ArogH/gx4Wj/r9DyitjMC70JWiEjtfENebyz0ZCjkPOc/LmNHbzCoaJpPpcppCRm7elO6c9GXc7rgf7VX7BDKUmYleM2t5djo6mA7mgxhqKAYnTyQnwLbh+cYAaSC2Z2vcHjHyc0gbuucvkLZ+9WnrbfC+DN9GTeR6ef2amzzihruuHhw+nsAhnzenweF1u0Ypmbdlx9NOxwS45o/MWwB0vWPoM58ZoltrUGvfyi8QYO3JO/aZiULbqcI7sdi8Ppjv2Fgujbm3Ot23TLb7XvoiHUfeX89O/RQpynFaq1bKCcoWbxUBZkYhQS1BUI4buBTYIXbkY2TqSnmAGCzBZImkVm1MnVLCu/EWUSfvhrL1UmKdM+KW1kTaw3rEF8+OnNTfvnS43eiu5dY2lECvmSwnwkk1mfzMiV0rhtt+efnm0aFS1+qbdw+7ehld7G7REEmW01GvECQul89V8mqa14xm6rFAYbgrPy1nOHXF6elJatFYIBebtszomL9m8+W9ruHdN6/uKg2NTtHdxaGWPL7H8TTOlwPtNx/23ETVJhFRgm52fs0kv965Z89euLr5XvP9JWQlGW/ea/12MZwIJy2hrlUbNm60vmWdADcMWB3w0/ivBqzfQnRgUs7/if6dPIfSJGefRReFDCrCKirCctJW3DiG7IQCU5eNwIDtoYcjhcyPSsKKiKDwH/D4VYSIIPz4xwI0niKymBZF8hTxCHiFDZjJR3n+xz/m8cKK744KwvutGzFB+PELPCq55hK8R8J7yYOMoLJ14/uCwG544ceCXQHWM+Xvf4Z+jU7jvFwA7f0ol0R9Zdoneo+s1ZZMp2k1zXZfeTSG/v1KLzn8jhaLaVRm4eF3qNz8zubN8Jy1BW6yev+TotMAi/09GIsFqVuLHf4udf+ip6fnb729ve/gr8WnP6XH0SFsVdI+Mdc6+z7p+WNHNphS0nT7VHGBbnWk51zhcpeX9uy4BHXB5de+nhGsO6cvpQv7po3ShfCj1cu/cKbTmYP82EuXX/ZiTL/+6sxx86f1LaWwoNG3xLbPvkqvoLtta3BqLLg8wlz2qkOAb+Qb7Af4EQMNYH1Wxpvc+Aa41W9tKMBFWWv/fJhft75+07A13LwI7rFWuYGz7oXxDzkIrV65eveDS756mvXWLFAvr1j3VKyR8cn1+HX6FJ2P+HqN7S1keicdbJ0SMmpGL1uFIoO4aITaUJbWbSegvf1fsuFtzVY97CgAw1pBtgsktk6zCq3pgyd5futZhMyGPVvcHrTQKC8A3boXmofIWZvR/uCpg3fChwhxRuCY5R7P8mNgLttcOPw/Hr+qLID1y2V5+XpYyNLoqKLClZSEr9m8c+fma8JUdYtARcoTyRm+dtPatZuuCRNKeV4KCNYi2b923edKoli8ft1O9uJJWIWd664vimLpc+vWsgTbNsaF9B75Bufn4lwbN8wt5Vawc9VMpjD7LKgpJJtWeVs8sXdsAiiIakzZBvO2c6jCjqSgQCoMECaJxLSmNwomijGxUrC38otd86uxjvZp03IzR9utF0HNlbyxtHre1Vo+6qt1/ReZGavk68KOyMmLqytnJiEzY2Vl+ng9RK1DvoNGKZ4PS/A9/pUPPiAPgy/b31kaCKgr+orDXRo58b2MGYz5hKutD5z+ZKin7W4SLWjLRtJD49WeNYO5roWbKpHiKyEIJDKe0vsz7TnH/n6LDnAy4+08StR0YHJ/KZ+usZmcOqmgYjo9JhVqztuSMsiFoSQ0Y+SMVMi6H5Ih602Mb0mdYqTg+/jDlC31UKrCyJTRPAkeNVJc6+WIR8nv2JldSE8ez0uzfXSmjWHCeqdQBigXyLOFSqVgHSS/xUjzjVYiPIrXSXvlBvLgpK/E9pNMfU6g1cPfn/qRByo/wM+kv+Of9NfUbe+lDSFvb+fOwha0bDBBa50jEgsaw8R2VNTLDGkVib26NTTN7ZOxBaHl92V8XsgE6sydbmBey/9f1ifvbG0/1auTxp9eFZmUYFE0mynXv4yQZf2K0jsLYFav8oawf6uirNkmQsh6DdaNjJzoXTg8sjMoUJPC4qGhS7o7XZnsuSNLNwA1r/Z99bqrHgWnSVz5TnPHGTvMzhRPu5vfmqxMmaz8KXHbGkXZeo4MBpyACSxZJ1gCy9HIT7deLmIGPXetAreObBZg5eUn+zzzR6SgNxQaOTVsFHrrl/X31SV178JQ88WrX3A9cVUkFBo8s6urWOzqPaM/BFeQoTJ7pgGwrH/GMqz07fF9FJ9BP73VRT56J+MXaHOUuFlsBTEFwz4p0X77xbDP/acadVFImYUSsd3hKUNPsgOZJntRwDz6dQ36wzQ7Z5nubTxo3fhgo/dIDI57sLF6wnpsolbyuSS1VJuAoSn6r2qgUAEI+tS+pQBL+6YvgcFOyeNxdQxU77qrOtDh8nikTpv2HzxY7g96Fb2/zCjN5w32r3VCrS0XcZAVAwMrCFk6yUvvIS850TZNonyYzs3hljDMZbS8YtqkgCwjHEH7hcF3BlCPYPnW2X/WJRQV7Kxa3t6MTbT2aCcpco/qCx+64OrHHPOHMntS05I+n4ve1q8ZRlsi8bKWTJqGQZ523HXW/tsovW1/uBI5NlydbV3oCQY9AcP4gkfTPFiYRMm2AwQLzN3dfcIM0QUkk9/9uY0G3m0a462L9da2TxHyqW3brqBuoTJuHndcMKIBaJHg1LWFK35OX6IBLsh1cNWj1m7FYG8wTL6QoKJ8zIpCie2/MrjNoHcQaJaprIqapXua/vY6QL399ZO0Hu2k1+2I4f9gL8/v/cBvGH7yZ79h/eBnfY0XBho0gAUtrq0O2/ygbmM+fa693rxVNWCvw7EXDJVw7B7rc5CzLmOIFfZO2Qy34vxEkHJyCiKhCMoI9spFI4+YOZAN1MvIegLCLEYa61Dq9LpEB3TBpq9Yv9v+j22OKHmi7hBdVi9M/GO7I+qAJ5qvwphouCear9Id1kOwULbumXAbovUlksGIPGXL/YjeTL2or5NcilnZAVsF2i7PMjtcS21fqYN5BHHuCQetEwktP9ChSDYbOe8LiOprWcef74/kchFwwDoBspUcOK1N1s92QqwyvRIDmFkszoQXstUs0LvPY7c98BYMQa6cA9G60zps3zoNbm1OS/Qm8IuFYabNt4fot+kc+x2pLFfBNTnKZtJuZJr5bQPpKRVdLYhH0YGjJDWb58CU8V0x0o1KLStmzaw6eYaNXGz9w+VV3OByeb0LrGU2/RV25PQoen3zgsZCgIUNcp59jUAx07wg0w1zHoXYI3PXPvKPQ6uhO0vOzaIhPlvR0SZjwRIMlKD3LoWtUgXWYQVHV9TkMkXAmp67a6Jy111wLtYH3Zmp/fRL6XfpXkTbCDSBp6YKvCqBSnk1T6vWEngQnm/eAt+GJ8+1vgHzyC+a1pW7YAcUf9+0rPfASYg1/Wtw9Tdb581voa9R9q6IjDIggei0zg3ibNv7qJPuUMrUib3pkWeGFabSakPP2dsiaH0GWqXYGeo8FrM3UFL00cX3ro1mV3+61DcLDnZdNn7MuQvHNt5p9Z677ox/nqV/+l5yDkj7MtFzXl06b/RrC1/cm+0U1m1b+d/wc8+csVvmEd85dJPlDvGBkVmpzSNDdxwLm2ZvSN5yIAIwR7/g5mwUznzIOj+oQSI/OCd72/mz77feOufGzPpvbWiHuusbD6iiAac/NLVvd4PdR5Oh3ULDLOi2/VVvsBOOAtdyadovKuoV9h6BiRDuyo4wzFfzjkg4GkXj9Wdznt33fettHjav1AgJBebGxtd/H7w89FpPfx0cet7xUL8iBAN+r0D+uPYk4K0PH9/59aFzaERyl7QUD/D4Kcc+u2eqPV+hf6VnMxQMbLc5wbTz1K4TShs2oKjOyWxfwg2bXDLIkjXfnfJbV/hSsuSIgV+FL0tBeqbD7bZulkIRw2nNU1QS52U5rsAWvaDAfa7AkXNNr9Etk7jPPgfATr2zRTG1Y46PrLS2zDMfbZnbC8kmszZMCLQOKLfebGvgike8ACgM6fdoZ9ulx2z+DG/vkN+3Y+WE0ymBQwPtH2Nj/9CcMnU6nRMrd9zX2iL/zKZ1l7V1UrcCPeCVH3yWeH0Oqjx1t+zFBMVa1NdHXgKU1IlyjMg+NwrcoflsT1ySBNhy4MAWcPpkAtPnz8oQl+oGEq0kA8TeET/X7QXPZtElsi1x2SuTC91+hHTzpvZFf0n/Qk2UoB3cYvYWFNPI1EY67LCq/TIzZCa7SlrKjPnrzADOScP2pgZsr7gCXjAbA8SGR2xlgEUdvavTzdnC/OyaLavTh+eI8zIrrZ/kZkX6+PrhyPCi4Wgg0M/Xm5E5hfdLKzOF6PDiOZHDDb4/inmRTW2b06u2rM3OE+cczqzqTZOuNuhZ+ZPRfJ52tVnPI5XLU388NvSlEev5ZJbE434/0tCTzJDD/08+m4vFSSYJvSNfnBWP00zyjNSZZpejkB99Ydx6vq2TTMmMr9Jn6SKU5kOMD2zT2GA2NHu9krm/zUKGReyX3BosQwEEjIP2K5iTGZPFBA1+2de3bebNMzF0ejXntgULFj+5BENR8w5imnn8SQtj0cJ/5MGxeM+2vj4WOjVF3LbkycULFrBQ9AaWstRCNLbwpOPN/8ydxCrfpr9Eu5XJ/CJXRjk1NCXzW7K9cZT8Nyg7w83jlNLWK4dpdqasTtG8NDNoFQxAJc/e2szSYPMF9roO6ZbcbnfzXpseR/qWUSmTa16XyLtHXZBQ6Q6fD+AtKwOvziB68zuzeb+f7Az4+OG3yKjb78bvSVN7fi9CgYTiEIlZP5Y8VoeKUiuiwk8169DeB2A68qZHsb57xEZ9le7iGnZfWliKvXmitnYmG6bYsLVu0GjYNioyptjavRJV1Fa1lm+VwSyGtwg3dwOBkcb+/Yu2ZaMFz+yJrpFCf/elx7S3H3Npd39hpGtitqcQzW5btH9/YwTIhrm5YnF+sUhPR7JvlXftmPWQWEqHykZq0f3pkVpbn5N0dBBnX1ttJH3/opRRDqVLIiwcW+td1Td3w3IoziuV5hUnbaEnSIVplACi8QaYcEov3BMOwz291imk3GuNGwbci/SUDHyLXE9VVl5i/vmGBORE63Iss6ds3Qobqc+6PBy2Lu+FjbDxSP3fZuVxyRkSSkjCha1VvXAtXNtrrSKPG9Y4Rix86r2t+mlbq37mhMIHmHB9GTZat5Zhj2FQX691q3VrL+wJh7Fqz6SvYJfNWx95akqILBpcP3LaHOxXkP1zhixzQtZE9mpQmr0exCw1NR2wydaPP4r+9/irE/TqiTFry8TYGNw0NtbUyR+a+vtjK8aQfgSDowh6evvh0+jV7e3t53TgH0uHt8fsvzvHJv8mWhcbr11p+zpa7c/+f7cWRFNMwiB8bGtI4eWN/eck4u/T+R2HT6dX4bP3YyPaV7AG/PYXG2ecE4u9P4kRj35m8v82QumP7/0E3PRxT1qE3fqPZ5j/l34deWcr+/HPgsUTEysmJj7ueW9PjN1559jE//9nivZOXoMt1Y9/Jpmxe/fU9+Oe/Hz/VH7/7tbaQF4/k/zd9gcw3pXY6jDhsSoMWSyAoar1mB2QdzCw/jVjSt5fT39PT0T8Hsda/hXymjy22z7hjJcBeHfDfkL2byD+1rX5Z5DgSrJwuvWutYsspCfYaUeVWWPtst6dvpDAlSBNXzi51q7BtYbtBZUNSkVFKavCK9Z1sGM+7LCuw9V83fzJ2GT7sI+vkeftMeYQf2E3ReY3NoEFDTsCcNpjj1lfgWUre3J/+cvma2DZY4/1XLP5L3/J9ayEZfCVxx7DcDLzKjvzqqlMbur9/tfodO5M7kqm85gas0+rMT1WmtopbXmS2S4CJifgCFn+t2T2v2UGodzbcpgwFzPzLX98pOWKZqeuAr3sfTj2Bl150hldZmdIikD+Wwq76NCV0xMyce2RJJJbf/zqVJ97dlkQoh4SzXjCkiE4owqJpZWwoMpHp4Y91Cgo7dAmJxWfQ4mKHlUIyymPSpWo4PGJ4cl0QVaFiDul+KgnPP/BkQm34E0syfW4wq4npIjkz2YdXWBJkqPP06474669rrBEs1m+01zwwEhZUIWogmpUjjgFQ4p6CgbxhLH2I6miLoU9mRhR2k3ZIbnbvFHR58Hn8ZKMNGtyGNPlNmyfT4apDHh5unv2hJx0KpkeSfquhM3Ank/qhNfoLTRlv1WTnnqtium+jw7jN+ydUebHszf1W7tdGKf7rNW+YNAH1BsEGCxZt+CVDJSI4NMg6Gt+cNaNNOgj6e2fpkF4Iehb7wtC0BsoDRC8wKbSINhp9Mazmh/g5dPbf+ILctz/CyPCp1AAAAB4nGNgZGBgAGL181tmxPPbfGXgZmEAgeu8IQkI+n81qy5zI5DLwcAEEgUAFjoJXQB4nGNgZGBgbvjfwBDDGsQABKy6DIwMqCAJAFLvA0wAAHicY2FgYGB+ycDAwoAFM+IQJxZj00+hmaxBJKi/D6V/ALEohX6hMQYAGPYEswAAAAAAAAAAdgDCASgBmgHOAkQChgLSAwQDOgPWBEQEfgSsBR4FaAX8BoQHEAesCGwI3Aj4CTwJsgpWCqwK7gxADHIM8A14De4OLg6gDxIPrhBSEHIQpBEEEeYSHhLOEzATeBO+FCQUbhUWFWYV4hZyFwYXYhfeGAoYahi2GO4ZKhmsGiQaWhp8GpYbUBu8HDYcjBzIHRgdlh28Hi4edh6sHzAfsCASIHwg4CD4IRAhKCFAIaAh2iIMIkYihiKoIt4i+CMqJAIkTAAAeJxjYGRgYEhiVGfgZQABJiDmAkIGhv9gPgMAF7QBrgB4nF2Qy07CQBSG/0JBLYkLjSbuZmGM0aRcXBjZksCeBXsoUy5pO810IOFpXPoELl36FCZufBH/lgMLOjmn3/nPbTIArvALD/vvhrZnDz6jPddwhjvhOnUl7PPcCzfQwqNwk/qLcIBnvAq3cI0ZJ3j+BaMnbIQ9nONduIZLfAjXqX8K++Qv4QZu8S3cpP4jHGCCP+EWHry3YGD11Om5mu3UKjJZbDIXlDDWi00ytSWWNtG2WJlMdcNOGY50pu2hr9gues7FKrYmVUMO0EliVG7NWkcuXDqX99vtWPQwMimvMYCFxhSOfs7nmmFHv0IEgwxx5R3rDsqYdQs+R8Iee1QP/wmzFgXjMlLoIkTnmB0xm1UVp/sKbDm1R9Vxp6JZdqSkodxAc2NCVsir3JpKRD3EsurK0UebJz6pD6vd6T8/OGF2AAB4nG1SaZfURBTtO52k093TuIIbooK7BPcRUUBQEQX3XdZK5SVV3ZWqTC3TM/PrqXSE+UKdk3PuW/KWe99oazS82ejxr8QWxkiQIsMEOaaYYY5tLHAMT+BJPIWn8QyexXGcwHN4Hi/gRbyEk3gZp/AKXsVrOI0zeB1v4E28hbfxDt7FeziLAufwPj7Ah/gIH+MTfIodfIbz+BwX8AW+xEVcwmV8hSu4iq/xDb7FNXyH6/geP+AGbuJH/ISf8Qt+xW/4HX/gT/yFv/EP/sV/uIXbuIO7uIf7YCjBR9jPK8l0/2UisJLpKTcVFbWxq6Q1ltJDIUXIldQrqqTO6SAGpVIL5xlf0T4XTDc09qzJo8fW0olEmJYyR8xyMemsWRL3WeygTDPxa+k92ayRXoQy8bKldM9ITlljTKMoXZMszbajpiXtaxaUn/Z1Nz3TThhNOQ/dYC4lW4Z09zA6p33PwcuV4askQppw0/ZlxvGP1AlmaaglmKqTHi08aR4Tik3XpDRmNS2lL0PczOc149S7UmqZVOkhN0ZtO8PjJkUbyWBZZUJkLIuMSd3Mh502Q2zt7uZOhA2edlLHlcn5JLLkkjL6xjE462sXTpCqszhLQ74nq587Y0p27CB1q4OOsmWgpdRJL0uipPOzlnVFy+yK7CCC2SNbK7OOHATbKObcpKQoC6d5bVRFtjAd6WzASSQkpMGRdeOoZbamqKDPdGjLQRbFyrF1Lu/Vk3vk8p3zFTnZ6EllZVluJIrDzQ9MqJgptPE03WyyIV/QYTBJfy2LhwU2gSyOI4ydxWNRVFRmrf+HimqfDzB08wFY2Qifc6ZIV8weewgKLoivjsxW6uAWj8xOBXcU7C/L9bfgaFqRklya4JI+Z6tpZrWVMc0J2aVxZaLR6AG9AyuUAA==\") format(\"woff\"),url(\"iconfont.ttf?t=1525101408939\") format(\"truetype\"),url(\"iconfont.svg?t=1525101408939#icon\") format(\"svg\"); } .icon { display: inline-block; font: normal normal normal 14px/1 icon; font-size: inherit; text-rendering: auto; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale; } .icon-diandian:before { content: \"\\e63a\"; } .icon-huaban:before { content: \"\\e63c\"; } .icon-code-fork:before { content: \"\\e67a\"; } .icon-more:before { content: \"\\e6c0\"; } .icon-zhihu:before { content: \"\\e6d1\"; } .icon-linkedin:before { content: \"\\e724\"; } .icon-eye-fill:before { content: \"\\e64f\"; } .icon-stackexchange:before { content: \"\\e8b2\"; } .icon-tag:before { content: \"\\e6a3\"; } .icon-starfish:before { content: \"\\e62e\"; } .icon-home:before { content: \"\\e660\"; } .icon-search:before { content: \"\\e61c\"; } .icon-project:before { content: \"\\e63e\"; } .icon-dialog:before { content: \"\\e613\"; } .icon-twitter:before { content: \"\\ec9c\"; } .icon-github:before { content: \"\\e70a\"; } .icon-time:before { content: \"\\e669\"; } .icon-voice:before { content: \"\\e65a\"; } .icon-google:before { content: \"\\e601\"; } .icon-weibo:before { content: \"\\e64b\"; } .icon-segmentfault:before { content: \"\\e610\"; } .icon-star-fill:before { content: \"\\e630\"; } .icon-phone:before { content: \"\\e68a\"; } .icon-cup-fill:before { content: \"\\e614\"; } .icon-jiaju:before { content: \"\\e671\"; } .icon-qzone:before { content: \"\\e603\"; } .icon-home-fill:before { content: \"\\e617\"; } .icon-clock:before { content: \"\\e618\"; } .icon-file:before { content: \"\\e66f\"; } .icon-comment:before { content: \"\\e61a\"; } .icon-cup:before { content: \"\\e62c\"; } .icon-share:before { content: \"\\e66a\"; } .icon-star-half:before { content: \"\\e62f\"; } .icon-star:before { content: \"\\e619\"; } .icon-tencent-weibo:before { content: \"\\e602\"; } .icon-book:before { content: \"\\e79d\"; } .icon-bitbucket:before { content: \"\\e64e\"; } .icon-facebook:before { content: \"\\e6e3\"; } .icon-email:before { content: \"\\e667\"; } .icon-zcool:before { content: \"\\e60c\"; } .icon-social-media:before { content: \"\\e68b\"; } .icon-douban:before { content: \"\\e60f\"; } .icon-coding:before { content: \"\\e600\"; } .icon-github-fill:before { content: \"\\e71d\"; } .icon-qq:before { content: \"\\e611\"; } .icon-shu-fill:before { content: \"\\e615\"; } .icon-pinterest:before { content: \"\\e697\"; } .icon-tags:before { content: \"\\e6c4\"; } .icon-bill:before { content: \"\\e61b\"; } .icon-shu:before { content: \"\\e616\"; } .icon-book-shelf:before { content: \"\\e60d\"; } .icon-target:before { content: \"\\e695\"; } .icon-profile:before { content: \"\\e6e2\"; } .icon-alipay:before { content: \"\\e938\"; } .icon-skype:before { content: \"\\e604\"; } .icon-juejin:before { content: \"\\e605\"; } .icon-code:before { content: \"\\e73f\"; } .icon-list:before { content: \"\\e61e\"; } .icon-map-marker:before { content: \"\\e609\"; } .icon-stackoverflow:before { content: \"\\e606\"; } .icon-hourglass:before { content: \"\\e60e\"; } .icon-behance:before { content: \"\\e67b\"; } .icon-folder-open:before { content: \"\\e6b4\"; } .icon-folder:before { content: \"\\e60a\"; } .icon-menu:before { content: \"\\e607\"; } .icon-users:before { content: \"\\e60b\"; } .icon-eye:before { content: \"\\e657\"; } .icon-wechat:before { content: \"\\e65e\"; } .icon-number:before { content: \"\\e658\"; } .icon-gitlab:before { content: \"\\e67c\"; } .icon-rss:before { content: \"\\e63d\"; } .icon-archives:before { content: \"\\e62d\"; } .icon-68design:before { content: \"\\e608\"; } .icon-dribble:before { content: \"\\e982\"; } .icon-wepay:before { content: \"\\e629\"; } .icon-youdao-note:before { content: \"\\e8a6\"; } .icon-book-fill:before { content: \"\\e659\"; } .icon-hezuo:before { content: \"\\e6e5\"; } .icon-link:before { content: \"\\e635\"; } .icon-archives-fill:before { content: \"\\e694\"; } .icon-anchor:before { content: \"\\e858\"; } .icon-angle-down:before { content: \"\\e85e\"; } .icon-angle-left:before { content: \"\\e85f\"; } .icon-angle-up:before { content: \"\\e860\"; } .icon-angle-right:before { content: \"\\e862\"; } .icon-calendar:before { content: \"\\e895\"; } .icon-calendar-check:before { content: \"\\e896\"; } .icon-calendar-minus:before { content: \"\\e897\"; } .icon-calendar-plus:before { content: \"\\e899\"; } .icon-calendar-times:before { content: \"\\e89a\"; } .icon-close:before { content: \"\\e8c4\"; } .icon-delicious:before { content: \"\\e8e2\"; } .icon-plus:before { content: \"\\e99d\"; } .icon-gg:before { content: \"\\e6fd\"; } .icon-friendship:before { content: \"\\e612\"; } .icon-gitee:before { content: \"\\e61d\"; } pre .comment { color: #8e908c; } pre .variable, pre .attribute, pre .tag, pre .regexp, pre .ruby .constant, pre .xml .tag .title, pre .xml .pi, pre .xml .doctype, pre .html .doctype, pre .css .id, pre .css .class, pre .css .pseudo { color: #c82829; } pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant { color: #f5871f; } pre .ruby .class .title, pre .css .rules .attribute { color: #718c00; } pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata { color: #718c00; } pre .title, pre .css .hexcolor { color: #3e999f; } pre .function, pre .python .decorator, pre .python .title, pre .ruby .function .title, pre .ruby .title .keyword, pre .perl .sub, pre .javascript .title, pre .js .title, pre .coffeescript .title { color: #4271ae; } pre .keyword, pre .javascript .function, pre .js .function { color: #8959a8; } pre, .highlight { background: #fafafa; margin: 10px 0; padding: 15px 10px; overflow: auto; font-size: 13px; color: #4d4d4c; line-height: 1.5; } .highlight .gutter pre, .gist .gist-file .gist-data .line-numbers { color: #666; } code { text-shadow: 0 1px #fff; padding: 0.2em 0.4em; margin: 0 0.3em; color: #555; background: #eee; border-radius: 3px; font-size: 85%; } pre code { background: none; text-shadow: none; padding: 0; } .highlight { position: relative; padding: 32px 10px 0 10px; border-radius: 4px; } .highlight:before { display: block; content: ' '; height: 32px; position: absolute; top: 0; left: 0; right: 0; background-color: #f6f6f6; padding: 0 10px; border-top-left-radius: 4px; border-top-right-radius: 4px; } .highlight:after { content: \" \"; position: absolute; border-radius: 50%; background: #fc625d; width: 10px; height: 10px; top: 0; left: 15px; margin-top: 11px; -webkit-box-shadow: 20px 0 #fdbc40,40px 0 #35cd4b; box-shadow: 20px 0 #fdbc40,40px 0 #35cd4b; } .highlight pre { border: none; margin: 0; } .highlight table { position: relative; border: none; width: 100%; margin: 0; padding: 0; } .highlight tr { border: none; } .highlight td, .highlight th { border: none; padding: 0; } .highlight td.code, .highlight th.code { width: 100% !important; } .highlight figcaption { font-size: 0.85em; color: #8e908c; line-height: 1em; margin-bottom: 1em; } .highlight figcaption a { float: right; } .highlight .line { height: 24px; line-height: 24px; } .highlight .gutter pre { text-align: right; padding-right: 0; padding-left: 0; color: #ccc; } /* * Sidebar */ /* Hide for mobile, show later */ .header { background-color: #fbfbfb; } .sidebar { background-color: #fdfdfd; } .sidebar .slimContent { padding: 20px; } .main { position: relative; min-height: 100vh; padding: 15px; } .main:before, .main:after { content: \" \"; display: table; } .main:after { clear: both; } .footer { padding: 20px; background-color: #fbfbfb; } /* * main-center */ body.main-center .sidebar { left: auto; right: 0; border-left: 1px solid #f6f6f6; border-right: 0; } /* * main-left */ body.main-left .header { left: auto; right: 0; border-left: 1px solid #f6f6f6; border-right: 0; } body.main-left .sidebar { left: auto; right: 0; border-left: 1px solid #f6f6f6; border-right: 0; } body.main-left .footer { left: auto; right: 0; } /* * main-right */ body.no-sidebar .sidebar { display: none !important; } /** * Sidebar navigation */ .main-nav { float: none !important; } .main-nav > li { display: block; width: 100%; position: relative; } .main-nav > li > a { color: #555555; } .main-nav > li .menu-title { margin-left: 15px; } .main-nav > .active a, .main-nav > .active a:hover, .main-nav > .active a:focus { color: #333333; background: #f4f4f4; } /** * profile-block */ .profile-block { padding: 20px 15px 10px 15px; } #avatar { width: 64px; height: 64px; display: inline-block; } #avatar img { width: 100%; max-height: 100%; height: auto !important; } #name { font-size: 18px; margin-top: 10px; margin-bottom: 0; } #title { font-size: 13px; margin-top: 5px; margin-bottom: 5px; } /** * search */ .sidebar-form { border-radius: 3px; border: 1px solid #eee; margin: 0 15px 15px 15px; } .sidebar-form input[type=\"text\"], .sidebar-form .btn { -webkit-box-shadow: none; box-shadow: none; background-color: transparent; border: 1px solid transparent; height: 32px; } .sidebar-form input[type=\"text\"]:focus, .sidebar-form .btn:focus { outline: none; } .sidebar-form input[type=\"text\"] { color: #666; border-top-left-radius: 2px; border-top-right-radius: 0; border-bottom-right-radius: 0; border-bottom-left-radius: 2px; } .sidebar-form input[type=\"text\"]:focus, .sidebar-form input[type=\"text\"]:focus + .input-group-btn .btn { background-color: #fff; color: #666; } .sidebar-form .btn { color: #999; border-top-left-radius: 0; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 0; } .header { /** * navbar */ } .header .navbar-collapse { padding-left: 0; padding-right: 0; } .header .navbar-collapse .navbar-nav { margin: 0; } .header .navbar-toggle .icon-bar { background-color: #2196f3; } /* * Main content */ .main .pager { text-align: left; margin: 10px 0; } .main .pager .disabled { cursor: not-allowed; } .main .pager > a, .main .pager > .page-number { line-height: 32px; /* float: left; */ } .main .pager a { color: #666; border: 0; line-height: 32px; padding: 0; } .main .pager a:link, .main .pager a:visited { background-color: transparent; } .main .pager a:hover { color: #0a6ebd; background-color: transparent; } .main .pager .prev { margin-right: 10px; } .main .pager .page-number.current { color: #2196f3; } .main .pager .page-number + .page-number { margin-left: 10px; } .main .pager .page-number + .next { margin-left: 10px; } .main .total-article { margin: 10px 0; line-height: 32px; color: #999; } .main .page-header { margin-top: 0; } .main .article-list article { border-bottom: 1px solid #f2f2f2; } .main .article-list article:last-child { border-bottom: 0; } .main .article-meta { font-size: 13px; color: #999; } .main .article-meta a { color: #999; } .main .article-meta a:hover { color: #0a6ebd; text-decoration: none; } .main .article-meta span + span { margin-left: 10px; } .main .content { min-height: 85vh; } .main.has-sticky .content { margin-bottom: 70px; } #comments .gitment-footer-container, #comments .gitment-footer-project-link { display: none !important; } .panel .label, .widget .label { font-weight: normal; } .widget:before, .widget:after { content: \" \"; display: table; } .widget:after { clear: both; } .widget .widget-title { font-size: 18px; color: #000; } .widget time { color: #999; font-size: 12px; text-transform: uppercase; } .widget p { margin-bottom: 0; } .widget ul { margin-left: 0; padding-left: 0; list-style: none; } .widget .category-link { color: #0a6ebd; } .category-list-count, .tag-list-count, .archive-list-count { padding-left: 5px; color: #999; font-size: 0.85em; } .category-list-count:before, .tag-list-count:before, .archive-list-count:before { content: \"(\"; } .category-list-count:after, .tag-list-count:after, .archive-list-count:after { content: \")\"; } .category-list, .archive-list, .tag-list { line-height: 1.75; } .category-list li:before, .archive-list li:before, .tag-list li:before { color: #ccc; content: \"▪\"; font-size: 12px; margin-right: 6px; -webkit-transition: 0.2s ease; transition: 0.2s ease; } .category-list-child { padding-left: 15px; } .recent-post-list li + li { margin-top: 15px; } .recent-post-list li .item-thumb, .recent-post-list li .item-inner { display: table-cell; vertical-align: middle; } .recent-post-list li .item-thumb { opacity: 1; padding-right: 10px; -webkit-transition: all 0.2s ease; transition: all 0.2s ease; } .recent-post-list li .item-thumb .thumb { width: 50px; height: 50px; display: block; position: relative; overflow: hidden; } .recent-post-list li .item-thumb .thumb span { width: 100%; height: 100%; display: block; } .recent-post-list li .item-thumb .thumb .thumb-image { position: absolute; background-size: cover; background-position: center; } .recent-post-list li .item-thumb .thumb .thumb-none { background-image: url(\"../images/thumb-default.png\"); background-size: 100% 100%; } .recent-post-list li:hover .item-thumb { opacity: 0.8; } .sidebar-toc.collapse { display: none !important; } .sidebar-toc.in { display: block !important; } .tagcloud a { display: inline-block; margin-bottom: 0.2em; padding: .3em .6em; font-size: 75% !important; line-height: 1; background-color: #eee; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em; } .bar .pager .next > a, .bar .pager .next > span { float: none; } .bar.bar-footer { position: relative; background-color: #fff; bottom: -15px; } .bar.bar-footer:before { content: ''; position: absolute; width: -webkit-calc(100% + 30px); width: calc(100% + 30px); height: 52px; left: -15px; border-top: 1px solid #f6f6f6; border-bottom: 1px solid #fff; background-color: #fff; } .bar .bar-inner { position: relative; z-index: 9; } .bar .bar-inner:before, .bar .bar-inner:after { content: \" \"; display: table; } .bar .bar-inner:after { clear: both; } .bar .bar-right { margin: 10px 0; float: right; } .toggle-toc { cursor: pointer; margin-left: 10px; } .toggle-toc a { display: inline-block; line-height: 32px; text-align: center; } /** * footer */ .footer { color: #999; } .footer .copyright { font-size: 12px; } .footer .copyright a { color: #999; text-decoration: none; } .footer .copyright a:hover { color: #0a6ebd; } /** * .wave-icon */ .wave-icon { display: inline-block; position: relative; } .wave-icon .wave-circle { display: block; border-radius: 50%; background-color: transparent; } .wave-icon .wave-circle:before, .wave-icon .wave-circle:after { content: ''; border: 10px solid #2196f3; background: #2196f3; border-radius: 50%; position: absolute; top: 50%; left: 50%; z-index: 1; } .wave-icon .wave-circle:before { height: 74px; width: 74px; -webkit-animation: pulse 5s ease-out; animation: pulse 5s ease-out; -webkit-animation-iteration-count: infinite; animation-iteration-count: infinite; margin-top: -37px; margin-left: -37px; opacity: 0; } .wave-icon .wave-circle:after { height: 98px; width: 98px; -webkit-animation: pulse 5s ease-out; animation: pulse 5s ease-out; -webkit-animation-iteration-count: infinite; animation-iteration-count: infinite; margin-top: -49px; margin-left: -49px; opacity: 0.3; } .wave-icon .icon { position: relative; display: block; width: 50px; height: 50px; line-height: 50px; text-align: center; background-color: #2196f3; border-radius: 50%; font-size: 24px; color: #fff; z-index: 2; } .wave-icon.wave-icon-info .wave-circle:before, .wave-icon.wave-icon-info .wave-circle:after { border: 10px solid #56CCF2; background: #56CCF2; } .wave-icon.wave-icon-info .icon { background-color: #56CCF2; } .wave-icon.wave-icon-primary .wave-circle:before, .wave-icon.wave-icon-primary .wave-circle:after { border: 10px solid #2196f3; background: #2196f3; } .wave-icon.wave-icon-primary .icon { background-color: #2196f3; } .wave-icon.wave-icon-warning .wave-circle:before, .wave-icon.wave-icon-warning .wave-circle:after { border: 10px solid #F09819; background: #F09819; } .wave-icon.wave-icon-warning .icon { background-color: #F09819; } .wave-icon.wave-icon-success .wave-circle:before, .wave-icon.wave-icon-success .wave-circle:after { border: 10px solid #5cb85c; background: #5cb85c; } .wave-icon.wave-icon-success .icon { background-color: #5cb85c; } .wave-icon.wave-icon-danger .wave-circle:before, .wave-icon.wave-icon-danger .wave-circle:after { border: 10px solid #FF512F; background: #FF512F; } .wave-icon.wave-icon-danger .icon { background-color: #FF512F; } @-webkit-keyframes pulse { 0% { -webkit-transform: scale(0); opacity: 0.0; } 25% { -webkit-transform: scale(0); opacity: 0.1; } 50% { -webkit-transform: scale(0.1); opacity: 0.3; } 75% { -webkit-transform: scale(0.5); opacity: 0.5; } 100% { -webkit-transform: scale(1); opacity: 0.0; } } .repo-list { list-style: none; padding-left: 0; } .repo { position: relative; list-style-type: none; border: 1px solid #f2f2f2; margin-bottom: 15px; overflow: hidden; } .repo-title { padding: 0 15px; margin: 15px 0; font-size: 16px; font-weight: 600; } .repo-body { display: -webkit-box; padding: 0 15px; margin: 0 0 20px; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 2; line-height: 1.5em; height: 3em; word-break: break-all !important; word-wrap: break-word !important; } .repo-image { position: relative; display: table; width: 101%; height: 3px; margin: -1px -1px 15px; background-color: #666; } .repo-meta { padding: 0 15px; margin-top: 5px; margin-bottom: 15px; color: #777; font-size: 12px; text-align: right; } .repo-meta:before, .repo-meta:after { content: \" \"; display: table; } .repo-meta:after { clear: both; } .repo-meta .meta + .meta { margin-left: 15px; } /* * Global add-ons */ .text-collapsed { display: none; } .text-in { display: inline-block; } .collapsed .text-collapsed { display: inline-block; } .collapsed .text-in { display: none; } .sub-header { padding-bottom: 10px; border-bottom: 1px solid #eee; } .article-header { margin-bottom: 20px; } .article-footer { margin-top: 20px; } /** * collection */ .collection { position: relative; } .collection a.collection-item { display: block; -webkit-transition: .25s; transition: .25s; color: #777777; } .collection a:not(.active):hover { color: #333333; } .collection .collection-item { padding: 8px 0; margin: 0; } .article-list .article-title { font-size: 18px; } .article-toc .toc-title { font-size: 18px; color: #000; } .article-toc .toc { list-style: none; padding-left: 0; line-height: 2.0; } .article-toc .toc ol { list-style: none; padding-left: 10px; } .article-toc .toc .toc-item { position: relative; } .article-toc .toc .toc-item .markdownIt-Anchor { position: absolute; left: 0; right: 0; top: 0; padding: 14px 0; } .marked-body h1, .marked-body h2, .marked-body h3, .marked-body h4, .marked-body h5, .marked-body h6 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; } .marked-body h1 { padding-bottom: 0.3em; font-size: 2em; border-bottom: 1px solid #f2f2f2; } .marked-body h2 { padding-bottom: 0.3em; font-size: 1.5em; border-bottom: 1px solid #f2f2f2; } .marked-body a { color: #2196f3; text-decoration: none; } .marked-body a:focus, .marked-body a:hover { color: #0a6ebd; text-decoration: none; } .marked-body ul, .marked-body ol { padding-left: 0; margin-left: 20px; } /* * We are hiding the invisible nav outside the screen * so we need to avoid the horizontal scroll */ body.okayNav-loaded { overflow-x: hidden; } .okayNav { position: relative; } .okayNav:before, .okayNav:after { content: \" \"; display: table; } .okayNav:after { clear: both; } .okayNav:not(.loaded) { visibility: hidden; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .okayNav ul { /* We want two navigations - one hidden and one visible */ float: left; padding-left: 0; } .okayNav ul li { display: inline-block; margin-left: 15px; } .okayNav a { position: relative; z-index: 1; } .okayNav a.active { color: #0a6ebd; } .okayNav__nav--visible { overflow: hidden; white-space: nowrap; } .okayNav__nav--visible li { display: inline-block; margin-left: 15px; } .okayNav__nav--visible li:first-child { margin-left: 0; } .okayNav__nav--visible a { /* Link styling for the visible part of the nav */ display: block; -webkit-transition: color 200ms cubic-bezier(0.55, 0, 0.1, 1); transition: color 200ms cubic-bezier(0.55, 0, 0.1, 1); } .okayNav__nav--visible:empty ~ .okayNav__menu-toggle { top: 0; } /* Link styling for the off-screen part of the nav */ .okayNav__nav--invisible { display: none; position: absolute; width: 100%; top: 24px; overflow-y: auto; -webkit-overflow-scrolling: touch; -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); padding-top: 15px; padding-bottom: 15px; background: #fff; } .okayNav__nav--invisible li { display: inline-block; } .okayNav__nav--invisible li a { display: block; padding: 6px 15px; min-width: 100px; } .okayNav__nav--invisible.nav-left { left: 0; } .okayNav__nav--invisible.nav-right { right: 0; } .okayNav__nav--invisible.transition-enabled { -webkit-transition: -webkit-transform 400ms cubic-bezier(0.55, 0, 0.1, 1); transition: -webkit-transform 400ms cubic-bezier(0.55, 0, 0.1, 1); transition: transform 400ms cubic-bezier(0.55, 0, 0.1, 1); transition: transform 400ms cubic-bezier(0.55, 0, 0.1, 1),-webkit-transform 400ms cubic-bezier(0.55, 0, 0.1, 1); } .okayNav__nav--invisible.nav-open { display: block; z-index: 99; border: 1px solid #f2f2f2; } /* Kebab icon */ .okayNav__menu-toggle { position: relative; z-index: 1; float: right; cursor: pointer; -webkit-transition: -webkit-transform 400ms cubic-bezier(0.55, 0, 0.1, 1); transition: -webkit-transform 400ms cubic-bezier(0.55, 0, 0.1, 1); transition: transform 400ms cubic-bezier(0.55, 0, 0.1, 1); transition: transform 400ms cubic-bezier(0.55, 0, 0.1, 1),-webkit-transform 400ms cubic-bezier(0.55, 0, 0.1, 1); } .okayNav__menu-toggle.okay-invisible { position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none; opacity: 0; } .okayNav__menu-toggle span { background: #666; display: inline-block; width: 2px; height: 2px; margin: auto 1px; pointer-events: none; border-radius: 50%; vertical-align: middle; } .okayNav__menu-toggle.icon--active { /* Kebab icon when off-screen nav is open */ } .okayNav__menu-toggle.icon--active span { background: #0a6ebd; } .okayNav a { color: #2e2e33; font-weight: 400; } .okayNav a:hover { color: #0a6ebd; } /** * social-links */ .social-links { list-style: none; padding: 0; text-align: left; } .social-links li { list-style: none; display: inline-block; margin-left: 10px; } .social-links li:first-child { margin-left: 0; } .header .social-links { padding: 10px 20px; } .footer .social-links { margin-bottom: 5px; } @font-face { font-family: \"socialshare\"; src: url(\"../fonts/iconfont.eot\"); /* IE9*/ src: url(\"../fonts/iconfont.eot?#iefix\") format(\"embedded-opentype\"),url(\"../fonts/iconfont.woff\") format(\"woff\"),url(\"../fonts/iconfont.ttf\") format(\"truetype\"),url(\"../fonts/iconfont.svg#iconfont\") format(\"svg\"); } .social-share { display: inline-block; font-size: 16px; } .social-share a { position: relative; text-decoration: none; margin-left: 16px; display: inline-block; outline: none; line-height: 32px; } .social-share .social-share-icon { position: relative; display: inline-block; height: 32px; line-height: 32px; color: #999; text-align: center; vertical-align: middle; -webkit-transition: background 0.6s ease-out 0s; transition: background 0.6s ease-out 0s; } .social-share .social-share-icon:hover { color: #666; } .social-share .icon-weibo:hover { color: #ff763b; } .social-share .icon-tencent:hover { color: #56b6e7; } .social-share .icon-qq:hover { color: #56b6e7; } .social-share .icon-qzone:hover { color: #FDBE3D; } .social-share .icon-douban:hover { color: #33b045; } .social-share .icon-linkedin:hover { color: #0077B5; } .social-share .icon-facebook:hover { color: #44619D; } .social-share .icon-google:hover { color: #db4437; } .social-share .icon-twitter:hover { color: #55acee; } .social-share .icon-diandian:hover { color: #307DCA; } .social-share .icon-wechat { position: relative; } .social-share .icon-wechat:hover { color: #7bc549; } .social-share .icon-wechat .wechat-qrcode { display: none; border: 1px solid #eee; position: absolute; z-index: 9; top: -209px; left: -90px; width: 200px; height: 200px; color: #666; font-size: 12px; text-align: center; background-color: #fff; -webkit-transition: all 200ms; transition: all 200ms; -webkit-tansition: all 350ms; -moz-transition: all 350ms; } .social-share .icon-wechat .wechat-qrcode.bottom { top: 40px; left: -84px; } .social-share .icon-wechat .wechat-qrcode.bottom:after { display: none; } .social-share .icon-wechat .wechat-qrcode h4 { font-weight: normal; height: 26px; line-height: 26px; font-size: 12px; background-color: #f3f3f3; margin: 0; padding: 0; color: #777; } .social-share .icon-wechat .wechat-qrcode .qrcode { width: 105px; margin: 15px auto; } .social-share .icon-wechat .wechat-qrcode .qrcode table { margin: 0 !important; } .social-share .icon-wechat .wechat-qrcode .help p { font-weight: normal; line-height: 16px; padding: 0; margin: 0; } .social-share .icon-wechat .wechat-qrcode:before { content: ''; position: absolute; left: 50%; margin-left: -6px; bottom: -15px; width: 0; height: 0; border-width: 8px 6px 6px 6px; border-style: solid; border-color: #eee transparent transparent transparent; } .social-share .icon-wechat .wechat-qrcode:after { content: ''; position: absolute; left: 50%; margin-left: -6px; bottom: -13px; width: 0; height: 0; border-width: 8px 6px 6px 6px; border-style: solid; border-color: #fff transparent transparent transparent; } .social-share .icon-wechat:hover .wechat-qrcode { display: block; } .btn-donate { position: absolute; bottom: 10px; left: 50%; margin-left: -25px; width: 50px; height: 50px; line-height: 50px; padding: 0; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 99; } .btn-donate:focus, .btn-donate:hover, .btn-donate:active { border-color: transparent !important; outline: none !important; } .btn-donate.btn-fancy { background-color: transparent; } .btn-donate.btn-fancy span { width: 50px; height: 50px; padding: 0; } .donate { overflow: hidden; } .donate-box { text-align: center; padding-top: 30px; } .donate-box .donate-head { width: 100%; height: 80px; text-align: center; line-height: 60px; color: #a3a3a3; font-size: 16px; position: relative; } .donate-box .donate-head:before, .donate-box .donate-head:after { font-family: Arial,Helvetica,sans-serif; background: none; width: 0px; height: 0px; font-style: normal; color: #eee; font-size: 100px; position: absolute; top: 15px; } .donate-box .donate-head:before { content: '\\201c'; left: 30px; } .donate-box .donate-head:after { content: '\\201d'; right: 70px; } .donate-box .donate-footer { padding-top: 35px; } .donate-box .donate-payimg { display: inline-block; padding: 10px; border: 6px solid #ea5f00; margin: 0 auto; border-radius: 3px; } .donate-box .donate-payimg img { display: block; text-align: center; width: 140px; height: 140px; } .book .media-middle { display: inline-block; width: 115px; } .ins-search { display: none; } .ins-search.show { display: block; } .ins-selectable { cursor: pointer; } .ins-search-mask, .ins-search-container { position: fixed; } .ins-search-mask { top: 0; left: 0; width: 100%; height: 100%; z-index: 1050; background: rgba(0, 0, 0, 0.5); } .ins-input-wrapper { position: relative; } .ins-search-input { width: 100%; border: none; outline: none; font-size: 16px; -webkit-box-shadow: none; box-shadow: none; font-weight: 200; border-radius: 0; background: #fff; line-height: 20px; -webkit-box-sizing: border-box; box-sizing: border-box; padding: 12px 28px 12px 20px; border-bottom: 1px solid #e2e2e2; font-family: \"Microsoft Yahei Light\",\"Microsoft Yahei\",Helvetica,Arial,sans-serif; } .ins-close { top: 50%; right: 6px; width: 20px; height: 20px; font-size: 24px; margin-top: -15px; position: absolute; text-align: center; opacity: 1.0; color: #666; display: inline-block; } .ins-close:hover { color: #006bde; } .ins-search-container { left: 50%; top: 100px; z-index: 1051; bottom: 100px; -webkit-box-sizing: border-box; box-sizing: border-box; width: 540px; margin-left: -270px; } .ins-section-wrapper { left: 0; right: 0; top: 45px; bottom: 0; overflow-y: auto; position: absolute; } .ins-section-container { position: relative; background: #f7f7f7; } .ins-section { font-size: 14px; line-height: 16px; } .ins-section .ins-section-header, .ins-section .ins-search-item { padding: 8px 15px; } .ins-section .ins-section-header { color: #9a9a9a; border-bottom: 1px solid #e2e2e2; } .ins-section .ins-slug { margin-left: 5px; color: #9a9a9a; } .ins-section .ins-slug:before { content: '('; } .ins-section .ins-slug:after { content: ')'; } .ins-section .ins-search-item header, .ins-section .ins-search-item .ins-search-preview { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .ins-section .ins-search-item header .icon { margin-right: 8px; } .ins-section .ins-search-item .ins-search-preview { height: 15px; font-size: 12px; color: #9a9a9a; margin: 5px 0 0 20px; } .ins-section .ins-search-item:hover, .ins-section .ins-search-item.active { color: #fff; background: #006bde; } .ins-section .ins-search-item:hover .ins-slug, .ins-section .ins-search-item.active .ins-slug, .ins-section .ins-search-item:hover .ins-search-preview, .ins-section .ins-search-item.active .ins-search-preview { color: #fff; } .theme-black .header, .theme-blue .header, .theme-green .header, .theme-purple .header { color: #fff; } .theme-black .header a, .theme-blue .header a, .theme-green .header a, .theme-purple .header a { color: #efefef; } .theme-black .header #location, .theme-blue .header #location, .theme-green .header #location, .theme-purple .header #location { color: rgba(255, 255, 255, 0.75) !important; } .theme-black .header .navbar-toggle .icon-bar, .theme-blue .header .navbar-toggle .icon-bar, .theme-green .header .navbar-toggle .icon-bar, .theme-purple .header .navbar-toggle .icon-bar { background-color: #fff; } .theme-black .footer, .theme-blue .footer, .theme-green .footer, .theme-purple .footer { color: rgba(255, 255, 255, 0.75); } .theme-black .footer a, .theme-blue .footer a, .theme-green .footer a, .theme-purple .footer a { color: rgba(255, 255, 255, 0.75); } .theme-black .header a:focus, .theme-black .header a:hover, .theme-black .header a.active, .theme-black .footer a:focus, .theme-black .footer a:hover, .theme-black .footer a.active, .theme-blue .header a:focus, .theme-blue .header a:hover, .theme-blue .header a.active, .theme-blue .footer a:focus, .theme-blue .footer a:hover, .theme-blue .footer a.active, .theme-green .header a:focus, .theme-green .header a:hover, .theme-green .header a.active, .theme-green .footer a:focus, .theme-green .footer a:hover, .theme-green .footer a.active, .theme-purple .header a:focus, .theme-purple .header a:hover, .theme-purple .header a.active, .theme-purple .footer a:focus, .theme-purple .footer a:hover, .theme-purple .footer a.active { color: #fff; } .theme-black .main-nav > li > a:focus, .theme-black .main-nav > li > a:hover, .theme-black .main-nav > li > a.active, .theme-blue .main-nav > li > a:focus, .theme-blue .main-nav > li > a:hover, .theme-blue .main-nav > li > a.active, .theme-green .main-nav > li > a:focus, .theme-green .main-nav > li > a:hover, .theme-green .main-nav > li > a.active, .theme-purple .main-nav > li > a:focus, .theme-purple .main-nav > li > a:hover, .theme-purple .main-nav > li > a.active { color: #fff; background: rgba(0, 0, 0, 0.15); } .theme-black .main-nav > .active a, .theme-black .main-nav > .active a:focus, .theme-black .main-nav > .active a:hover, .theme-black .main-nav > .active a.active, .theme-blue .main-nav > .active a, .theme-blue .main-nav > .active a:focus, .theme-blue .main-nav > .active a:hover, .theme-blue .main-nav > .active a.active, .theme-green .main-nav > .active a, .theme-green .main-nav > .active a:focus, .theme-green .main-nav > .active a:hover, .theme-green .main-nav > .active a.active, .theme-purple .main-nav > .active a, .theme-purple .main-nav > .active a:focus, .theme-purple .main-nav > .active a:hover, .theme-purple .main-nav > .active a.active { color: #fff; background: rgba(0, 0, 0, 0.2); } .theme-black .search .sidebar-form, .theme-blue .search .sidebar-form, .theme-green .search .sidebar-form, .theme-purple .search .sidebar-form { border: 0; background: rgba(0, 0, 0, 0.2); } .theme-black .search .sidebar-form input::-webkit-input-placeholder, .theme-blue .search .sidebar-form input::-webkit-input-placeholder, .theme-green .search .sidebar-form input::-webkit-input-placeholder, .theme-purple .search .sidebar-form input::-webkit-input-placeholder { color: rgba(255, 255, 255, 0.5); } .theme-black .search .sidebar-form input:-moz-placeholder, .theme-blue .search .sidebar-form input:-moz-placeholder, .theme-green .search .sidebar-form input:-moz-placeholder, .theme-purple .search .sidebar-form input:-moz-placeholder { color: rgba(255, 255, 255, 0.5); } .theme-black .search .sidebar-form input::-moz-placeholder, .theme-blue .search .sidebar-form input::-moz-placeholder, .theme-green .search .sidebar-form input::-moz-placeholder, .theme-purple .search .sidebar-form input::-moz-placeholder { color: rgba(255, 255, 255, 0.5); } .theme-black .search .sidebar-form input:-ms-input-placeholder, .theme-blue .search .sidebar-form input:-ms-input-placeholder, .theme-green .search .sidebar-form input:-ms-input-placeholder, .theme-purple .search .sidebar-form input:-ms-input-placeholder { color: rgba(255, 255, 255, 0.5); } .theme-black .search input[type=\"text\"], .theme-blue .search input[type=\"text\"], .theme-green .search input[type=\"text\"], .theme-purple .search input[type=\"text\"] { color: #666; } .theme-black .search input[type=\"text\"] + .input-group-btn .btn, .theme-blue .search input[type=\"text\"] + .input-group-btn .btn, .theme-green .search input[type=\"text\"] + .input-group-btn .btn, .theme-purple .search input[type=\"text\"] + .input-group-btn .btn { color: rgba(255, 255, 255, 0.5); } .theme-black .search input[type=\"text\"]:focus, .theme-black .search input[type=\"text\"]:focus + .input-group-btn .btn, .theme-blue .search input[type=\"text\"]:focus, .theme-blue .search input[type=\"text\"]:focus + .input-group-btn .btn, .theme-green .search input[type=\"text\"]:focus, .theme-green .search input[type=\"text\"]:focus + .input-group-btn .btn, .theme-purple .search input[type=\"text\"]:focus, .theme-purple .search input[type=\"text\"]:focus + .input-group-btn .btn { background-color: #fff; color: #666; } .theme-black .header { background: #1a2433; background: -webkit-linear-gradient(left, #1a2433 0%, #253449 80%, #253449 100%); background: -webkit-gradient(linear, left top, right top, from(#1a2433), color-stop(80%, #253449), to(#253449)); background: linear-gradient(to right, #1a2433 0%, #253449 80%, #253449 100%); } .theme-blue .header { background: #0062c5; background: -webkit-linear-gradient(left, #0062c5 0%, #0073e6 80%, #0073e6 100%); background: -webkit-gradient(linear, left top, right top, from(#0062c5), color-stop(80%, #0073e6), to(#0073e6)); background: linear-gradient(to right, #0062c5 0%, #0073e6 80%, #0073e6 100%); } .theme-green .header { background: #08a283; background: -webkit-linear-gradient(left, #08a283 0%, #0ac29d 80%, #0ac29d 100%); background: -webkit-gradient(linear, left top, right top, from(#08a283), color-stop(80%, #0ac29d), to(#0ac29d)); background: linear-gradient(to right, #08a283 0%, #0ac29d 80%, #0ac29d 100%); } .theme-purple .header { background: #494683; background: -webkit-linear-gradient(left, #494683 0%, #555299 80%, #555299 100%); background: -webkit-gradient(linear, left top, right top, from(#494683), color-stop(80%, #555299), to(#555299)); background: linear-gradient(to right, #494683 0%, #555299 80%, #555299 100%); } @media (min-width: 767px) { .modal-center { text-align: center; padding: 0 !important; } .modal-center:before { content: ''; display: inline-block; height: 100%; vertical-align: middle; margin-right: -4px; } .modal-center .modal-dialog { display: inline-block; text-align: left; vertical-align: middle; } .donate-box .donate-footer { margin: 0 -15px -16px -15px; } } @media (min-width: 768px) { .lead { font-size: 21px; } .dl-horizontal dt { float: left; width: 160px; clear: left; text-align: right; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .dl-horizontal dd { margin-left: 180px; } .container { width: 750px; } .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12 { float: left; } .col-sm-1 { width: 8.33333%; } .col-sm-2 { width: 16.66667%; } .col-sm-3 { width: 25%; } .col-sm-4 { width: 33.33333%; } .col-sm-5 { width: 41.66667%; } .col-sm-6 { width: 50%; } .col-sm-7 { width: 58.33333%; } .col-sm-8 { width: 66.66667%; } .col-sm-9 { width: 75%; } .col-sm-10 { width: 83.33333%; } .col-sm-11 { width: 91.66667%; } .col-sm-12 { width: 100%; } .col-sm-pull-0 { right: auto; } .col-sm-pull-1 { right: 8.33333%; } .col-sm-pull-2 { right: 16.66667%; } .col-sm-pull-3 { right: 25%; } .col-sm-pull-4 { right: 33.33333%; } .col-sm-pull-5 { right: 41.66667%; } .col-sm-pull-6 { right: 50%; } .col-sm-pull-7 { right: 58.33333%; } .col-sm-pull-8 { right: 66.66667%; } .col-sm-pull-9 { right: 75%; } .col-sm-pull-10 { right: 83.33333%; } .col-sm-pull-11 { right: 91.66667%; } .col-sm-pull-12 { right: 100%; } .col-sm-push-0 { left: auto; } .col-sm-push-1 { left: 8.33333%; } .col-sm-push-2 { left: 16.66667%; } .col-sm-push-3 { left: 25%; } .col-sm-push-4 { left: 33.33333%; } .col-sm-push-5 { left: 41.66667%; } .col-sm-push-6 { left: 50%; } .col-sm-push-7 { left: 58.33333%; } .col-sm-push-8 { left: 66.66667%; } .col-sm-push-9 { left: 75%; } .col-sm-push-10 { left: 83.33333%; } .col-sm-push-11 { left: 91.66667%; } .col-sm-push-12 { left: 100%; } .col-sm-offset-0 { margin-left: 0%; } .col-sm-offset-1 { margin-left: 8.33333%; } .col-sm-offset-2 { margin-left: 16.66667%; } .col-sm-offset-3 { margin-left: 25%; } .col-sm-offset-4 { margin-left: 33.33333%; } .col-sm-offset-5 { margin-left: 41.66667%; } .col-sm-offset-6 { margin-left: 50%; } .col-sm-offset-7 { margin-left: 58.33333%; } .col-sm-offset-8 { margin-left: 66.66667%; } .col-sm-offset-9 { margin-left: 75%; } .col-sm-offset-10 { margin-left: 83.33333%; } .col-sm-offset-11 { margin-left: 91.66667%; } .col-sm-offset-12 { margin-left: 100%; } .navbar-right .dropdown-menu { right: 0; left: auto; } .navbar-right .dropdown-menu-left { left: 0; right: auto; } .nav-justified > li, .nav-tabs.nav-justified > li { display: table-cell; width: 1%; } .nav-justified > li > a, .nav-tabs.nav-justified > li > a { margin-bottom: 0; } .nav-tabs-justified > li > a, .nav-tabs.nav-justified > li > a { border-bottom: 1px solid #f2f2f2; border-radius: 4px 4px 0 0; } .nav-tabs-justified > .active > a, .nav-tabs.nav-justified > .active > a, .nav-tabs-justified > .active > a:hover, .nav-tabs.nav-justified > .active > a:hover, .nav-tabs-justified > .active > a:focus, .nav-tabs.nav-justified > .active > a:focus { border-bottom-color: #fff; } .navbar { border-radius: 4px; } .navbar-header { float: left; } .navbar-collapse { width: auto; border-top: 0; -webkit-box-shadow: none; box-shadow: none; } .navbar-collapse.collapse { display: block !important; height: auto !important; padding-bottom: 0; overflow: visible !important; } .navbar-collapse.in { overflow-y: visible; } .navbar-fixed-top .navbar-collapse, .navbar-static-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { padding-left: 0; padding-right: 0; } .container > .navbar-header, .container > .navbar-collapse, .container-fluid > .navbar-header, .container-fluid > .navbar-collapse { margin-right: 0; margin-left: 0; } .navbar-static-top { border-radius: 0; } .navbar-fixed-top, .navbar-fixed-bottom { border-radius: 0; } .navbar > .container .navbar-brand, .navbar > .container-fluid .navbar-brand { margin-left: -15px; } .navbar-toggle { display: none; } .navbar-nav { float: left; margin: 0; } .navbar-nav > li { float: left; } .navbar-nav > li > a { padding-top: 14.5px; padding-bottom: 14.5px; } .navbar-form .form-group { display: inline-block; margin-bottom: 0; vertical-align: middle; } .navbar-form .form-control { display: inline-block; width: auto; vertical-align: middle; } .navbar-form .form-control-static { display: inline-block; } .navbar-form .input-group { display: inline-table; vertical-align: middle; } .navbar-form .input-group .input-group-addon, .navbar-form .input-group .input-group-btn, .navbar-form .input-group .form-control { width: auto; } .navbar-form .input-group > .form-control { width: 100%; } .navbar-form .control-label { margin-bottom: 0; vertical-align: middle; } .navbar-form .radio, .navbar-form .checkbox { display: inline-block; margin-top: 0; margin-bottom: 0; vertical-align: middle; } .navbar-form .radio label, .navbar-form .checkbox label { padding-left: 0; } .navbar-form .radio input[type=\"radio\"], .navbar-form .checkbox input[type=\"checkbox\"] { position: relative; margin-left: 0; } .navbar-form .has-feedback .form-control-feedback { top: 0; } .navbar-form { width: auto; border: 0; margin-left: 0; margin-right: 0; padding-top: 0; padding-bottom: 0; -webkit-box-shadow: none; box-shadow: none; } .navbar-text { float: left; margin-left: 15px; margin-right: 15px; } .navbar-left { float: left !important; } .navbar-right { float: right !important; margin-right: -15px; } .navbar-right ~ .navbar-right { margin-right: 0; } .modal-dialog { width: 600px; margin: 30px auto; } .modal-content { -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05); } .modal-sm { width: 300px; } .header { position: fixed; top: 0; bottom: 0; left: 0; z-index: 1000; display: block; padding: 0; overflow-y: auto; /* Scrollable contents if viewport is shorter than content. */ border-right: 1px solid #f6f6f6; width: 4.16667%; } .sidebar { position: fixed; top: 0; bottom: 0; left: 0; display: block; padding: 0; overflow-x: hidden; overflow-y: auto; /* Scrollable contents if viewport is shorter than content. */ border-right: 1px solid #f6f6f6; width: 33.33333%; } .main { width: 62.5%; padding-right: 20px; padding-left: 20px; } .footer { position: fixed; left: 0; bottom: 0; background-color: transparent; z-index: 1050; width: 4.16667%; } body.main-center .main { margin-left: 4.16667%; } body.main-left .sidebar { margin-right: 4.16667%; } body.main-right .sidebar { margin-left: 4.16667%; } body.main-right .main { margin-left: 37.5%; } body.no-sidebar.main-left .main { width: 95.83333333%; margin-right: 4.16667%; } body.no-sidebar.main-right .main, body.no-sidebar.main-center .main { width: 95.83333333%; margin-left: 4.16667%; } .header .navbar-header { float: none; } #avatar img { padding: 5px; } .bar.bar-footer:before { width: -webkit-calc(100% + 40px); width: calc(100% + 40px); left: -20px; } .header .social-links { display: none; } } @media (min-width: 992px) { .slimContent{ margin-top: 20px; } .container { width: 970px; } .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 { float: left; } .col-md-1 { width: 8.33333%; } .col-md-2 { width: 16.66667%; } .col-md-3 { width: 25%; } .col-md-4 { width: 33.33333%; } .col-md-5 { width: 41.66667%; } .col-md-6 { width: 50%; } .col-md-7 { width: 58.33333%; } .col-md-8 { width: 66.66667%; } .col-md-9 { width: 75%; } .col-md-10 { width: 83.33333%; } .col-md-11 { width: 91.66667%; } .col-md-12 { width: 100%; } .col-md-pull-0 { right: auto; } .col-md-pull-1 { right: 8.33333%; } .col-md-pull-2 { right: 16.66667%; } .col-md-pull-3 { right: 25%; } .col-md-pull-4 { right: 33.33333%; } .col-md-pull-5 { right: 41.66667%; } .col-md-pull-6 { right: 50%; } .col-md-pull-7 { right: 58.33333%; } .col-md-pull-8 { right: 66.66667%; } .col-md-pull-9 { right: 75%; } .col-md-pull-10 { right: 83.33333%; } .col-md-pull-11 { right: 91.66667%; } .col-md-pull-12 { right: 100%; } .col-md-push-0 { left: auto; } .col-md-push-1 { left: 8.33333%; } .col-md-push-2 { left: 16.66667%; } .col-md-push-3 { left: 25%; } .col-md-push-4 { left: 33.33333%; } .col-md-push-5 { left: 41.66667%; } .col-md-push-6 { left: 50%; } .col-md-push-7 { left: 58.33333%; } .col-md-push-8 { left: 66.66667%; } .col-md-push-9 { left: 75%; } .col-md-push-10 { left: 83.33333%; } .col-md-push-11 { left: 91.66667%; } .col-md-push-12 { left: 100%; } .col-md-offset-0 { margin-left: 0%; } .col-md-offset-1 { margin-left: 8.33333%; } .col-md-offset-2 { margin-left: 16.66667%; } .col-md-offset-3 { margin-left: 25%; } .col-md-offset-4 { margin-left: 33.33333%; } .col-md-offset-5 { margin-left: 41.66667%; } .col-md-offset-6 { margin-left: 50%; } .col-md-offset-7 { margin-left: 58.33333%; } .col-md-offset-8 { margin-left: 66.66667%; } .col-md-offset-9 { margin-left: 75%; } .col-md-offset-10 { margin-left: 83.33333%; } .col-md-offset-11 { margin-left: 91.66667%; } .col-md-offset-12 { margin-left: 100%; } .modal-lg { width: 900px; } .header { width: 16.66667%; } .sidebar { width: 25%; } .sidebar .slimContent { padding-right: 25px; padding-left: 25px; } .main { width: 58.33333%; padding-right: 25px; padding-left: 25px; } .footer { width: 16.66667%; } body.main-center .main { margin-left: 16.66667%; } body.main-left .sidebar { margin-right: 16.66667%; } body.main-right .sidebar { margin-left: 16.66667%; } body.main-right .main { margin-left: 41.66667%; } body.no-sidebar.main-left .main { width: 83.33333333%; margin-right: 16.66667%; } body.no-sidebar.main-right .main, body.no-sidebar.main-center .main { width: 83.33333333%; margin-left: 16.66667%; } .bar.bar-footer:before { width: -webkit-calc(100% + 50px); width: calc(100% + 50px); left: -25px; } .marked-body .headerlink:before, .marked-body .markdownIt-Anchor:before { display: inline-block; width: 18px; content: \"#\"; color: #0a6ebd; text-align: right; float: left; visibility: hidden; } .marked-body .headerlink:before { margin-left: -15px; padding-right: 2px; } .marked-body .markdownIt-Anchor:before { margin-left: -20px; } .marked-body h1:hover .headerlink:before, .marked-body h1:hover .markdownIt-Anchor:before, .marked-body h2:hover .headerlink:before, .marked-body h2:hover .markdownIt-Anchor:before, .marked-body h3:hover .headerlink:before, .marked-body h3:hover .markdownIt-Anchor:before, .marked-body h4:hover .headerlink:before, .marked-body h4:hover .markdownIt-Anchor:before, .marked-body h5:hover .headerlink:before, .marked-body h5:hover .markdownIt-Anchor:before, .marked-body h6:hover .headerlink:before, .marked-body h6:hover .markdownIt-Anchor:before { visibility: visible; } } @media (min-width: 1200px) { .container { width: 1170px; } .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 { float: left; } .col-lg-1 { width: 8.33333%; } .col-lg-2 { width: 16.66667%; } .col-lg-3 { width: 25%; } .col-lg-4 { width: 33.33333%; } .col-lg-5 { width: 41.66667%; } .col-lg-6 { width: 50%; } .col-lg-7 { width: 58.33333%; } .col-lg-8 { width: 66.66667%; } .col-lg-9 { width: 75%; } .col-lg-10 { width: 83.33333%; } .col-lg-11 { width: 91.66667%; } .col-lg-12 { width: 100%; } .col-lg-pull-0 { right: auto; } .col-lg-pull-1 { right: 8.33333%; } .col-lg-pull-2 { right: 16.66667%; } .col-lg-pull-3 { right: 25%; } .col-lg-pull-4 { right: 33.33333%; } .col-lg-pull-5 { right: 41.66667%; } .col-lg-pull-6 { right: 50%; } .col-lg-pull-7 { right: 58.33333%; } .col-lg-pull-8 { right: 66.66667%; } .col-lg-pull-9 { right: 75%; } .col-lg-pull-10 { right: 83.33333%; } .col-lg-pull-11 { right: 91.66667%; } .col-lg-pull-12 { right: 100%; } .col-lg-push-0 { left: auto; } .col-lg-push-1 { left: 8.33333%; } .col-lg-push-2 { left: 16.66667%; } .col-lg-push-3 { left: 25%; } .col-lg-push-4 { left: 33.33333%; } .col-lg-push-5 { left: 41.66667%; } .col-lg-push-6 { left: 50%; } .col-lg-push-7 { left: 58.33333%; } .col-lg-push-8 { left: 66.66667%; } .col-lg-push-9 { left: 75%; } .col-lg-push-10 { left: 83.33333%; } .col-lg-push-11 { left: 91.66667%; } .col-lg-push-12 { left: 100%; } .col-lg-offset-0 { margin-left: 0%; } .col-lg-offset-1 { margin-left: 8.33333%; } .col-lg-offset-2 { margin-left: 16.66667%; } .col-lg-offset-3 { margin-left: 25%; } .col-lg-offset-4 { margin-left: 33.33333%; } .col-lg-offset-5 { margin-left: 41.66667%; } .col-lg-offset-6 { margin-left: 50%; } .col-lg-offset-7 { margin-left: 58.33333%; } .col-lg-offset-8 { margin-left: 66.66667%; } .col-lg-offset-9 { margin-left: 75%; } .col-lg-offset-10 { margin-left: 83.33333%; } .col-lg-offset-11 { margin-left: 91.66667%; } .col-lg-offset-12 { margin-left: 100%; } .visible-lg { display: block !important; } table.visible-lg { display: table !important; } tr.visible-lg { display: table-row !important; } th.visible-lg, td.visible-lg { display: table-cell !important; } .visible-lg-block { display: block !important; } .visible-lg-inline { display: inline !important; } .visible-lg-inline-block { display: inline-block !important; } .hidden-lg { display: none !important; } .header { width: 16.66667%; } .sidebar { width: 23%; } .sidebar .slimContent { padding-right: 30px; padding-left: 30px; } .main { width: 60.33333%; padding-right: 30px; padding-left: 30px; } .footer { width: 16.66667%; } body.main-center .main { margin-left: 16.66667%; } body.main-left .sidebar { margin-right: 16.66667%; } body.main-right .sidebar { margin-left: 16.66667%; } body.main-right .main { margin-left: 39.66667%; } body.no-sidebar.main-left .main { width: 83.33333333%; margin-right: 16.66667%; } body.no-sidebar.main-right .main, body.no-sidebar.main-center .main { width: 83.33333333%; margin-left: 16.66667%; } .main-nav > li > a { padding: 10px 20px; } .bar.bar-footer:before { width: -webkit-calc(100% + 60px); width: calc(100% + 60px); left: -30px; } } @media (min-width: 1440px) { .header { width: 16.66667%; } .sidebar { width: 21%; } .main { width: 62.33333%; } .footer { width: 16.66667%; } body.main-center .main { margin-left: 16.66667%; } body.main-left .sidebar { margin-right: 16.66667%; } body.main-right .sidebar { margin-left: 16.66667%; } body.main-right .main { margin-left: 37.66667%; } body.no-sidebar.main-left .main { width: 83.33333333%; margin-right: 16.66667%; } body.no-sidebar.main-right .main, body.no-sidebar.main-center .main { width: 83.33333333%; margin-left: 16.66667%; } .header #title { font-size: 15px; } } @media (max-width: 1199px) { .main-nav > li > a { padding: 6px 20px; } .bar .pager li a span { display: none; } .footer .copyright { display: none; } } @media (max-width: 767px) { .navbar-nav .open .dropdown-menu { position: static; float: none; width: auto; margin-top: 0; background-color: transparent; border: 0; -webkit-box-shadow: none; box-shadow: none; } .navbar-nav .open .dropdown-menu > li > a, .navbar-nav .open .dropdown-menu .dropdown-header { padding: 5px 15px 5px 25px; } .navbar-nav .open .dropdown-menu > li > a { line-height: 21px; } .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-nav .open .dropdown-menu > li > a:focus { background-image: none; } .navbar-form .form-group { margin-bottom: 5px; } .navbar-form .form-group:last-child { margin-bottom: 0; } .navbar-default .navbar-nav .open .dropdown-menu > li > a { color: #777; } .navbar-default .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > li > a:focus { color: #333; background-color: transparent; } .navbar-default .navbar-nav .open .dropdown-menu > .active > a, .navbar-default .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > .active > a:focus { color: #555; background-color: #e7e7e7; } .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a, .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #ccc; background-color: transparent; } .navbar-inverse .navbar-nav .open .dropdown-menu > .dropdown-header { border-color: #090909; } .navbar-inverse .navbar-nav .open .dropdown-menu .divider { background-color: #090909; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a { color: #9d9d9d; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a, .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:focus { color: #fff; background-color: #090909; } .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a, .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #444; background-color: transparent; } .visible-xs { display: block !important; } table.visible-xs { display: table !important; } tr.visible-xs { display: table-row !important; } th.visible-xs, td.visible-xs { display: table-cell !important; } .visible-xs-block { display: block !important; } .visible-xs-inline { display: inline !important; } .visible-xs-inline-block { display: inline-block !important; } .hidden-xs { display: none !important; } body { padding-top: 53px; } .list-circle-num, .list-square-num { margin: 0 0 40px; } .modal-xs-full .modal-dialog, .modal-xs-full .modal-content { height: 100%; width: 100%; margin: 0; border-radius: 0; -webkit-box-shadow: none; box-shadow: none; } .modal-xs-full .modal-dialog .donate-box, .modal-xs-full .modal-content .donate-box { padding-top: 50px; } .highlight table:before { display: block; content: ' '; height: 38px; position: absolute; top: 0; left: 0; right: 0; margin-left: -10px; margin-right: -10px; margin-top: -38px; background-color: #f6f6f6; border-top-left-radius: 4px; border-top-right-radius: 4px; } .header { position: fixed; left: 0; right: 0; top: 0; width: 100%; z-index: 1050; } .header:before, .header:after { content: \" \"; display: table; } .header:after { clear: both; } .sidebar { display: none; } .main { min-height: auto; } .main-nav > li > a { padding: 10px 20px; } .sidebar-form { border: 0; margin: 9px 45px 9px 0; } .sidebar-form .input-group-btn .btn { color: #2196f3; } .sidebar-form input[type=\"text\"]:focus { background-color: transparent; } .sidebar-form input[type=\"text\"]:focus + .input-group-btn .btn { color: #2196f3; background-color: transparent; } .header .navbar-toggle { position: absolute; top: 0; right: 0; margin-right: 5px; } .header .navbar-toggle .icon-bar { width: 18px; } .header .search { width: 90%; float: right; } .header .profile-block { padding: 0; margin: 10px 0; width: 8.33333%; float: left; } .header #avatar { width: 32px; height: 32px; } .header #name, .header #title, .header #location { display: none; } #main-navbar { position: absolute; width: 100%; background-color: #fbfbfb; border-bottom: 1px solid #f6f6f6; z-index: 99; } .main .content { min-height: auto; } .sidebar-toc.in { position: fixed; top: 50px; bottom: 50px; z-index: 9; } .bar.bar-footer { top: auto !important; bottom: 0 !important; } .footer { display: none; position: static; } .footer .copyright { display: block; } .social-links .tooltip { display: none !important; visibility: hidden; } .theme-black .search input[type=\"text\"]:focus, .theme-blue .search input[type=\"text\"]:focus, .theme-green .search input[type=\"text\"]:focus, .theme-purple .search input[type=\"text\"]:focus { background-color: transparent; } .theme-black .search input[type=\"text\"]:focus + .input-group-btn .btn, .theme-blue .search input[type=\"text\"]:focus + .input-group-btn .btn, .theme-green .search input[type=\"text\"]:focus + .input-group-btn .btn, .theme-purple .search input[type=\"text\"]:focus + .input-group-btn .btn { color: rgba(255, 255, 255, 0.5); background-color: transparent; } .theme-black #main-navbar { background: #1a2433; background: -webkit-linear-gradient(left, #1a2433 0%, #253449 80%, #253449 100%); background: -webkit-gradient(linear, left top, right top, from(#1a2433), color-stop(80%, #253449), to(#253449)); background: linear-gradient(to right, #1a2433 0%, #253449 80%, #253449 100%); } .theme-blue #main-navbar { background: #0062c5; background: -webkit-linear-gradient(left, #0062c5 0%, #0073e6 80%, #0073e6 100%); background: -webkit-gradient(linear, left top, right top, from(#0062c5), color-stop(80%, #0073e6), to(#0073e6)); background: linear-gradient(to right, #0062c5 0%, #0073e6 80%, #0073e6 100%); } .theme-green #main-navbar { background: #08a283; background: -webkit-linear-gradient(left, #08a283 0%, #0ac29d 80%, #0ac29d 100%); background: -webkit-gradient(linear, left top, right top, from(#08a283), color-stop(80%, #0ac29d), to(#0ac29d)); background: linear-gradient(to right, #08a283 0%, #0ac29d 80%, #0ac29d 100%); } .theme-purple #main-navbar { background: #494683; background: -webkit-linear-gradient(left, #494683 0%, #555299 80%, #555299 100%); background: -webkit-gradient(linear, left top, right top, from(#494683), color-stop(80%, #555299), to(#555299)); background: linear-gradient(to right, #494683 0%, #555299 80%, #555299 100%); } } @media screen and (max-width: 559px),screen and (max-height: 479px) { .ins-search-container { top: 0; left: 0; margin: 0; width: 100%; height: 100%; background: #f7f7f7; } } @media (max-width: 480px) { .header #avatar { width: 24px; height: 24px; margin-top: 3px; margin-left: 15px; } } @media (min-width: 768px) and (max-width: 991px) { .visible-sm { display: block !important; } table.visible-sm { display: table !important; } tr.visible-sm { display: table-row !important; } th.visible-sm, td.visible-sm { display: table-cell !important; } .visible-sm-block { display: block !important; } .visible-sm-inline { display: inline !important; } .visible-sm-inline-block { display: inline-block !important; } .hidden-sm { display: none !important; } .sidebar-form { display: none; } .header .main-nav > li > a { text-align: center; padding-left: 0; padding-right: 0; } .header .main-nav > li > a span { display: none; } .header .profile-block { padding-top: 10px; padding-left: 0; padding-right: 0; } .header #avatar { width: 32px; height: 32px; } .footer { padding-left: 0; padding-right: 0; } .social-links { display: block; width: 100%; text-align: center; margin-bottom: 0; } .social-links:before, .social-links:after { content: \" \"; display: table; } .social-links:after { clear: both; } .social-links li { display: block; margin-left: 0; margin-top: 10px; } .social-links li:before, .social-links li:after { content: \" \"; display: table; } .social-links li:after { clear: both; } .social-links .tooltip { display: none !important; visibility: hidden; } } @media (min-width: 992px) and (max-width: 1199px) { .visible-md { display: block !important; } table.visible-md { display: table !important; } tr.visible-md { display: table-row !important; } th.visible-md, td.visible-md { display: table-cell !important; } .visible-md-block { display: block !important; } .visible-md-inline { display: inline !important; } .visible-md-inline-block { display: inline-block !important; } .hidden-md { display: none !important; } } @media print { *, *:before, *:after { background: transparent !important; color: #000 !important; -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; } a, a:visited { text-decoration: underline; } a[href]:after { content: \" (\" attr(href) \")\"; } abbr[title]:after { content: \" (\" attr(title) \")\"; } a[href^=\"#\"]:after, a[href^=\"javascript:\"]:after { content: \"\"; } pre, blockquote { border: 1px solid #999; page-break-inside: avoid; } thead { display: table-header-group; } tr, img { page-break-inside: avoid; } img { max-width: 100% !important; } p, h2, h3 { orphans: 3; widows: 3; } h2, h3 { page-break-after: avoid; } .navbar { display: none; } .btn > .caret, .dropup > .btn > .caret { border-top-color: #000 !important; } .label { border: 1px solid #000; } .table { border-collapse: collapse !important; } .table td, .table th { background-color: #fff !important; } .table-bordered th, .table-bordered td { border: 1px solid #ddd !important; } .visible-print { display: block !important; } table.visible-print { display: table !important; } tr.visible-print { display: table-row !important; } th.visible-print, td.visible-print { display: table-cell !important; } .visible-print-block { display: block !important; } .visible-print-inline { display: inline !important; } .visible-print-inline-block { display: inline-block !important; } .hidden-print { display: none !important; } } @media (max-device-width: 480px) and (orientation: landscape) { .navbar-fixed-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { max-height: 200px; } }"},{"title":"","date":"2022-06-24T17:19:04.512Z","updated":"2022-06-24T17:19:04.512Z","comments":true,"path":"js/application.min.js","permalink":"http://fyupeng.github.io/js/application.min.js","excerpt":"","text":"$(function(){$('[data-toggle=\"tooltip\"]').tooltip(),\"undefined\"!=typeof $.fn.slimScroll&&$(\".sidebar .slimContent\").slimScroll({height:$(window).height(),color:\"rgba(0,0,0,0.15)\",size:\"5px\",position:\"right\"}),$(\"#collapseToc\").on(\"shown.bs.collapse\",function(){\"undefined\"!=typeof $.fn.slimScroll&&$(\".sidebar .slimContent\").slimScroll().on(\"slimscroll\")}),$(\".geopattern\").each(function(){$(this).geopattern($(this).data(\"pattern-id\"))});$(\"#nav-main\").okayNav({swipe_enabled:!1});$(\"[data-stick-bottom]\").keepInView({fixed:!1,parentClass:\"has-sticky\",customClass:\"sticky\",trigger:\"bottom\",zindex:42,edgeOffset:0}),$(\"[data-stick-top]\").keepInView({fixed:!0,parentClass:\"has-sticky\",customClass:\"sticky\",trigger:\"top\",zindex:42,edgeOffset:0});var t=$(\"ul.main-nav\").hasClass(\"menu-highlight\");if(t){for(var e=location.pathname,i=$(\"ul.main-nav>li\"),a=-1,s=0,n=i.length;s-1||\"/\"===e&&(\"/.\"===o||\"/\"===o||\"index.html\"===o||\"/index.html\"===o))&&(a=s),$(i[s]).removeClass(\"active\")}i[a]&&$(i[a]).addClass(\"active\")}});"},{"title":"","date":"2022-06-24T17:19:04.496Z","updated":"2022-06-24T17:19:04.496Z","comments":true,"path":"css/style.min.css","permalink":"http://fyupeng.github.io/css/style.min.css","excerpt":"","text":"@charset \"UTF-8\";/*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}b,optgroup,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0}mark{background:#ff0;color:#000}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0;vertical-align:middle}svg:not(:root){overflow:hidden}hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}textarea{overflow:auto}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */*,:after,:before{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:transparent}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a:focus{outline:-webkit-focus-ring-color auto 5px;outline-offset:-2px}figure{margin:0}.img-responsive{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{padding:4px;line-height:1.57143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;display:inline-block;max-width:100%;height:auto}.img-circle{border-radius:50%}hr{margin-top:21px;margin-bottom:21px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:21px;margin-bottom:10.5px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10.5px;margin-bottom:10.5px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:30px}.h2,h2{font-size:26px}.h3,h3{font-size:22px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10.5px}.lead{margin-bottom:21px;font-size:16px;font-weight:300;line-height:1.4}.small,small{font-size:85%}.mark,mark{background-color:#fcf8e3;padding:.2em}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-lowercase{text-transform:lowercase}.initialism,.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777!important}.text-primary{color:#2196f3}a.text-primary:focus,a.text-primary:hover{color:#0c7cd5}.text-success{color:#3c763d}a.text-success:focus,a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:focus,a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:focus,a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:focus,a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#2196f3}a.bg-primary:focus,a.bg-primary:hover{background-color:#0c7cd5}.bg-success{background-color:#dff0d8}a.bg-success:focus,a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:focus,a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:focus,a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:focus,a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9.5px;margin:42px 0 21px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10.5px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;list-style:none;margin-left:-5px}.list-inline>li{display:inline-block;padding-left:5px;padding-right:5px}dl{margin-top:0;margin-bottom:21px}dd,dt{line-height:1.57143}dt{font-weight:700}dd{margin-left:0}.dl-horizontal dd:after,.dl-horizontal dd:before{content:\" \";display:table}.dl-horizontal dd:after{clear:both}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%}blockquote{padding:10.5px 16px;margin:0 0 21px;border:1px dotted #eee;border-left:3px solid #eee;background-color:#fbfbfb}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.57143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0;text-align:right}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:21px;font-style:normal;line-height:1.57143}.container{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}.container:after,.container:before{content:\" \";display:table}.container:after{clear:both}.container-fluid{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}.container-fluid:after,.container-fluid:before{content:\" \";display:table}.container-fluid:after{clear:both}.row{margin-left:-15px;margin-right:-15px}.row:after,.row:before{content:\" \";display:table}.row:after{clear:both}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-left:15px;padding-right:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-1{width:8.33333%}.col-xs-2{width:16.66667%}.col-xs-3{width:25%}.col-xs-4{width:33.33333%}.col-xs-5{width:41.66667%}.col-xs-6{width:50%}.col-xs-7{width:58.33333%}.col-xs-8{width:66.66667%}.col-xs-9{width:75%}.col-xs-10{width:83.33333%}.col-xs-11{width:91.66667%}.col-xs-12{width:100%}.col-xs-pull-0{right:auto}.col-xs-pull-1{right:8.33333%}.col-xs-pull-2{right:16.66667%}.col-xs-pull-3{right:25%}.col-xs-pull-4{right:33.33333%}.col-xs-pull-5{right:41.66667%}.col-xs-pull-6{right:50%}.col-xs-pull-7{right:58.33333%}.col-xs-pull-8{right:66.66667%}.col-xs-pull-9{right:75%}.col-xs-pull-10{right:83.33333%}.col-xs-pull-11{right:91.66667%}.col-xs-pull-12{right:100%}.col-xs-push-0{left:auto}.col-xs-push-1{left:8.33333%}.col-xs-push-2{left:16.66667%}.col-xs-push-3{left:25%}.col-xs-push-4{left:33.33333%}.col-xs-push-5{left:41.66667%}.col-xs-push-6{left:50%}.col-xs-push-7{left:58.33333%}.col-xs-push-8{left:66.66667%}.col-xs-push-9{left:75%}.col-xs-push-10{left:83.33333%}.col-xs-push-11{left:91.66667%}.col-xs-push-12{left:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333%}.col-xs-offset-2{margin-left:16.66667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333%}.col-xs-offset-5{margin-left:41.66667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333%}.col-xs-offset-8{margin-left:66.66667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333%}.col-xs-offset-11{margin-left:91.66667%}.col-xs-offset-12{margin-left:100%}.btn{display:inline-block;margin-bottom:0;font-weight:400;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;padding:6px 12px;font-size:14px;line-height:1.57143;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:-webkit-focus-ring-color auto 5px;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{outline:0;background-image:none;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default:hover{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.btn-default.dropdown-toggle{color:#333;background-color:#e6e6e6;border-color:#adadad;background-image:none}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.btn-default.dropdown-toggle.focus,.open>.btn-default.dropdown-toggle:focus,.open>.btn-default.dropdown-toggle:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.disabled.focus,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled].focus,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#2196f3;border-color:#0d8aee}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#0c7cd5;border-color:#064475}.btn-primary:hover{color:#fff;background-color:#0c7cd5;border-color:#0a68b4}.btn-primary.active,.btn-primary:active,.open>.btn-primary.dropdown-toggle{color:#fff;background-color:#0c7cd5;border-color:#0a68b4;background-image:none}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.btn-primary.dropdown-toggle.focus,.open>.btn-primary.dropdown-toggle:focus,.open>.btn-primary.dropdown-toggle:hover{color:#fff;background-color:#0a68b4;border-color:#064475}.btn-primary.disabled.focus,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled].focus,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#2196f3;border-color:#0d8aee}.btn-primary .badge{color:#2196f3;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success:hover{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.btn-success.dropdown-toggle{color:#fff;background-color:#449d44;border-color:#398439;background-image:none}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.btn-success.dropdown-toggle.focus,.open>.btn-success.dropdown-toggle:focus,.open>.btn-success.dropdown-toggle:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.disabled.focus,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled].focus,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#56ccf2;border-color:#3ec5f0}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#27beee;border-color:#0d7ea3}.btn-info:hover{color:#fff;background-color:#27beee;border-color:#11aee0}.btn-info.active,.btn-info:active,.open>.btn-info.dropdown-toggle{color:#fff;background-color:#27beee;border-color:#11aee0;background-image:none}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.btn-info.dropdown-toggle.focus,.open>.btn-info.dropdown-toggle:focus,.open>.btn-info.dropdown-toggle:hover{color:#fff;background-color:#11aee0;border-color:#0d7ea3}.btn-info.disabled.focus,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled].focus,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#56ccf2;border-color:#3ec5f0}.btn-info .badge{color:#56ccf2;background-color:#fff}.btn-warning{color:#fff;background-color:#f09819;border-color:#e18b0f}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#c97c0d;border-color:#694107}.btn-warning:hover{color:#fff;background-color:#c97c0d;border-color:#a7670b}.btn-warning.active,.btn-warning:active,.open>.btn-warning.dropdown-toggle{color:#fff;background-color:#c97c0d;border-color:#a7670b;background-image:none}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.btn-warning.dropdown-toggle.focus,.open>.btn-warning.dropdown-toggle:focus,.open>.btn-warning.dropdown-toggle:hover{color:#fff;background-color:#a7670b;border-color:#694107}.btn-warning.disabled.focus,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled].focus,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f09819;border-color:#e18b0f}.btn-warning .badge{color:#f09819;background-color:#fff}.btn-danger{color:#fff;background-color:#ff512f;border-color:#ff3c16}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#fb2900;border-color:#951800}.btn-danger:hover{color:#fff;background-color:#fb2900;border-color:#d72300}.btn-danger.active,.btn-danger:active,.open>.btn-danger.dropdown-toggle{color:#fff;background-color:#fb2900;border-color:#d72300;background-image:none}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.btn-danger.dropdown-toggle.focus,.open>.btn-danger.dropdown-toggle:focus,.open>.btn-danger.dropdown-toggle:hover{color:#fff;background-color:#d72300;border-color:#951800}.btn-danger.disabled.focus,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled].focus,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#ff512f;border-color:#ff3c16}.btn-danger .badge{color:#ff512f;background-color:#fff}.btn-link{color:#2196f3;font-weight:400;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#0a6ebd;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-lg{padding:10px 16px;font-size:18px;line-height:1.33333;border-radius:6px}.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-property:height,visibility;transition-property:height,visibility;-webkit-transition-duration:.35s;transition-duration:.35s;-webkit-transition-timing-function:ease;transition-timing-function:ease}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;font-size:14px;text-align:left;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175);background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9.5px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.57143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{text-decoration:none;color:#262626;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;outline:0;background-color:#2196f3}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);cursor:not-allowed}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{left:auto;right:0}.dropdown-menu-left{left:0;right:auto}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.57143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;left:0;right:0;bottom:0;top:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\9;content:\"\"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-left:0;padding-right:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group .form-control:focus{z-index:3}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.input-group-addon.btn{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.input-group-addon.btn{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-top-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-bottom-left-radius:0;border-top-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{z-index:2;margin-left:-1px}.nav{margin-bottom:0;padding-left:0;list-style:none}.nav:after,.nav:before{content:\" \";display:table}.nav:after{clear:both}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;background-color:transparent;cursor:not-allowed}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#2196f3}.nav .nav-divider{height:1px;margin:9.5px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #f2f2f2}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.57143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #f2f2f2}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;background-color:#fff;border:1px solid #f2f2f2;border-bottom-color:transparent;cursor:default}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#2196f3}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified,.nav-tabs.nav-justified{width:100%}.nav-justified>li,.nav-tabs.nav-justified>li{float:none}.nav-justified>li>a,.nav-tabs.nav-justified>li>a{text-align:center;margin-bottom:5px}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}.nav-tabs-justified,.nav-tabs.nav-justified{border-bottom:0}.nav-tabs-justified>li>a,.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover,.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #f2f2f2}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-right-radius:0;border-top-left-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:21px;border:1px solid transparent}.navbar:after,.navbar:before{content:\" \";display:table}.navbar:after{clear:both}.navbar-header:after,.navbar-header:before{content:\" \";display:table}.navbar-header:after{clear:both}.navbar-collapse{overflow-x:visible;padding-right:15px;padding-left:15px;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1);-webkit-overflow-scrolling:touch}.navbar-collapse:after,.navbar-collapse:before{content:\" \";display:table}.navbar-collapse:after{clear:both}.navbar-collapse.in{overflow-y:auto}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}.navbar-static-top{z-index:1000;border-width:0 0 1px}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;padding:14.5px 15px;font-size:18px;line-height:21px;height:50px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}.navbar-toggle{position:relative;float:right;margin-right:15px;padding:10px;margin-top:8px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:3px}.navbar-nav{margin:7.25px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:21px}.navbar-form{padding:10px 15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);margin:7.5px -15px}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-right-radius:0;border-top-left-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-radius:4px 4px 0 0}.navbar-btn{margin-top:7.5px;margin-bottom:7.5px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:14.5px;margin-bottom:14.5px}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-nav>li>a,.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{background-color:#e7e7e7;color:#555}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#090909}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>li>a,.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#090909}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{background-color:#090909;color:#fff}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.pager{padding-left:0;margin:21px 0;list-style:none;text-align:center}.pager:after,.pager:before{content:\" \";display:table}.pager:after{clear:both}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;background-color:#fff;cursor:not-allowed}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;color:#fff;line-height:1;vertical-align:middle;white-space:nowrap;text-align:center;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#2196f3;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.thumbnail{display:block;padding:4px;margin-bottom:21px;line-height:1.57143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto;margin-left:auto;margin-right:auto}.thumbnail .caption{padding:9px;color:#333}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#2196f3}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{zoom:1;overflow:hidden}.media-body{width:10000px}.media-object{display:block}.media-object.img-thumbnail{max-width:none}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle,.media-middle .media-body,.media-middle .media-left,.media-middle .media-right{vertical-align:middle}.media-bottom,.media-bottom .media-body,.media-bottom .media-left,.media-bottom .media-right{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;left:0;bottom:0;height:100%;width:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:24px;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;opacity:.5;filter:alpha(opacity=50)}button.close{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none}.modal-open{overflow:hidden}.modal{display:none;overflow:hidden;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);transform:translate(0,-25%);-webkit-transition:-webkit-transform .3s ease-out;transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border-radius:6px;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.05);box-shadow:0 3px 9px rgba(0,0,0,.05);background-clip:padding-box;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0;filter:alpha(opacity=0)}.modal-backdrop.in{opacity:.5;filter:alpha(opacity=50)}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5}.modal-header:after,.modal-header:before{content:\" \";display:table}.modal-header:after{clear:both}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.57143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer:after,.modal-footer:before{content:\" \";display:table}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.tooltip{position:absolute;z-index:1070;display:block;font-family:PingHei,\"PingFang SC\",Helvetica Neue,\"Work Sans\",\"Hiragino Sans GB\",\"Microsoft YaHei\",SimSun,sans-serif;font-style:normal;font-weight:400;letter-spacing:normal;line-break:auto;line-height:1.57143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;white-space:normal;word-break:normal;word-spacing:normal;word-wrap:normal;font-size:12px;opacity:0;filter:alpha(opacity=0)}.tooltip.in{opacity:.9;filter:alpha(opacity=90)}.tooltip.top{margin-top:-3px;padding:5px 0}.tooltip.right{margin-left:3px;padding:0 5px}.tooltip.bottom{margin-top:3px;padding:5px 0}.tooltip.left{margin-left:-3px;padding:0 5px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{bottom:0;right:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-print,.visible-print-block,.visible-print-inline,.visible-print-inline-block,.visible-sm,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}/*! * IE10 viewport hack for Surface/desktop Windows 8 bug * Copyright 2014-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */@-o-viewport{width:device-width}@viewport{width:device-width}::-webkit-scrollbar{width:6px;height:4px;background:0 0}::-webkit-scrollbar-thumb{background:rgba(0,0,0,.15)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(0,0,0,.1)}::-webkit-scrollbar-thumb:vertical{height:4px;background:rgba(0,0,0,.15)}::-webkit-scrollbar-thumb:horizontal{width:4px;background:rgba(0,0,0,.15)}::-webkit-scrollbar-thumb:vertical:hover{background-color:rgba(0,0,0,.3)}::-webkit-scrollbar-thumb:vertical:active{background-color:rgba(0,0,0,.5)}::-webkit-scrollbar-track{background:rgba(0,0,0,.1);-webkit-box-shadow:inset 0 0 3px rgba(0,0,0,.1);box-shadow:inset 0 0 3px rgba(0,0,0,.1)}::-webkit-scrollbar-track-piece{background:rgba(0,0,0,.15)}body,html{position:relative;overflow-x:hidden}body{padding-right:0!important;font-family:PingHei,\"PingFang SC\",Helvetica Neue,\"Work Sans\",\"Hiragino Sans GB\",\"Microsoft YaHei\",SimSun,sans-serif;font-size:14px;line-height:1.57143;color:#333;background-color:#fff}a{color:#333;text-decoration:none}a:focus,a:hover{color:#0a6ebd;text-decoration:none}.active>a,a.active{color:#0a6ebd}.btn,button,input,select,textarea{outline:0!important}.btn:active,.btn:focus,.btn:hover,button:active,button:focus,button:hover,input:active,input:focus,input:hover,select:active,select:focus,select:hover,textarea:active,textarea:focus,textarea:hover{outline:0!important}canvas,iframe,img,svg,video{max-width:100%;height:auto}.clear{height:0;font-size:0;line-height:0;overflow:hidden;clear:both}.clearfix:after,.clearfix:before{content:\" \";display:table;line-height:0;content:\"\"}.clearfix:after{clear:both}.clearfix{*zoom:1}.clickable{cursor:pointer}.scrollable{overflow-x:hidden;overflow-y:auto}.transform-no{-ms-transform:none!important;-webkit-transform:none!important;transform:none!important}.text-dark{color:#333!important}.text-grey{color:#999!important}.text-white{color:#fff!important}.text-white a:hover,.text-white a:hover i,.text-white:hover{color:rgba(255,255,255,.8)}.text-white a.list-group-item.active i{color:#fff}.text-white .accordion-list p{font-size:12px;height:84px;line-height:21px;color:rgba(255,255,255,.8)}.bg-no{background:0 0!important}.bg-alpha{background-color:transparent!important}.bg-inverse,.bg-inverse a{color:#fff}.btn.bg-inverse.focus,.btn.bg-inverse:focus,.btn.bg-inverse:hover{color:rgba(255,255,255,.8)}.bg{background-color:#f6f6f6!important}.z-no{z-index:inherit}.z1{z-index:1}.z2{z-index:2}.z3{z-index:3}.z4{z-index:4}.zmin{z-index:-1}.zmax{z-index:999}.m{margin:5px!important}.m-no{margin:0!important}.m-0x{margin:10px!important}.m-1x{margin:15px!important}.m-2x{margin:20px!important}.m-3x{margin:30px!important}.m-4x{margin:60px!important}.m-5x{margin:100px!important}.mv{margin-top:5px!important;margin-bottom:5px!important}.mv-no{margin-top:0!important;margin-bottom:0!important}.mv-0x{margin-top:10px!important;margin-bottom:10px!important}.mv-1x{margin-top:15px!important;margin-bottom:15px!important}.mv-2x{margin-top:20px!important;margin-bottom:20px!important}.mv-3x{margin-top:30px!important;margin-bottom:30px!important}.mv-4x{margin-top:60px!important;margin-bottom:60px!important}.mv-5x{margin-top:100px!important;margin-bottom:100px!important}.mh{margin-left:5px!important;margin-right:5px!important}.mh-no{margin-left:0!important;margin-right:0!important}.mh-0x{margin-left:10px!important;margin-right:10px!important}.mh-1x{margin-left:15px!important;margin-right:15px!important}.mh-2x{margin-left:20px!important;margin-right:20px!important}.mh-3x{margin-left:30px!important;margin-right:30px!important}.mh-4x{margin-left:60px!important;margin-right:60px!important}.mh-5x{margin-left:100px!important;margin-right:100px!important}.mt{margin-top:5px!important}.mt-no{margin-top:0!important}.mt-0x{margin-top:10px!important}.mt-1x{margin-top:15px!important}.mt-2x{margin-top:20px!important}.mt-3x{margin-top:30px!important}.mt-4x{margin-top:60px!important}.mt-5x{margin-top:100px!important}.mb{margin-bottom:5px!important}.mb-no{margin-bottom:0!important}.mb-0x{margin-bottom:10px!important}.mb-1x{margin-bottom:15px!important}.mb-2x{margin-bottom:20px!important}.mb-3x{margin-bottom:30px!important}.mb-4x{margin-bottom:60px!important}.mb-5x{margin-bottom:100px!important}.ml{margin-left:5px!important}.ml-no{margin-left:0!important}.ml-0x{margin-left:10px!important}.ml-1x{margin-left:15px!important}.ml-2x{margin-left:20px!important}.ml-3x{margin-left:30px!important}.ml-4x{margin-left:60px!important}.ml-5x{margin-left:100px!important}.mr{margin-right:5px!important}.mr-no{margin-right:0!important}.mr-0x{margin-right:10px!important}.mr-1x{margin-right:15px!important}.mr-2x{margin-right:20px!important}.mr-3x{margin-right:30px!important}.mr-4x{margin-right:60px!important}.mr-5x{margin-right:100px!important}.p{padding:5px!important}.p-no{padding:0!important}.p-0x{padding:10px!important}.p-1x{padding:15px!important}.p-2x{padding:20px!important}.p-3x{padding:30px!important}.p-4x{padding:60px!important}.p-5x{padding:100px!important}.pv{padding-top:5px!important;padding-bottom:5px!important}.pv-no{padding-top:0!important;padding-bottom:0!important}.pv-0x{padding-top:10px!important;padding-bottom:10px!important}.pv-1x{padding-top:15px!important;padding-bottom:15px!important}.pv-2x{padding-top:20px!important;padding-bottom:20px!important}.pv-3x{padding-top:30px!important;padding-bottom:30px!important}.pv-4x{padding-top:60px!important;padding-bottom:60px!important}.pv-5x{padding-top:100px!important;padding-bottom:100px!important}.ph{padding-left:5px!important;padding-right:5px!important}.ph-no{padding-left:0!important;padding-right:0!important}.ph-0x{padding-left:10px!important;padding-right:10px!important}.ph-1x{padding-left:15px!important;padding-right:15px!important}.ph-2x{padding-left:20px!important;padding-right:20px!important}.ph-3x{padding-left:30px!important;padding-right:30px!important}.ph-4x{padding-left:60px!important;padding-right:60px!important}.ph-5x{padding-left:100px!important;padding-right:100px!important}.pt{padding-top:5px!important}.pt-no{padding-top:0!important}.pt-0x{padding-top:10px!important}.pt-1x{padding-top:15px!important}.pt-2x{padding-top:20px!important}.pt-3x{padding-top:30px!important}.pt-4x{padding-top:60px!important}.pt-5x{padding-top:100px!important}.pb{padding-bottom:5px!important}.pb-no{padding-bottom:0!important}.pb-0x{padding-bottom:10px!important}.pb-1x{padding-bottom:15px!important}.pb-2x{padding-bottom:20px!important}.pb-3x{padding-bottom:30px!important}.pb-4x{padding-bottom:60px!important}.pb-5x{padding-bottom:100px!important}.pl{padding-left:5px!important}.pl-no{padding-left:0!important}.pl-0x{padding-left:10px!important}.pl-1x{padding-left:15px!important}.pl-2x{padding-left:20px!important}.pl-3x{padding-left:30px!important}.pl-4x{padding-left:60px!important}.pl-5x{padding-left:100px!important}.pr{padding-right:5px!important}.pr-no{padding-right:0!important}.pr-0x{padding-right:10px!important}.pr-1x{padding-right:15px!important}.pr-2x{padding-right:20px!important}.pr-3x{padding-right:30px!important}.pr-4x{padding-right:60px!important}.pr-5x{padding-right:100px!important}.b{border:1px solid #ddd}.b-no{border:none!important}.r-rounded{border-radius:2em!important;padding-left:1em;padding-right:1em;overflow:hidden}.r-circle{border-radius:50%!important;overflow:hidden}.r-no{border-radius:0!important}.w-auto{width:auto!important}.w-full,.w-full img{width:100%!important;max-width:100%!important}.lh-2x{line-height:2}.text-break{word-break:break-all!important;word-wrap:break-word!important}.text-undecorate{text-decoration:none!important}.text-underline{text-decoration:underline!important}.text-through{text-decoration:line-through!important}.text-sub{vertical-align:sub!important}.text-super{vertical-align:super!important}.text-indent,.text-indent div,.text-indent p{text-indent:2em}.text-nowrap{max-width:100%;overflow:hidden!important;text-overflow:ellipsis!important;white-space:nowrap!important;word-wrap:normal!important;-moz-binding:url(ellipsis.xml)}.text-nowrap-1x{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:1;-webkit-box-flex:1;line-height:24px;height:24px;word-break:break-all!important;word-wrap:break-word!important}.text-nowrap-2x{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:2;line-height:24px;height:48px;word-break:break-all!important;word-wrap:break-word!important}.text-nowrap-3x{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:3;line-height:24px;height:72px;word-break:break-all!important;word-wrap:break-word!important}.text-nowrap-4x{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:4;line-height:24px;height:96px;word-break:break-all!important;word-wrap:break-word!important}.text-nowrap-5x{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:5;line-height:24px;height:120px;word-break:break-all!important;word-wrap:break-word!important}.thumb{width:16px;display:inline-block;overflow:hidden}.thumb-xs{width:32px;display:inline-block;overflow:hidden}.thumb-sm{width:48px;display:inline-block;overflow:hidden}.thumb-md{width:64px;display:inline-block;overflow:hidden}.thumb-lg{width:96px;display:inline-block;overflow:hidden}.thumb-xl{width:128px;display:inline-block;overflow:hidden}.thumb-wrapper{padding:2px;border:1px solid #dbe2e7}.thumb img,.thumb-0x img,.thumb-1x img,.thumb-2x img,.thumb-3x img,.thumb-4x img,.thumb-5x img,.thumb-6x img,.thumb-btn img{height:auto;max-width:100%;vertical-align:middle}.img-gray img,img.img-gray{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%);-webkit-filter:gray;filter:gray}.img-gray:hover img,img.img-gray:hover{-webkit-filter:grayscale(0);-moz-filter:grayscale(0);-ms-filter:grayscale(0);-o-filter:grayscale(0);filter:grayscale(0)}.img-rotate img,img.img-rotate{-webkit-transition:-webkit-transform .3s ease;transition:-webkit-transform .3s ease;transition:transform .3s ease;transition:transform .3s ease,-webkit-transform .3s ease}.img-rotate:hover img,img.img-rotate:hover{transform:rotate(360deg);-ms-transform:rotate(360deg);-moz-transform:rotate(360deg);-webkit-transform:rotate(360deg);-o-transform:rotate(360deg)}.img-burn img,img.img-burn{position:relative;-webkit-transition:all .8s ease-in-out;transition:all .8s ease-in-out}.img-burn:hover img,img.img-burn:hover{-webkit-transform:scale(1.2) rotate(2deg);-ms-transform:scale(1.2) rotate(2deg);transform:scale(1.2) rotate(2deg)}.hover-up img,img.hover-up{position:relative;top:0;-webkit-transition:top .3s ease-out;transition:top .3s ease-out}.hover-up:hover img,img.hover-up:hover{top:-6px}.active>.auto .text,.active>.text,.collapsed>.auto .text,.collapsed>.text,.text-active{display:none!important}.active>.auto .text-active,.active>.text-active,.collapsed>.auto .text-active,.collapsed>.text-active{display:inline-block!important}.shadow-no{-webkit-box-shadow:none;box-shadow:none}.hover-shadow:hover,.shadow{-webkit-box-shadow:0 1px 2px rgba(0,0,0,.05);box-shadow:0 1px 2px rgba(0,0,0,.05)}.radio{margin-left:20px}.radio label{display:inline-block;position:relative;padding-left:5px}.radio label:before{content:\"\";display:inline-block;position:absolute;width:17px;height:17px;left:0;margin-left:-20px;border:1px solid #ccc;border-radius:50%;background-color:#fff;-webkit-transition:border .15s ease-in-out;transition:border .15s ease-in-out}.radio label:after{display:inline-block;position:absolute;content:\" \";width:11px;height:11px;left:3px;top:3px;margin-left:-20px;border-radius:50%;background-color:#555;-webkit-transform:scale(0,0);-ms-transform:scale(0,0);transform:scale(0,0);-webkit-transition:-webkit-transform .1s cubic-bezier(.8,-.33,.2,1.33);transition:-webkit-transform .1s cubic-bezier(.8,-.33,.2,1.33);transition:transform .1s cubic-bezier(.8,-.33,.2,1.33);transition:transform .1s cubic-bezier(.8,-.33,.2,1.33),-webkit-transform .1s cubic-bezier(.8,-.33,.2,1.33)}.radio input[type=radio]{display:none}.radio input[type=radio]:checked+label:after{-webkit-transform:scale(1,1);-ms-transform:scale(1,1);transform:scale(1,1)}.radio input[type=radio]:disabled+label{opacity:.65}.radio input[type=radio]:disabled+label:before{cursor:not-allowed}.hover-grow{-webkit-transition:all .2s linear;transition:all .2s linear}.hover-grow:hover{-webkit-transform:translate3d(0,-2px,0);transform:translate3d(0,-2px,0)}fieldset{padding:0;margin:0;border:0;min-width:0}legend{display:block;width:100%;padding:0;margin-bottom:21px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none}input[type=checkbox],input[type=radio]{margin:4px 0 0;margin-top:1px\\9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=checkbox]:focus,input[type=file]:focus,input[type=radio]:focus{outline:-webkit-focus-ring-color auto 5px;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.57143;color:#555}.form-control{display:block;width:100%;height:35px;padding:6px 12px;font-size:14px;line-height:1.57143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s,-webkit-box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control::-ms-expand{border:0;background-color:transparent}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}.list-disc{list-style:disc!important}.list-alpha{list-style:upper-alpha!important}.list-decimal{list-style:decimal!important}.list-outside{list-style-position:outside!important}.list-inside{list-style-position:inside!important}.list-square{list-style:none}.list-square li:before{color:#ccc;content:\"▪\";font-size:12px;margin-right:6px;-webkit-transition:.2s ease;transition:.2s ease}.list-circle-num,.list-square-num{counter-reset:list1}.list-circle-num>li,.list-square-num>li{list-style:none;margin-bottom:13px}.list-circle-num>li:before{counter-increment:list1;content:counter(list1) \"\";width:24px;height:24px;text-align:center;border-radius:12px;font-size:15px;border-width:1px;border-style:solid;margin:0 16px 0 0;display:inline-block;vertical-align:middle}.list-square-num>li:before{counter-increment:list1;content:counter(list1) \"\";width:24px;height:24px;text-align:center;border-radius:5px;font-size:15px;border-width:1px;border-style:solid;margin:0 16px 0 0;display:inline-block;vertical-align:middle}.list-circle-num>li>ol,.list-square-num>li>ol{counter-reset:list2}.list-circle-num>li>ol>li,.list-square-num>li>ol>li{margin-bottom:13px}.list-circle-num>li>ol>li:before{counter-increment:list2;content:counter(list1) \".\" counter(list2) \"\";width:24px;height:24px;text-align:center;border-radius:12px;font-size:15px;border-width:1px;border-style:solid;margin:0 16px 0 0;display:inline-block;vertical-align:middle}.list-square-num>li>ol>li:before{counter-increment:list2;content:counter(list1) \".\" counter(list2) \"\";width:24px;height:24px;text-align:center;border-radius:5px;font-size:15px;border-width:1px;border-style:solid;margin:0 16px 0 0;display:inline-block;vertical-align:middle}.list-circle-num[class*=list-full]>li::before,.list-square-num[class*=list-full]>li::before{background:#de4a32;color:#fff}.label{display:inline-block;padding:.3em .6em;font-size:75%;font-weight:700;line-height:1;color:#777;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}.label:empty{display:none}.btn .label{position:relative;top:-1px}a.label:focus,a.label:hover{color:#333;text-decoration:none;cursor:pointer}.label-default{background-color:#eee}.label-default[href]:focus,.label-default[href]:hover{background-color:#d5d5d5}.label-primary{background-color:#2196f3;color:#fff}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#0c7cd5}.label-success{background-color:#5cb85c;color:#fff}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#56ccf2;color:#fff}.label-info[href]:focus,.label-info[href]:hover{background-color:#27beee}.label-warning{background-color:#f09819;color:#fff}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#c97c0d}.label-danger{background-color:#ff512f;color:#fff}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#fb2900}.panel{margin-bottom:21px;background-color:#fff;border:1px solid #f2f2f2}.panel .article-title{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:2;font-size:18px;line-height:32px;height:64px;word-break:break-all!important;word-wrap:break-word!important}.panel-body{padding:15px}.panel-body:after,.panel-body:before{content:\" \";display:table}.panel-body:after{clear:both}.panel-heading{padding:10px 15px;border-bottom:1px solid #f2f2f2}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit;text-decoration:none}.panel-footer{padding:10px 15px;border-top:1px solid #f2f2f2;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel.b-no{border:0;margin-bottom:0}.panel.b-no .panel-body,.panel.b-no .panel-footer,.panel.b-no .panel-heading{border:0;padding-left:0;padding-right:0}.panel-badger{position:relative}.panel-badger:after{content:\"\";position:absolute;top:0;width:0;height:0;border-width:4px;border-style:solid;border-color:#777 transparent transparent #777}.panel-badger:hover:after{border-color:#2196f3 transparent transparent #2196f3}.badger-danger:after{border-color:#ff512f transparent transparent #ff512f}.badger-warning:after{border-color:#f09819 transparent transparent #f09819}.badger-success:after{border-color:#5cb85c transparent transparent #5cb85c}.badger-info:after{border-color:#56ccf2 transparent transparent #56ccf2}.badger-primary:after{border-color:#2196f3 transparent transparent #2196f3}.bg-gradient-info span,.bg-gradient-info:before{background:#56ccf2;background:-webkit-linear-gradient(left,#56ccf2 0,#2f80ed 80%,#2f80ed 100%);background:-webkit-gradient(linear,left top,right top,from(#56ccf2),color-stop(80%,#2f80ed),to(#2f80ed));background:linear-gradient(to right,#56ccf2 0,#2f80ed 80%,#2f80ed 100%)}.bg-gradient-primary span,.bg-gradient-primary:before{background:#396afc;background:-webkit-linear-gradient(left,#396afc 0,#2948ff 80%,#2948ff 100%);background:-webkit-gradient(linear,left top,right top,from(#396afc),color-stop(80%,#2948ff),to(#2948ff));background:linear-gradient(to right,#396afc 0,#2948ff 80%,#2948ff 100%)}.bg-gradient-success span,.bg-gradient-success:before{background:#44ea76;background:-webkit-linear-gradient(left,#44ea76 0,#39fad7 80%,#39fad7 100%);background:-webkit-gradient(linear,left top,right top,from(#44ea76),color-stop(80%,#39fad7),to(#39fad7));background:linear-gradient(to right,#44ea76 0,#39fad7 80%,#39fad7 100%)}.bg-gradient-warning span,.bg-gradient-warning:before{background:#ff512f;background:-webkit-linear-gradient(left,#ff512f 0,#f09819 80%,#f09819 100%);background:-webkit-gradient(linear,left top,right top,from(#ff512f),color-stop(80%,#f09819),to(#f09819));background:linear-gradient(to right,#ff512f 0,#f09819 80%,#f09819 100%)}.bg-gradient-danger span,.bg-gradient-danger:before{background:#ff512f;background:-webkit-linear-gradient(left,#ff512f 0,#dd2476 80%,#dd2476 100%);background:-webkit-gradient(linear,left top,right top,from(#ff512f),color-stop(80%,#dd2476),to(#dd2476));background:linear-gradient(to right,#ff512f 0,#dd2476 80%,#dd2476 100%)}.btn-fancy{display:inline-block;font-size:17px;letter-spacing:.03em;text-transform:uppercase;color:#fff;position:relative}.btn-fancy:before{content:'';display:inline-block;height:40px;position:absolute;bottom:-5px;left:30px;right:30px;z-index:-1;-webkit-filter:blur(20px) brightness(.95);filter:blur(20px) brightness(.95);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transition:all .3s ease-out;transition:all .3s ease-out}.btn-fancy i{margin-top:-1px;margin-right:20px;font-size:1.265em;vertical-align:middle}.btn-fancy span{display:inline-block;padding:18px 60px;border-radius:50em;position:relative;z-index:2;will-change:transform,filter;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transition:all .3s ease-out;transition:all .3s ease-out}.btn-fancy:active,.btn-fancy:focus{color:#fff}.btn-fancy:hover{color:#fff}.btn-fancy:hover span{-webkit-filter:brightness(1.05) contrast(1.05);filter:brightness(1.05) contrast(1.05);-webkit-transform:scale(.95);-ms-transform:scale(.95);transform:scale(.95)}.btn-fancy:hover:before{bottom:0;-webkit-filter:blur(10px) brightness(.95);filter:blur(10px) brightness(.95)}.btn-fancy.pop-onhover:before{opacity:0;bottom:10px}.btn-fancy.pop-onhover:hover:before{bottom:-7px;opacity:1;-webkit-filter:blur(20px);filter:blur(20px)}.btn-fancy.pop-onhover:hover span{-webkit-transform:scale(1.04);-ms-transform:scale(1.04);transform:scale(1.04)}.btn-fancy.pop-onhover:hover:active span{-webkit-filter:brightness(1) contrast(1);filter:brightness(1) contrast(1);-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1);-webkit-transition:all .15s ease-out;transition:all .15s ease-out}.btn-fancy.pop-onhover:hover:active:before{bottom:0;-webkit-filter:blur(10px) brightness(.95);filter:blur(10px) brightness(.95);-webkit-transition:all .2s ease-out;transition:all .2s ease-out}table,table>tbody>tr>td,table>tbody>tr>th,table>tfoot>tr>td,table>tfoot>tr>th,table>thead>tr>td,table>thead>tr>th{border:1px solid #f2f2f2}table>tbody>tr:nth-of-type(odd){background-color:#f8f8f8}table>tbody>tr:hover{background-color:#fbfbfb}table{border-collapse:collapse;border-spacing:0;padding:0;width:100%;max-width:100%;margin:10px 0}table>tbody>tr>td,table>tbody>tr>th,table>tfoot>tr>td,table>tfoot>tr>th,table>thead>tr>td,table>thead>tr>th{padding:6px 13px}table>tbody+tbody{border-top:2px solid #f2f2f2}table table{background-color:#fff}.modal button.close{position:absolute;right:10px;top:10px;z-index:99}.modal-small .modal-dialog{width:480px}@font-face{font-family:icon;src:url(iconfont.eot?t=1525101408939);src:url(iconfont.eot?t=1525101408939#iefix) format(\"embedded-opentype\"),url(\"data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAD7sAAsAAAAAWwQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFZW806XY21hcAAAAYAAAANEAAAIGLFwHIlnbHlmAAAExAAANNEAAEiYkGD74GhlYWQAADmYAAAALwAAADYSZuy5aGhlYQAAOcgAAAAeAAAAJAkLBTVobXR4AAA56AAAAC0AAAGIiyoAAGxvY2EAADoYAAAAxgAAAMbA6a6WbWF4cAAAOuAAAAAfAAAAIAF5ATNuYW1lAAA7AAAAAUIAAAI9Divfm3Bvc3QAADxEAAACpwAAA/BaS1xneJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2Bk4WCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGBwYKt7MYW7438AQw9zI0AoUZgTJAQDiFQwleJzN1UlP1WccxfEvg6iIivMInehgi0oHWkoROg/SQmeQtohujG6Mm4ZYVi51KyUS2NSEdNU0hjRNF41peAO+BYzn/kl8C8aeh8PG2qQrk/LkQ+69yX24PM/5nQusAxqs0xr9cIo6P6L+e79at/p6A82rrzfWH/fzcd70e9qZVLsOqUvd6lW/BjWsMY1rQmd0Tud1QVO6omnN6LoWdVNLuqXbuqN7teZaW62jNlCbr0ariep0NVPNVgvVjWqpWl7pWbm0Mn937v59/51J4f07V/fv8/5DGlnb/+zq/hd1WVcf2H/5of3Hvf90de1f9390P3U+o3FmvX5aXQteP/PL2vp1dS3yG78/sP54aP3p9RdL/1hl/0520sEBenidY7zNcfp4i3c4xCv08wK7OcIEW9nHUV7mIG08xWO8xGZO8QYf8zgfsYkn2cOn1Pt+P2QLu3iGDbzL+wyxg/do4Tm284Rver9zMcAH7OV5PqObLuehZOBFmniVZxnmJNs4zHp6eZrP+YIv+YqvGWGUE4zxDZ+wkW/5jtcY9Mm0+l9oeqQ38B/X8z/5aSm/GufWnp2yyTX+iCLKXKoufOuoPnz/qCGcBNQYzgRaF04HagrnBK0PJwZtCGcHbQynCDWH84Q2hZOFWsIZQ5vDaUNbwrlDW8MJRK3hLKJt4VSi7eF8oh1Bed/OcGbRrnB60e5wjtGecKLR3nC20b5wytH+cN7RgXDy0cGgfPa2KGeu9vBcuG/CE4I6w7OCDoenBh0JytkcDU8S6grKZ+wOTxfqDcq99UXpWx0Lzx7qD8pZDgblDIbCk4mGg3JvI+FpRaPhuUUngvK+saCc8Xh4qtFElPTpTHjS0dmg3M+58PSj80E5pwtBOeOLUb4z9EO4JdBUuC/Q5aDc1ZVwh6Cr4TZB00E5s5mgnOX1KN89Wgy3DroZ5XtLS+EmQreCkvflcDuh2+GeQneCcpb3wt1FrTncYtTawn1GrSPcbNQGwh1HbT7cdlSj4d6jGg83INXJcBdSTYRbkep0uB+ppsNNSfVjUPabCbcn1bVwj1LNhhuVaiHcrVQ3wi1LtRTuW6rlcPOy0hPuYFYuhduYlflwL3N3Lmj9G/Y/t0h4nJW8CZwcVdU3XOferqqu7urqru7qqt737pq1e6bXZCaZmSQz2ZNJMplshKxsCQlLAiQYwho2UbYHH4UgO4OAig8gimIARWRRQRFFRMQHF1A/EUVZTBffudUzISrv9/6+6e5b5y516y7nnvM/594ajue4D39NH6EhLsC1cb3cMLeM40DohIxC4pA2q0XSCcE0HzQ0hZpZMy1mM0U6E4yMoOnlerVgCKLgBQUSUEmX62aRmFCrDpB+KOtxgHA0MubPx/z0anCFzMTF1kJyGwST2Zh3oNta0DWolVMB5x7Z7w/7/Z9yCjzvJMThVWCnoUu85BKsO3hvJPhIsp0kQQ6bkcVrPamof/Nl1VPieUMCOP98CERTyl2DakTF7zkRPeAPiz6PMxTxZHMa7PmNOxSQ44XXOfxjff0c/R49gVM4Pxflclw3x+XTatpM19K1rJpWKyqtpYOGAq2+5f+DIAm4wjoLoMd6/rPWWz+ZSRzHmJXKkmrVehqvSysVy9+6fhE+eczZx1g/ss6y/gR7HnnkEFSWVqtLK/Bv16l2XUV/SRcgpXN5bNV0bFehhGMaGACjCGYBB9mfhFqhzmNMF0QFQ0djAPKCbvSaWFTPNep+s+AQBQIe0emlYTLrIYlcdML4TbzLvMVJCXlDSgLZddWOlwZfgvtVojV7QdIdTl71wql3X+1zqdZlnz8QPUdwejUXXDxxtoMkJaoSnzX+kgT9T7696mLqvHNWu05vKUrCfUUSIQ6RD7vUq74AWxTJd9GN1mUc58C+fIk26Bjn5FQuwi3FnlQLLWZRpwh+imho2DGRdSeOnQ1qQqZQq9YbahF5qF7WMUFU640BvjaZAHszPZkjXzjQuvanonBZ+4ql5WhyePNwKhpN4SUZTc9Mm8VIyGWnZsKZTG8mQ34Ssq+1kF1HKFX3fnmJEQnnO3zeeqpneLgHU+CvH9HWj30Bl9cI53uSrUScL8omjV4MP+QkXDVxXC9T7GGmP4YiXLqra3ZXV9p6ZpIgOycJ+CGw6+wu+Pcr13rOh1+gr9JjuRncHG4hPqdShE6oD0KFPWAAGgV78Qk4RNCoGLqYVSBYUQDHUxR0lohfYwBKINYbAbViNJDBs6KZVSsw/kMSIA84iOMeQbFeBMPvWBMNh5Mk4fbM9K2nBA5pvp8LIVWfg5HuntUpNeV5gHjdB7oD/PuLkhfevmR8ezj6N1iYbxsZOckxyDs2ZR3p8bXVQcnB09LMC8fi/mm0tDVV2rYIZEo7BtLLOp8jc3quS8+ZDtc3G6tWkaebF82dS7qn+vobej3tQkrhOjguoGbVhs4EUcGeeYxWC9kMdjioZuu+mlkJZgdopaz/9ZGnoL8HStP7N/SRGx4p9uZ6ZeERgEfAHWrvz23eQ6LNZ0j9vo5p01Y2GlbNegSKM4bNuBq3nvgNRKOxFf5oyn/hkXm1yB2cmzO4TntexQTgADaKQHHhIYFRBWi9UcgeyauaglgEwl3+9oFT37jrHmvVGusLq3cTsnt1KwSfUyoPAwyXWRiIoDC7HW64bM/dVHzk2O0PWQFy1po1ZxE7BCOqAYxUKiMsdDq9AO32mrqc7qEVTuZ8nMYlcE3h0ugEsZbOFGZCPpiuTf2qdRTDOt0zt5y52TpUnkv+1vRM/eaWCS3PfaG9Ov+OO+ZX2588ePCpgwfH29qq8+dzBJ9xH/0RXYQ8jfVDfXKJNkATQciYUISZUK0zsW6ADqVQcVZ39yyd3GZYL4YGDWuxkSqmmqlRAx4wyHJjqFgcKhrWSynMNgx4UB/FzGIqZC0NcfaznkF5183N5bbis1B8FQFnFoQgjmgZmbZSNnRDr9iDiwOvgBHQgzjgGbNgtpggyyRCAwZYewIJvJq8zu5psLVQBFwUosAKl6CggG6QPxR8W5SuepdineeC6R356Oxb1y6Zt2FRLNcxDdw3CVqA52/iIar5Pcu3jY5veWCB7A9GHXCeGIzowmftfOs0X6F/7sJh0+fi3ZpL9mr9QzMrmuKWNJmX4G9zYvcYkYjR3KAHO6dBqG/ASM02YFpnKAi6JLg1yfqjJAej4F6QiQzPckM06JbIzW5ZdlvvYY0B15Mub5BA2OtijxMEp6gDCQioFh0BTWiN2x30V3QjF8SR4yTsp4kLHnCeUCZIKEEb9aqZwQXCmANlpsmYNJhFoaqyAQ6qOLwVlckKJFQ2vJhOX7RW4fgGdWtc8utSHK6FL7p0p3SbS4kGt0OlsMmswHYtCh5NgYp5E0SCqzB2E6aCBw7CV0AlRAVrmRTyO/H2q6zlKNFdobjisk7RYm+YVYCq+UZMg2tdCqZtYzdqWAMONurGigmfdSl2356ij9IZqJkZf5t1YhZyqPUM1HMGE6R5oWAWsYe6kQB6361rAts/YX3v7F3kjFMhuedWX3vC+t3aN9atgpV2mLplLyROO4PsOtv63idODqy91Ztof2ElrFr3xtqVZHzdG1My50rkw11IuVBbcRIVJcBv7+SFcFYOXoFXMtZca27mXyl6unWLdQts2mM9DPMi/0pxLT14M/013Yw6sMwNMOnNM+6tIeOabApwlaLAVnGC0qJAcRpVTTcqDDQ1cAmzqUFxR9NM+rEVjZrwKBoaPO+B21pDS8VAxhMBRAfWphvF7wTCEf833J5PYAfuCYQh4r/Yoi6PxwVNe/g/ojcR0Xsu3kV2YT1eTyzfvKpQg6sFxGphf/NKfxgU18bTBYyQXf6I9TtFU/D7ZOvCxg+V1IfvYx8FxI2IGUUtiBgxmzH1SrnBYIp9mYmrz16ryHJMuePSrjcEsU5fa59e3Hjh17fdeXkwcvmOoRP8mhqJjKxt72kvRRe+cDa/e8V4/+x+Y2g6ubu/Q1JHb7rmtNlryEpY3E9FZcc8apDoqkqteMxOwdBX7B7wZOYWhFabJuhZtMRtwAiqyXqBoadCBkU0qkVDCCJiEisMcuBMMAlufxuCzpSmXm/UCy3a0OuM3XShwWqo13SBFWNYjKWblewA0DPjca/qKK+Q+/+7Txyv86pvOpx+DkDa5Y8HZswcFuMeWZaMNf1EkKSYI97v8WpRXvYIKlnqcwBRnLCWBgRZCimiNC8k6U7F5eBDLoD9pxPatSxdX+IknS6fTyyBc7QxZ+36ywwIlRyS+wSXX1W8OTUfcWdnhb2y6vKHe86N1c8oKgGf43MrXXGy5hvgDfq6zyqnTy3FUrosK5nd5XhCDV3G5g6H6sM76S/oMahTOlDXTeNWcGP/qvFMjGTTNiibCVnGfP2g2rBMZczbCwIn6pxR5xoFzmTyNsMGplBloKNeZuOqaygJcBUdfM7heO5gK4QIuCXrXbffHXTKsjOIBEiSG6zfPWP9nefB/cwz4EZZ+/dnYNrM0RUPrhjdl85m0/ts8hMZJAfIn7GeG3/ocPzwRqzT2uuUNcnNhLAqg8Qqtd6VJXiH1XF0nYf/PPBvNbXImWw8RBtrvUZXo/wJIwbv5WZy49wqHBEGqkRbchotgZlVGYBqqKh0kL+yDOcZgXqRoM5JkEZAVwgqnQFi5As2LqszsTXAmMyGZQWzl8AfJ9IM6qUn/ti6/uCJJ34AzwlOp7BFEEVhJ0+9PmElTxWVHz+K/pATBCWbc/BtpsfpC3v6ZgrizLIcFujKP2At1vewtj9CV4Z6Ml2H73odpr3eJLAFAvEAtIJvOrSITHppMOwhTe6jCH1YCfHqzLaeJX4pHHE6MzuH6+vQsvPYcuw25JONXBVl2AZuO45IC4VpqG7LDUbohg057RRcQKh4mEKvtnrfQAvSrFAby+NCqjH2GGTjgSqeMuyfYakFLMgYJqjla9lgNlgJVmqVGrnkn+XdtaWN2nGBoNNheLountnomD3rwE1jy0mf2SkFNTmQVuLgj8blpTOSx67ZOn2GImfVaPuo5JPnOXlfutccCLRBPF0x+/0FOH/owIGhi+iGcNeiYxf34QrW3Wq0zQ96NrUqM7/SALJg7vqh0VRWCrclZDWttc3JNzriYvOCXE/fYoDOztmZkJ5wuj0SkF5YFg5lSE92wXC1ow2gO7dokXo9e8BFQzY/vUffow4uhnZ1FTXAPG4tt5ehnQFi23PY5YJoD5y9VNB+KwByx4Ct4hBjMmGFKoJJJCyMo1lHwd8QGC8lQMij8VTDHAbSKnVd1HRasO1wNh0NVtjQmWmAuVhFb71Afh9xCIFE6YCYJU46bfOJV9HpXqq/unc/cI32jdanz76F0lvOPvtWSm/93GkZAeTU3PPzhf7PG4mYHkkk5jq9TurzOR1wrksBx6Vut6K4Vyi819m5wMPLKGpkt9u3r0cXqYMGfR6Nmgfgk6JG52SzOcEdTZjDic6D0opt5JJtgrTlpBM2WPc5jlu+bKfIr1624mxo0y+TSK+WS/Y0rv0pCRZSlIQK8cU8KKqHetTXZInui4le3es+VnIrUJJEShyaxxcEgnZofG59luh2J/wgB6//PNfCSvfTP9ElnMl0LzIXGweUTzaMRz1rBFEjMLDUUgEKk3BmjUc7KSNmG6ilsJhRx1KFbEEIGij7xGwhqweNzcllHakqIYvqM1YAOXBcbVtHJTK3LdsGc+vzlwG5dPusU8pkJwCJGElI6BFKdqycvyCfSkVTkGork7KZInByrB2S2UI6GFq6YNPaSMS7VTMgFsuk/JGli7auz+e9a2JfhBBcALtPXg8Q107wQ753E8ZP/tJTk7r3egfQExGvcxDwQCDPB7rRCrkJtnzIzbCesJ6Y8SEHW+iJ1qOVD6xbJiZg0weV1n376Ad0O1dAlGXrROZMOEpUIUvZgspGXnYivXp2WdfTKXLuHbshEczx1OhNpYLGnEIuSeVZX3kcDqzP9xKh8FSHwZNYya9dd85ZUX8yrSwY7olAOBHqz3Rbb//gqdNmxI4xjfKUz+MK+hd6MhfFGaqhfbscG5exYWs2jU1gEpfBoNqkMlIxz8at2DZarqMxggZKHGUvczu1YiLOJRooR+fRuqCakI00r4tkgWwbhTNGTyKD+INto7y/DQbqcwHn7T2P3x/x+z3WpxihAqieb0wmwUsD0Ww2YhVHtxGsIIW1LB3dTqxn3oPhegPNtL/4PQc9qoqB/+Mo7Ksb+/ok/RX5E0oFr+136uGmc0u4Y7nN3PHcNhyMbA0FXsPgs2bDQMGXP8rWNKf8CPzHJZpZBvPTNsyvMVSJ2QHbKGxBRQOtpny6lga0lpnFDPPOqXVUuuGL+we7ezpqzc3lWYTMKvfOBpjdG83larkcebgVO5JWz+WKNcjHrFmxAtTInAo8ioZs1+F/yl6vTHk32qjepos83+yBQ9Om/Wb69L5t1WXxk46PLa7efqTu8qz7IYs11bMPfEya9zWsGgqx116rzCH4hOaXve473V47qJ0Kq6dPnz65pq+nH9LjuSJXYpLUzFMEdpRHUclTQW/keTRY6yZFa0gXuqFeyBdyBo9L38zXzV76T+qy7rqE1/hLrLtczNwcJaoEbdDmkHgnGQiqfv731g+g6L7A+gsP275n/Yjc/ikJkQ2Fv7lQ6A5KkvV4AgLi69Z9Lpl/4AFCBRe43bKHb1dfBs0tmJmXwZt7XZTsdXYL/V+6CbkbLTXbaIWWqK+oKNcrKi45ZGeRmWE12xbDhfa4dV22HOpSreuigkATqRHoKd9AIHR5CMj1ldJIKk4FAR6HfTm/37o4UXQ7vWD9rLqCQrtWIqQYtH5GV1ShHbxOd9HGeF+iL9AxtEHq3Gnck5AHtur7Icl7+RI/yEMlKXj5LJKOCjYs6VAxLmZLAibVBvnKIFEHBdMbDCYDg1opWEnqXqOk1waDvfAhcXhcEiUEqCSgCSs7eR5pJ0phmE2dTtmOAuZJHlkQHA4CvODyCtajDirxmOkUBNGBtzt4QVIkRXB5JBH/DqHd63Cg9BQw/VGnWwTCOwRJcLkTWjwfyIZC3nhEDfrdWCdFDO0QecEb0P2ReCgUiRQKWiKZTAQCBX8mbMQjAbdXERUXDwSrESWfx+ULo4L0hTOBWDze7pJDhpFJ68FEPB9OBTW/DxvLUwpAqVNyKj45EBRD4UggkEimu7JGLpTNdqWxdCASDnm1gM+FY8Cz4rzk8vvQhPOF1Hxc69DTmWzuJGQP7IQXx0IA7L0oeSWXTc9hAyU53W4Hi2L/eJcHR1DkYQFQh8Ppsn6L9r8bW+DyyE5JclBM5nnRDVTgnbbLlCfUjf0yBEFyYHYMCBXdoupV3ZG4kcpEAwENG62xtvpzmZQRjahej+zBGcMxc/AeJxaNRA1fKOLPmXEXDlo8EctGfKGEpqlurypKIk9nt8ZBwqJ6KhyLJYKpLj2Ec5Blo4bjHIs4Q3pQln2K2y2wcRAQiPtUOaiH1Eg8Hkym01kjFAoZ2XS6IxGLhX2GN4LGCtbusH2cbE0fpDfQDba3mIO0bRG3bORKGgc0kADUomBkyT4kYpFmXyQGeIW74m28i3+Zd/CHidR8OpgGIRak45G49XIwAkMO3vELzGfPcOIznkY7fzZK3zauHe3xCjfEzWK+aRAcCJ0MMY8gKtco5ALMtZQpgdhATVidNGSIJuSzLXmbEfhsgpQR+Rchg8s5qyXgSAw+fNb6Gz86EgR/3nwWPGjF/G3D9EWjqzIZ73eUyIxZM3ctWvql0UWnDww0n++JtUWjbTHgekE2woZsBx/2ePSI7rEDOpv/9d2rrms8tZF3/Pqeu3/dvKIUjfFk+DK9dM6lZ2+M4t/Gsw+c/YgWjbZHo0FPUFGCURYoH5EtO+9i+grdj+MbR0uvwQ1z61Dj4BDX0JizFYaqY6+BSaU0c76Zap5BoQF7B0cTKi1t8jGRALMJGy31bPsmbN1ELrXmrJ+vesg3PD4AV7SteS3Jj8C3SrqPB4vKTLuGVfVrssouX/fYl9uZtpy2CGDRNEYt30nIzk84Ti2RiF1ebv5cmpXqJDdZvGdcCGnthMhnq/KdHp/PcydW9DFU8/tYL6tv2iKCFNmxYvnOSb/M48hvPVwXog6GyhF1FEweTVUeOa6FL7A/jbztIGAaF7Vo/iPX7wC0PKNHfP5HCCoWBjXrEbQ3h7XBwsAYwNjA4AoC1j1ab3xgjJCxgXivBquArBhs5WZKpZFisflipljEK+nM4rVUIu5M/It+0//FeKZVA5Z3fNUfZLetIEH/Vx2ttIEVzb8Du2GkCN8DVgMShcmUqbX1M3qIdnMphvZA80JAC2o2f9s7LY2AbZDlkcuTwOt8owSqQQ95v1PSXe6335aDbih+R0mAstedcp0NnqT1mztfP/4Z+F9ZOWS94xCj4rnniogBnCAf8ro13nxH198x+Z/cnPlB858n28+/EzHeGi7EzcbnM+XHM3snYDIPbaBeKEEeBxYRN1qCqMWTgNaDgBZLI4/rjtcrZVTmhUFU5Ga+gFSWcPv5oAf0pyWJ9Lzvjrjf7yGS9DToniC/3y18UnBaT7sF8TWR1MCNchF03smD5uCdbqiB+CunIFvPuuknBTfNHJa9pP27Ushj/eEigTgvwkpC0nfbwSdDr8v6nUi7SND1suC2npU8QD5DyDUErb6aS/yFM0g7iRNCrskx/h96Iz0HUd0cW56Yk/b+pO1m23qGrgDzIjXqOUP384XGlD8AC7dMQMW2TGwYTk9uWG9f356TBW9ETqTP/VXRPGXfub/qDruJL6YTUVKmgXL9Zy9u/lVweldXqxWPsrraFgpvK9cDxKHLTpk4EwsLu+C0zxwoKbozEhLEgNvc+Yn9v+w2d+ybu1AJOrxK95pOzJ5mvdMTilTKsjJexdAd84zUNv/AmZQJSO7CX4/vHJ30k95s70MtQxt2i428EM4MMD9RlZlHLRJNhwLbCRFtj3uduf0wwTZPGcmsiiBKc7bGmGuwPrk/FUAUyzzZlJVj/ieU/EaFPkE72i5du/E6wemSne4v71g5ITol6nFqf1+x4u+a00MlpzixcseX3U7Z5RSu27Tu0rYOKnt6wOd+4BkqukSEB8qTd7t90OORrWTxvn1drsp3DsC1++4rHvhOxUVeIBBIlKME3KqLZIbmTQMi+ySAzQcu2kIIQgWAafOHMpjvk0m0ktAAQQlKogvcXs9mUaCEete6wesm58oqaSZiM1xkPjGHrLg0M0qGZ5nEtnG+RP8LMaCLC6Lemc2dgGOnC2bLhg82ipPW/wAEisQsiAoRE8TQmXskoFCR8UyRIosgnE2h+BECAsUibF+jyHxMzMtiDlBcH426wdziZJCfk9BV3exIzXCePi3XScjKk+Ze6G4Px+76fCiac6nVVObCcyveWi/vdIa13j2n9UfaSzlZ8VPX+TB8vkylE5VeGg77r/7BlWOSLBKECwwighpIuaPzT/753WszOEafyXX6XaWiJmR0eeassG/ErC6QVsN2r8bz0ZhDCHh9Gu9QfSLRmo8rfYUOORolLoccSGiN0yR+5UoaSJHUJutNNeGT5gd9Q6IvJBpe/v7slg4loqq8K+oKliOdcnbKz/w05egFnIaRYJbZdhUxq+KnVrFdyuTDtb3ZLxjX3HfNNXu2rqRnf7a9fcfd1lK4/+7928+c3Nd7hfwdbWWdMzguwLSehKPcOGJmqrxg5i8g/2yrg5WzsqTWthHqba14yS1bJfIO8rrVBGJW4VGr0cZc723wzLuC8I+pvYSH6Zt0K9omVa6v5Um1GdxsGdlTRFahRmsF1Bv2h4k3ZqMIBSYwUMN8M1gPt81Rgyi3Qs7qxYtCOQcJSUuvWDx+/elFWX/g0nT6lK9NV0I7SgLiZ+3weYHNwqw+y/3TheR2+Kos0/TSnqFzhtwO18JjlO7jah6nc7ROFlxy69ilDxj8zuND6sLdql/yeD/Vlpp+Rj90N0KHkEO5Dw/Rx+kgWqtxtFmKiBMWcxvQOt3HXfWvfmEDdYjtLDfYajfrDZ0imc2YVbNOy5hYqAWYx535+zCT2TeYg/xrn10whGDD9nJprGS2VQ8t1LBkkj2Fz7TumvyhYAywBIPVUrCrwacLhDt0mOcPH3qUhWlZjyBI0GJ9izxzl5WK9VmzR5IJ6Dwxk+5qJxek2nztCXHfSbEZghjJOrLtvhXWnlgKcm3ecFeb/5tX0FqXxxfJAHhmuB3gOuU8qJ09G9oWXlw7b7vsTar5/NZjgnr94adXj6QNrMKPKmLOYjVHB6Za8Oihwyc4xcEZfFqPqOXuWTet6zB81ni1IBNBaCOUVw1dtxZ3F9xBf3zWttUEMhGPO5s49vZ/dm+blojOmfdgMv+pbxupVK5LxDzdt8q6OZvtnzY7TrMl6YJyV2SuCDoF3SVtOA3kzuFKH2A5f1xs9E2/+dgZDWXSp3IPfYnOQG4UcR6jXIzxOiJjNa3a13rDFMRswcQxx2gtPUpPP3wVzTXN7URofgA/6unY3t54uLt/84y89Ta93WrSGVutAFxs7YPMIetbCzYVdh179qrCutEtWyb3EO7ju+lyzselEUkt43ZwZyKv9PTaZzumQS/bddRq+f9IyNicY29fijbeannRyw3dYSAOZzxTLSAgaAlKJuaYTGy0wFgLpqFZQBByT/lD4ctsIwFY8DtZZZQqAwo3T+cdO/sXCsLC/p13dMod4bZarc3QJNB++BxoTi1k1mr//KkjlPCJoaQX3px4BU1Ph8+TOGGgNJZMregZOD7p8aFh43gFdnnDoi8RFrzQw3bS3IqCwOIIdXs8dOxnc6GxWm0slPvssaE4DG4aBM/1/0PI/1zvYZFrZUkOhfFn3UwuOVXyGw2tqwqpGLJitUtrGJL/1EtgjiCFQzL+JuXe4/RHdJSbgfOYsLekapO7oGwzivkzcd0UbG8vAqYWqNCDCOcTYLu/2BERzhS4bnrvJ1UeTqhStV3saRhDuhTduRXKitdRWiRUD1Tc87sciqcCx+0MBB3yp75MeOuDJ5+03of9B/9YpqprmbDcbxiu8HicF/OR4N7lS/t7kCM7BEWRCkQc7ukbXbEn6O+NnSm6e/9045Mg8A7r/ck+3Iw68FjUf0yKtLYKjCk4zURewnY8tlJsD6RZLxDuijudrj6vInn8A1Qac0irnLE3c7k3Y85VkmNMogN+j6R4+1zOz9P18NyjwesqvdtFukpcvxEgHwqKaCwHQ3mAjevFVVTc3lv5jPbgz4+c8XiDNLkw8iy2KVBRGTuxoUJKRUY0xCzbNcyC2gIjeRQ5KrYqZMovP+Tr9D30c9ms/OlGIqwQ+BvertADd38tD59v3vfmjfmv3U2eaz5EB8LhAUoWNq/iZ7udTucIT25qPuaoJEmXb4XTucLX/Emy4miNzT10H92JdggXQP7XbaiLkzo1PLgyGNNXbZSIKczyZ4re9ssOwpGdOgUunt4XFN3UIagaXHvB6XsANi3vrkpKhuQLpRkAPkjFXV4XJU4qzg86vX7fouInbyPk0O1PP0MCC04Pi3qXS5YC9eyOGxzkrGP3TThgRnf9RDNXBLJ00OyBS/aU5p0v80Cd24bDM+bE28Dxo4nzH3Y4X+SOjOsh8lvbju+wfV62X1LVDNDL2LFqXmgd5dF4YKOroznSyqCKtU9yW2/KXpDgYrXb/2e1+Qe1O5PpzpD/svY55WG40ud7y86A1XCxE7sjW3+QndY+Vf2zv/slNcMKv8RyrF12MZZsy8Pz6SX0fNT6EW4Rt5o7EQe9YYgG+4mmaDbsX8MwGzTdSOcH7I0rtovCLBF2wKaCMItpaNRN9naKmGUGsMk2WVA7UV4stErTPLBjKq3ZsX158HuvV/ckvemar5b2JnK6z7cgsLNL+wJMA+t7pBgNSctcPQk5nnBmcdqcHm2nkXXIbtkbEkZ5t/uHXcWHZb/ZFn+4Vj4N+va4ZU8i5RSfsZ6Eb4em9Zf9eaVn8krqQU88i6KuQ+/o8Jh8Qg66IoETI016yhnuWuy1WJwSRzm2X3IKbYv2uwJAwKu8JhuOxV7we05KXZZoB+Kj2w8fpIQ4qnHDevcwQMAnJozqnvaAzxkPVfZMYpxX6Z9oBtdOlp2dhJpiL9lgIauiZdNix7rDUDPMGMgithINYPaByoQUvfbwQZ4/eLi72wOhXWpbLNam7oKQp8fKL3xw2PH4eQ4XHHCMfHWh7DjvcXLXJ8QTZPkE8RO0+SkHLbtSBNLuXuogZzS/2hYGMu5e5AxZaYi0kWjcucg9qf9epM9j+9xocdYQb6P1krcPB7UOEdFyvWYfQmSwjymh4KSzqdbaMGBYkO2rFYEv26cQWyUrU7exMxrkTYcR9dCL7XCOEgjE/AB+OKj4gYbCzTXJGA3EAtCTJYfT3ZjTPEZhu692qf9ixQOBGz0eERf3Wwq7NN8KKPBpr9/vtXYrgTMCysUhnZJQ9AIsq9ye64FU+mt2Ojle8fuV5kGWToCFzQ+VADfp07gN7bMN2G8NdcVx/4rXxMllJ+SzH3UV87PMjdHPOh1k6nkm49uK7dGYLMOOObB4J8uZLMM8ca37FCBc3xJClvS1wrhp9pkm3Ay+/71Li2l3/a/PbuTRUU2z1iD9yW965yCtzPF+85P/GiXSker6ljzL6uszT/j4mqai1kn/h7pa0am9pjvpT+hCmy/yXJnbhCNk71Cj6NcENhnZI6drjBZPfFzkKKdZkDnNivYpHSbmGGe0Tu0UmEJj53pglScQ8DzNWn4ZeGVrpexD3PhFmW2X/B9jvzr8bpodEL1BT4ArHJEh4G1+WdECXvJDdpzaGQq7gXSRzeC3GQqDS5ArogH/gx4Wj/r9DyitjMC70JWiEjtfENebyz0ZCjkPOc/LmNHbzCoaJpPpcppCRm7elO6c9GXc7rgf7VX7BDKUmYleM2t5djo6mA7mgxhqKAYnTyQnwLbh+cYAaSC2Z2vcHjHyc0gbuucvkLZ+9WnrbfC+DN9GTeR6ef2amzzihruuHhw+nsAhnzenweF1u0Ypmbdlx9NOxwS45o/MWwB0vWPoM58ZoltrUGvfyi8QYO3JO/aZiULbqcI7sdi8Ppjv2Fgujbm3Ot23TLb7XvoiHUfeX89O/RQpynFaq1bKCcoWbxUBZkYhQS1BUI4buBTYIXbkY2TqSnmAGCzBZImkVm1MnVLCu/EWUSfvhrL1UmKdM+KW1kTaw3rEF8+OnNTfvnS43eiu5dY2lECvmSwnwkk1mfzMiV0rhtt+efnm0aFS1+qbdw+7ehld7G7REEmW01GvECQul89V8mqa14xm6rFAYbgrPy1nOHXF6elJatFYIBebtszomL9m8+W9ruHdN6/uKg2NTtHdxaGWPL7H8TTOlwPtNx/23ETVJhFRgm52fs0kv965Z89euLr5XvP9JWQlGW/ea/12MZwIJy2hrlUbNm60vmWdADcMWB3w0/ivBqzfQnRgUs7/if6dPIfSJGefRReFDCrCKirCctJW3DiG7IQCU5eNwIDtoYcjhcyPSsKKiKDwH/D4VYSIIPz4xwI0niKymBZF8hTxCHiFDZjJR3n+xz/m8cKK744KwvutGzFB+PELPCq55hK8R8J7yYOMoLJ14/uCwG544ceCXQHWM+Xvf4Z+jU7jvFwA7f0ol0R9Zdoneo+s1ZZMp2k1zXZfeTSG/v1KLzn8jhaLaVRm4eF3qNz8zubN8Jy1BW6yev+TotMAi/09GIsFqVuLHf4udf+ip6fnb729ve/gr8WnP6XH0SFsVdI+Mdc6+z7p+WNHNphS0nT7VHGBbnWk51zhcpeX9uy4BHXB5de+nhGsO6cvpQv7po3ShfCj1cu/cKbTmYP82EuXX/ZiTL/+6sxx86f1LaWwoNG3xLbPvkqvoLtta3BqLLg8wlz2qkOAb+Qb7Af4EQMNYH1Wxpvc+Aa41W9tKMBFWWv/fJhft75+07A13LwI7rFWuYGz7oXxDzkIrV65eveDS756mvXWLFAvr1j3VKyR8cn1+HX6FJ2P+HqN7S1keicdbJ0SMmpGL1uFIoO4aITaUJbWbSegvf1fsuFtzVY97CgAw1pBtgsktk6zCq3pgyd5futZhMyGPVvcHrTQKC8A3boXmofIWZvR/uCpg3fChwhxRuCY5R7P8mNgLttcOPw/Hr+qLID1y2V5+XpYyNLoqKLClZSEr9m8c+fma8JUdYtARcoTyRm+dtPatZuuCRNKeV4KCNYi2b923edKoli8ft1O9uJJWIWd664vimLpc+vWsgTbNsaF9B75Bufn4lwbN8wt5Vawc9VMpjD7LKgpJJtWeVs8sXdsAiiIakzZBvO2c6jCjqSgQCoMECaJxLSmNwomijGxUrC38otd86uxjvZp03IzR9utF0HNlbyxtHre1Vo+6qt1/ReZGavk68KOyMmLqytnJiEzY2Vl+ng9RK1DvoNGKZ4PS/A9/pUPPiAPgy/b31kaCKgr+orDXRo58b2MGYz5hKutD5z+ZKin7W4SLWjLRtJD49WeNYO5roWbKpHiKyEIJDKe0vsz7TnH/n6LDnAy4+08StR0YHJ/KZ+usZmcOqmgYjo9JhVqztuSMsiFoSQ0Y+SMVMi6H5Ih602Mb0mdYqTg+/jDlC31UKrCyJTRPAkeNVJc6+WIR8nv2JldSE8ez0uzfXSmjWHCeqdQBigXyLOFSqVgHSS/xUjzjVYiPIrXSXvlBvLgpK/E9pNMfU6g1cPfn/qRByo/wM+kv+Of9NfUbe+lDSFvb+fOwha0bDBBa50jEgsaw8R2VNTLDGkVib26NTTN7ZOxBaHl92V8XsgE6sydbmBey/9f1ifvbG0/1auTxp9eFZmUYFE0mynXv4yQZf2K0jsLYFav8oawf6uirNkmQsh6DdaNjJzoXTg8sjMoUJPC4qGhS7o7XZnsuSNLNwA1r/Z99bqrHgWnSVz5TnPHGTvMzhRPu5vfmqxMmaz8KXHbGkXZeo4MBpyACSxZJ1gCy9HIT7deLmIGPXetAreObBZg5eUn+zzzR6SgNxQaOTVsFHrrl/X31SV178JQ88WrX3A9cVUkFBo8s6urWOzqPaM/BFeQoTJ7pgGwrH/GMqz07fF9FJ9BP73VRT56J+MXaHOUuFlsBTEFwz4p0X77xbDP/acadVFImYUSsd3hKUNPsgOZJntRwDz6dQ36wzQ7Z5nubTxo3fhgo/dIDI57sLF6wnpsolbyuSS1VJuAoSn6r2qgUAEI+tS+pQBL+6YvgcFOyeNxdQxU77qrOtDh8nikTpv2HzxY7g96Fb2/zCjN5w32r3VCrS0XcZAVAwMrCFk6yUvvIS850TZNonyYzs3hljDMZbS8YtqkgCwjHEH7hcF3BlCPYPnW2X/WJRQV7Kxa3t6MTbT2aCcpco/qCx+64OrHHPOHMntS05I+n4ve1q8ZRlsi8bKWTJqGQZ523HXW/tsovW1/uBI5NlydbV3oCQY9AcP4gkfTPFiYRMm2AwQLzN3dfcIM0QUkk9/9uY0G3m0a462L9da2TxHyqW3brqBuoTJuHndcMKIBaJHg1LWFK35OX6IBLsh1cNWj1m7FYG8wTL6QoKJ8zIpCie2/MrjNoHcQaJaprIqapXua/vY6QL399ZO0Hu2k1+2I4f9gL8/v/cBvGH7yZ79h/eBnfY0XBho0gAUtrq0O2/ygbmM+fa693rxVNWCvw7EXDJVw7B7rc5CzLmOIFfZO2Qy34vxEkHJyCiKhCMoI9spFI4+YOZAN1MvIegLCLEYa61Dq9LpEB3TBpq9Yv9v+j22OKHmi7hBdVi9M/GO7I+qAJ5qvwphouCear9Id1kOwULbumXAbovUlksGIPGXL/YjeTL2or5NcilnZAVsF2i7PMjtcS21fqYN5BHHuCQetEwktP9ChSDYbOe8LiOprWcef74/kchFwwDoBspUcOK1N1s92QqwyvRIDmFkszoQXstUs0LvPY7c98BYMQa6cA9G60zps3zoNbm1OS/Qm8IuFYabNt4fot+kc+x2pLFfBNTnKZtJuZJr5bQPpKRVdLYhH0YGjJDWb58CU8V0x0o1KLStmzaw6eYaNXGz9w+VV3OByeb0LrGU2/RV25PQoen3zgsZCgIUNcp59jUAx07wg0w1zHoXYI3PXPvKPQ6uhO0vOzaIhPlvR0SZjwRIMlKD3LoWtUgXWYQVHV9TkMkXAmp67a6Jy111wLtYH3Zmp/fRL6XfpXkTbCDSBp6YKvCqBSnk1T6vWEngQnm/eAt+GJ8+1vgHzyC+a1pW7YAcUf9+0rPfASYg1/Wtw9Tdb581voa9R9q6IjDIggei0zg3ibNv7qJPuUMrUib3pkWeGFabSakPP2dsiaH0GWqXYGeo8FrM3UFL00cX3ro1mV3+61DcLDnZdNn7MuQvHNt5p9Z677ox/nqV/+l5yDkj7MtFzXl06b/RrC1/cm+0U1m1b+d/wc8+csVvmEd85dJPlDvGBkVmpzSNDdxwLm2ZvSN5yIAIwR7/g5mwUznzIOj+oQSI/OCd72/mz77feOufGzPpvbWiHuusbD6iiAac/NLVvd4PdR5Oh3ULDLOi2/VVvsBOOAtdyadovKuoV9h6BiRDuyo4wzFfzjkg4GkXj9Wdznt33fettHjav1AgJBebGxtd/H7w89FpPfx0cet7xUL8iBAN+r0D+uPYk4K0PH9/59aFzaERyl7QUD/D4Kcc+u2eqPV+hf6VnMxQMbLc5wbTz1K4TShs2oKjOyWxfwg2bXDLIkjXfnfJbV/hSsuSIgV+FL0tBeqbD7bZulkIRw2nNU1QS52U5rsAWvaDAfa7AkXNNr9Etk7jPPgfATr2zRTG1Y46PrLS2zDMfbZnbC8kmszZMCLQOKLfebGvgike8ACgM6fdoZ9ulx2z+DG/vkN+3Y+WE0ymBQwPtH2Nj/9CcMnU6nRMrd9zX2iL/zKZ1l7V1UrcCPeCVH3yWeH0Oqjx1t+zFBMVa1NdHXgKU1IlyjMg+NwrcoflsT1ySBNhy4MAWcPpkAtPnz8oQl+oGEq0kA8TeET/X7QXPZtElsi1x2SuTC91+hHTzpvZFf0n/Qk2UoB3cYvYWFNPI1EY67LCq/TIzZCa7SlrKjPnrzADOScP2pgZsr7gCXjAbA8SGR2xlgEUdvavTzdnC/OyaLavTh+eI8zIrrZ/kZkX6+PrhyPCi4Wgg0M/Xm5E5hfdLKzOF6PDiOZHDDb4/inmRTW2b06u2rM3OE+cczqzqTZOuNuhZ+ZPRfJ52tVnPI5XLU388NvSlEev5ZJbE434/0tCTzJDD/08+m4vFSSYJvSNfnBWP00zyjNSZZpejkB99Ydx6vq2TTMmMr9Jn6SKU5kOMD2zT2GA2NHu9krm/zUKGReyX3BosQwEEjIP2K5iTGZPFBA1+2de3bebNMzF0ejXntgULFj+5BENR8w5imnn8SQtj0cJ/5MGxeM+2vj4WOjVF3LbkycULFrBQ9AaWstRCNLbwpOPN/8ydxCrfpr9Eu5XJ/CJXRjk1NCXzW7K9cZT8Nyg7w83jlNLWK4dpdqasTtG8NDNoFQxAJc/e2szSYPMF9roO6ZbcbnfzXpseR/qWUSmTa16XyLtHXZBQ6Q6fD+AtKwOvziB68zuzeb+f7Az4+OG3yKjb78bvSVN7fi9CgYTiEIlZP5Y8VoeKUiuiwk8169DeB2A68qZHsb57xEZ9le7iGnZfWliKvXmitnYmG6bYsLVu0GjYNioyptjavRJV1Fa1lm+VwSyGtwg3dwOBkcb+/Yu2ZaMFz+yJrpFCf/elx7S3H3Npd39hpGtitqcQzW5btH9/YwTIhrm5YnF+sUhPR7JvlXftmPWQWEqHykZq0f3pkVpbn5N0dBBnX1ttJH3/opRRDqVLIiwcW+td1Td3w3IoziuV5hUnbaEnSIVplACi8QaYcEov3BMOwz291imk3GuNGwbci/SUDHyLXE9VVl5i/vmGBORE63Iss6ds3Qobqc+6PBy2Lu+FjbDxSP3fZuVxyRkSSkjCha1VvXAtXNtrrSKPG9Y4Rix86r2t+mlbq37mhMIHmHB9GTZat5Zhj2FQX691q3VrL+wJh7Fqz6SvYJfNWx95akqILBpcP3LaHOxXkP1zhixzQtZE9mpQmr0exCw1NR2wydaPP4r+9/irE/TqiTFry8TYGNw0NtbUyR+a+vtjK8aQfgSDowh6evvh0+jV7e3t53TgH0uHt8fsvzvHJv8mWhcbr11p+zpa7c/+f7cWRFNMwiB8bGtI4eWN/eck4u/T+R2HT6dX4bP3YyPaV7AG/PYXG2ecE4u9P4kRj35m8v82QumP7/0E3PRxT1qE3fqPZ5j/l34deWcr+/HPgsUTEysmJj7ueW9PjN1559jE//9nivZOXoMt1Y9/Jpmxe/fU9+Oe/Hz/VH7/7tbaQF4/k/zd9gcw3pXY6jDhsSoMWSyAoar1mB2QdzCw/jVjSt5fT39PT0T8Hsda/hXymjy22z7hjJcBeHfDfkL2byD+1rX5Z5DgSrJwuvWutYsspCfYaUeVWWPtst6dvpDAlSBNXzi51q7BtYbtBZUNSkVFKavCK9Z1sGM+7LCuw9V83fzJ2GT7sI+vkeftMeYQf2E3ReY3NoEFDTsCcNpjj1lfgWUre3J/+cvma2DZY4/1XLP5L3/J9ayEZfCVxx7DcDLzKjvzqqlMbur9/tfodO5M7kqm85gas0+rMT1WmtopbXmS2S4CJifgCFn+t2T2v2UGodzbcpgwFzPzLX98pOWKZqeuAr3sfTj2Bl150hldZmdIikD+Wwq76NCV0xMyce2RJJJbf/zqVJ97dlkQoh4SzXjCkiE4owqJpZWwoMpHp4Y91Cgo7dAmJxWfQ4mKHlUIyymPSpWo4PGJ4cl0QVaFiDul+KgnPP/BkQm34E0syfW4wq4npIjkz2YdXWBJkqPP06474669rrBEs1m+01zwwEhZUIWogmpUjjgFQ4p6CgbxhLH2I6miLoU9mRhR2k3ZIbnbvFHR58Hn8ZKMNGtyGNPlNmyfT4apDHh5unv2hJx0KpkeSfquhM3Ank/qhNfoLTRlv1WTnnqtium+jw7jN+ydUebHszf1W7tdGKf7rNW+YNAH1BsEGCxZt+CVDJSI4NMg6Gt+cNaNNOgj6e2fpkF4Iehb7wtC0BsoDRC8wKbSINhp9Mazmh/g5dPbf+ILctz/CyPCp1AAAAB4nGNgZGBgAGL181tmxPPbfGXgZmEAgeu8IQkI+n81qy5zI5DLwcAEEgUAFjoJXQB4nGNgZGBgbvjfwBDDGsQABKy6DIwMqCAJAFLvA0wAAHicY2FgYGB+ycDAwoAFM+IQJxZj00+hmaxBJKi/D6V/ALEohX6hMQYAGPYEswAAAAAAAAAAdgDCASgBmgHOAkQChgLSAwQDOgPWBEQEfgSsBR4FaAX8BoQHEAesCGwI3Aj4CTwJsgpWCqwK7gxADHIM8A14De4OLg6gDxIPrhBSEHIQpBEEEeYSHhLOEzATeBO+FCQUbhUWFWYV4hZyFwYXYhfeGAoYahi2GO4ZKhmsGiQaWhp8GpYbUBu8HDYcjBzIHRgdlh28Hi4edh6sHzAfsCASIHwg4CD4IRAhKCFAIaAh2iIMIkYihiKoIt4i+CMqJAIkTAAAeJxjYGRgYEhiVGfgZQABJiDmAkIGhv9gPgMAF7QBrgB4nF2Qy07CQBSG/0JBLYkLjSbuZmGM0aRcXBjZksCeBXsoUy5pO810IOFpXPoELl36FCZufBH/lgMLOjmn3/nPbTIArvALD/vvhrZnDz6jPddwhjvhOnUl7PPcCzfQwqNwk/qLcIBnvAq3cI0ZJ3j+BaMnbIQ9nONduIZLfAjXqX8K++Qv4QZu8S3cpP4jHGCCP+EWHry3YGD11Om5mu3UKjJZbDIXlDDWi00ytSWWNtG2WJlMdcNOGY50pu2hr9gues7FKrYmVUMO0EliVG7NWkcuXDqX99vtWPQwMimvMYCFxhSOfs7nmmFHv0IEgwxx5R3rDsqYdQs+R8Iee1QP/wmzFgXjMlLoIkTnmB0xm1UVp/sKbDm1R9Vxp6JZdqSkodxAc2NCVsir3JpKRD3EsurK0UebJz6pD6vd6T8/OGF2AAB4nG1SaZfURBTtO52k093TuIIbooK7BPcRUUBQEQX3XdZK5SVV3ZWqTC3TM/PrqXSE+UKdk3PuW/KWe99oazS82ejxr8QWxkiQIsMEOaaYYY5tLHAMT+BJPIWn8QyexXGcwHN4Hi/gRbyEk3gZp/AKXsVrOI0zeB1v4E28hbfxDt7FeziLAufwPj7Ah/gIH+MTfIodfIbz+BwX8AW+xEVcwmV8hSu4iq/xDb7FNXyH6/geP+AGbuJH/ISf8Qt+xW/4HX/gT/yFv/EP/sV/uIXbuIO7uIf7YCjBR9jPK8l0/2UisJLpKTcVFbWxq6Q1ltJDIUXIldQrqqTO6SAGpVIL5xlf0T4XTDc09qzJo8fW0olEmJYyR8xyMemsWRL3WeygTDPxa+k92ayRXoQy8bKldM9ITlljTKMoXZMszbajpiXtaxaUn/Z1Nz3TThhNOQ/dYC4lW4Z09zA6p33PwcuV4askQppw0/ZlxvGP1AlmaaglmKqTHi08aR4Tik3XpDRmNS2lL0PczOc149S7UmqZVOkhN0ZtO8PjJkUbyWBZZUJkLIuMSd3Mh502Q2zt7uZOhA2edlLHlcn5JLLkkjL6xjE462sXTpCqszhLQ74nq587Y0p27CB1q4OOsmWgpdRJL0uipPOzlnVFy+yK7CCC2SNbK7OOHATbKObcpKQoC6d5bVRFtjAd6WzASSQkpMGRdeOoZbamqKDPdGjLQRbFyrF1Lu/Vk3vk8p3zFTnZ6EllZVluJIrDzQ9MqJgptPE03WyyIV/QYTBJfy2LhwU2gSyOI4ydxWNRVFRmrf+HimqfDzB08wFY2Qifc6ZIV8weewgKLoivjsxW6uAWj8xOBXcU7C/L9bfgaFqRklya4JI+Z6tpZrWVMc0J2aVxZaLR6AG9AyuUAA==\") format(\"woff\"),url(iconfont.ttf?t=1525101408939) format(\"truetype\"),url(iconfont.svg?t=1525101408939#icon) format(\"svg\")}.icon{display:inline-block;font:14px/1 icon;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-webkit-text-stroke-width:.2px;-moz-osx-font-smoothing:grayscale}.icon-diandian:before{content:\"\\e63a\"}.icon-huaban:before{content:\"\\e63c\"}.icon-code-fork:before{content:\"\\e67a\"}.icon-more:before{content:\"\\e6c0\"}.icon-zhihu:before{content:\"\\e6d1\"}.icon-linkedin:before{content:\"\\e724\"}.icon-eye-fill:before{content:\"\\e64f\"}.icon-stackexchange:before{content:\"\\e8b2\"}.icon-tag:before{content:\"\\e6a3\"}.icon-starfish:before{content:\"\\e62e\"}.icon-home:before{content:\"\\e660\"}.icon-search:before{content:\"\\e61c\"}.icon-project:before{content:\"\\e63e\"}.icon-dialog:before{content:\"\\e613\"}.icon-twitter:before{content:\"\\ec9c\"}.icon-github:before{content:\"\\e70a\"}.icon-time:before{content:\"\\e669\"}.icon-voice:before{content:\"\\e65a\"}.icon-google:before{content:\"\\e601\"}.icon-weibo:before{content:\"\\e64b\"}.icon-segmentfault:before{content:\"\\e610\"}.icon-star-fill:before{content:\"\\e630\"}.icon-phone:before{content:\"\\e68a\"}.icon-cup-fill:before{content:\"\\e614\"}.icon-jiaju:before{content:\"\\e671\"}.icon-qzone:before{content:\"\\e603\"}.icon-home-fill:before{content:\"\\e617\"}.icon-clock:before{content:\"\\e618\"}.icon-file:before{content:\"\\e66f\"}.icon-comment:before{content:\"\\e61a\"}.icon-cup:before{content:\"\\e62c\"}.icon-share:before{content:\"\\e66a\"}.icon-star-half:before{content:\"\\e62f\"}.icon-star:before{content:\"\\e619\"}.icon-tencent-weibo:before{content:\"\\e602\"}.icon-book:before{content:\"\\e79d\"}.icon-bitbucket:before{content:\"\\e64e\"}.icon-facebook:before{content:\"\\e6e3\"}.icon-email:before{content:\"\\e667\"}.icon-zcool:before{content:\"\\e60c\"}.icon-social-media:before{content:\"\\e68b\"}.icon-douban:before{content:\"\\e60f\"}.icon-coding:before{content:\"\\e600\"}.icon-github-fill:before{content:\"\\e71d\"}.icon-qq:before{content:\"\\e611\"}.icon-shu-fill:before{content:\"\\e615\"}.icon-pinterest:before{content:\"\\e697\"}.icon-tags:before{content:\"\\e6c4\"}.icon-bill:before{content:\"\\e61b\"}.icon-shu:before{content:\"\\e616\"}.icon-book-shelf:before{content:\"\\e60d\"}.icon-target:before{content:\"\\e695\"}.icon-profile:before{content:\"\\e6e2\"}.icon-alipay:before{content:\"\\e938\"}.icon-skype:before{content:\"\\e604\"}.icon-juejin:before{content:\"\\e605\"}.icon-code:before{content:\"\\e73f\"}.icon-list:before{content:\"\\e61e\"}.icon-map-marker:before{content:\"\\e609\"}.icon-stackoverflow:before{content:\"\\e606\"}.icon-hourglass:before{content:\"\\e60e\"}.icon-behance:before{content:\"\\e67b\"}.icon-folder-open:before{content:\"\\e6b4\"}.icon-folder:before{content:\"\\e60a\"}.icon-menu:before{content:\"\\e607\"}.icon-users:before{content:\"\\e60b\"}.icon-eye:before{content:\"\\e657\"}.icon-wechat:before{content:\"\\e65e\"}.icon-number:before{content:\"\\e658\"}.icon-gitlab:before{content:\"\\e67c\"}.icon-rss:before{content:\"\\e63d\"}.icon-archives:before{content:\"\\e62d\"}.icon-68design:before{content:\"\\e608\"}.icon-dribble:before{content:\"\\e982\"}.icon-wepay:before{content:\"\\e629\"}.icon-youdao-note:before{content:\"\\e8a6\"}.icon-book-fill:before{content:\"\\e659\"}.icon-hezuo:before{content:\"\\e6e5\"}.icon-link:before{content:\"\\e635\"}.icon-archives-fill:before{content:\"\\e694\"}.icon-anchor:before{content:\"\\e858\"}.icon-angle-down:before{content:\"\\e85e\"}.icon-angle-left:before{content:\"\\e85f\"}.icon-angle-up:before{content:\"\\e860\"}.icon-angle-right:before{content:\"\\e862\"}.icon-calendar:before{content:\"\\e895\"}.icon-calendar-check:before{content:\"\\e896\"}.icon-calendar-minus:before{content:\"\\e897\"}.icon-calendar-plus:before{content:\"\\e899\"}.icon-calendar-times:before{content:\"\\e89a\"}.icon-close:before{content:\"\\e8c4\"}.icon-delicious:before{content:\"\\e8e2\"}.icon-plus:before{content:\"\\e99d\"}.icon-gg:before{content:\"\\e6fd\"}.icon-friendship:before{content:\"\\e612\"}.icon-gitee:before{content:\"\\e61d\"}pre .comment{color:#8e908c}pre .attribute,pre .css .class,pre .css .id,pre .css .pseudo,pre .html .doctype,pre .regexp,pre .ruby .constant,pre .tag,pre .variable,pre .xml .doctype,pre .xml .pi,pre .xml .tag .title{color:#c82829}pre .built_in,pre .constant,pre .literal,pre .number,pre .params,pre .preprocessor{color:#f5871f}pre .css .rules .attribute,pre .header,pre .inheritance,pre .ruby .class .title,pre .ruby .symbol,pre .string,pre .value,pre .xml .cdata{color:#718c00}pre .css .hexcolor,pre .title{color:#3e999f}pre .coffeescript .title,pre .function,pre .javascript .title,pre .js .title,pre .perl .sub,pre .python .decorator,pre .python .title,pre .ruby .function .title,pre .ruby .title .keyword{color:#4271ae}pre .javascript .function,pre .js .function,pre .keyword{color:#8959a8}.highlight,pre{background:#fafafa;margin:10px 0;padding:15px 10px;overflow:auto;font-size:13px;color:#4d4d4c;line-height:1.5}.gist .gist-file .gist-data .line-numbers,.highlight .gutter pre{color:#666}code{text-shadow:0 1px #fff;padding:.2em .4em;margin:0 .3em;color:#555;background:#eee;border-radius:3px;font-size:85%}pre code{background:0 0;text-shadow:none;padding:0}.highlight{position:relative;padding:32px 10px 0;border-radius:4px}.highlight:before{display:block;content:' ';height:32px;position:absolute;top:0;left:0;right:0;background-color:#f6f6f6;padding:0 10px;border-top-left-radius:4px;border-top-right-radius:4px}.highlight:after{content:\" \";position:absolute;border-radius:50%;background:#fc625d;width:10px;height:10px;top:0;left:15px;margin-top:11px;-webkit-box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;box-shadow:20px 0 #fdbc40,40px 0 #35cd4b}.highlight pre{border:none;margin:0}.highlight table{position:relative;border:none;width:100%;margin:0;padding:0}.highlight tr{border:none}.highlight td,.highlight th{border:none;padding:0}.highlight td.code,.highlight th.code{width:100%!important}.highlight figcaption{font-size:.85em;color:#8e908c;line-height:1em;margin-bottom:1em}.highlight figcaption a{float:right}.highlight .line{height:24px;line-height:24px}.highlight .gutter pre{text-align:right;padding-right:0;padding-left:0;color:#ccc}.header{background-color:#fbfbfb}.sidebar{background-color:#fdfdfd}.sidebar .slimContent{padding:20px}.main{position:relative;min-height:100vh;padding:15px}.main:after,.main:before{content:\" \";display:table}.main:after{clear:both}.footer{padding:20px;background-color:#fbfbfb;color:#999}body.main-center .sidebar,body.main-left .header,body.main-left .sidebar{left:auto;right:0;border-left:1px solid #f6f6f6;border-right:0}body.main-left .footer{left:auto;right:0}body.no-sidebar .sidebar{display:none!important}.main-nav{float:none!important}.main-nav>li{display:block;width:100%;position:relative}.main-nav>li>a{color:#555}.main-nav>li .menu-title{margin-left:15px}.main-nav>.active a,.main-nav>.active a:focus,.main-nav>.active a:hover{color:#333;background:#f4f4f4}.profile-block{padding:20px 15px 10px}#avatar{width:64px;height:64px;display:inline-block}#avatar img{width:100%;max-height:100%;height:auto!important}#name{font-size:18px;margin-top:10px;margin-bottom:0}#title{font-size:13px;margin-top:5px;margin-bottom:5px}.sidebar-form{border-radius:3px;border:1px solid #eee;margin:0 15px 15px}.sidebar-form .btn,.sidebar-form input[type=text]{-webkit-box-shadow:none;box-shadow:none;background-color:transparent;border:1px solid transparent;height:32px}.sidebar-form .btn:focus,.sidebar-form input[type=text]:focus{outline:0}.sidebar-form input[type=text]{color:#666;border-radius:2px 0 0 2px}.sidebar-form input[type=text]:focus,.sidebar-form input[type=text]:focus+.input-group-btn .btn{background-color:#fff;color:#666}.sidebar-form .btn{color:#999;border-radius:0 2px 2px 0}.header .navbar-collapse{padding-left:0;padding-right:0}.header .navbar-collapse .navbar-nav{margin:0}.header .navbar-toggle .icon-bar{background-color:#2196f3}.main .pager{text-align:left;margin:10px 0}.main .pager .disabled{cursor:not-allowed}.main .pager>.page-number,.main .pager>a{line-height:32px;float:left}.main .pager a{color:#666;border:0;line-height:32px;padding:0}.main .pager a:link,.main .pager a:visited{background-color:transparent}.main .pager a:hover{color:#0a6ebd;background-color:transparent}.main .pager .prev{margin-right:10px}.main .pager .page-number.current{color:#2196f3}.main .pager .page-number+.next,.main .pager .page-number+.page-number{margin-left:10px}.main .total-article{margin:10px 0;line-height:32px;color:#999}.main .page-header{margin-top:0}.main .article-list article{border-bottom:1px solid #f2f2f2}.main .article-list article:last-child{border-bottom:0}.main .article-meta{font-size:13px;color:#999}.main .article-meta a{color:#999}.main .article-meta a:hover{color:#0a6ebd;text-decoration:none}.main .article-meta span+span{margin-left:10px}.main .content{min-height:85vh}.main.has-sticky .content{margin-bottom:70px}#comments .gitment-footer-container,#comments .gitment-footer-project-link{display:none!important}.panel .label,.widget .label{font-weight:400}.widget:after,.widget:before{content:\" \";display:table}.widget:after{clear:both}.widget .widget-title{font-size:18px;color:#000}.widget time{color:#999;font-size:12px;text-transform:uppercase}.widget p{margin-bottom:0}.widget ul{margin-left:0;padding-left:0;list-style:none}.widget .category-link{color:#0a6ebd}.archive-list-count,.category-list-count,.tag-list-count{padding-left:5px;color:#999;font-size:.85em}.archive-list-count:before,.category-list-count:before,.tag-list-count:before{content:\"(\"}.archive-list-count:after,.category-list-count:after,.tag-list-count:after{content:\")\"}.archive-list,.category-list,.tag-list{line-height:1.75}.archive-list li:before,.category-list li:before,.tag-list li:before{color:#ccc;content:\"▪\";font-size:12px;margin-right:6px;-webkit-transition:.2s ease;transition:.2s ease}.category-list-child{padding-left:15px}.recent-post-list li+li{margin-top:15px}.recent-post-list li .item-inner,.recent-post-list li .item-thumb{display:table-cell;vertical-align:middle}.recent-post-list li .item-thumb{opacity:1;padding-right:10px;-webkit-transition:all .2s ease;transition:all .2s ease}.recent-post-list li .item-thumb .thumb{width:50px;height:50px;display:block;position:relative;overflow:hidden}.recent-post-list li .item-thumb .thumb span{width:100%;height:100%;display:block}.recent-post-list li .item-thumb .thumb .thumb-image{position:absolute;background-size:cover;background-position:center}.recent-post-list li .item-thumb .thumb .thumb-none{background-image:url(../images/thumb-default.png);background-size:100% 100%}.recent-post-list li:hover .item-thumb{opacity:.8}.sidebar-toc.collapse{display:none!important}.sidebar-toc.in{display:block!important}.tagcloud a{display:inline-block;margin-bottom:.2em;padding:.3em .6em;font-size:75%!important;line-height:1;background-color:#eee;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}.bar .pager .next>a,.bar .pager .next>span{float:none}.bar.bar-footer{position:relative;background-color:#fff;bottom:-15px}.bar.bar-footer:before{content:'';position:absolute;width:-webkit-calc(100% + 30px);width:calc(100% + 30px);height:52px;left:-15px;border-top:1px solid #f6f6f6;border-bottom:1px solid #fff;background-color:#fff}.bar .bar-inner{position:relative;z-index:9}.bar .bar-inner:after,.bar .bar-inner:before{content:\" \";display:table}.bar .bar-inner:after{clear:both}.bar .bar-right{margin:10px 0;float:right}.toggle-toc{cursor:pointer;margin-left:10px}.toggle-toc a{display:inline-block;line-height:32px;text-align:center}.footer .copyright{font-size:12px}.footer .copyright a{color:#999;text-decoration:none}.footer .copyright a:hover{color:#0a6ebd}.wave-icon{display:inline-block;position:relative}.wave-icon .wave-circle{display:block;border-radius:50%;background-color:transparent}.wave-icon .wave-circle:after,.wave-icon .wave-circle:before{content:'';border:10px solid #2196f3;background:#2196f3;border-radius:50%;position:absolute;top:50%;left:50%;z-index:1}.wave-icon .wave-circle:before{height:74px;width:74px;-webkit-animation:5s ease-out infinite pulse;animation:5s ease-out infinite pulse;margin-top:-37px;margin-left:-37px;opacity:0}.wave-icon .wave-circle:after{height:98px;width:98px;-webkit-animation:5s ease-out infinite pulse;animation:5s ease-out infinite pulse;margin-top:-49px;margin-left:-49px;opacity:.3}.wave-icon .icon{position:relative;display:block;width:50px;height:50px;line-height:50px;text-align:center;background-color:#2196f3;border-radius:50%;font-size:24px;color:#fff;z-index:2}.wave-icon.wave-icon-info .wave-circle:after,.wave-icon.wave-icon-info .wave-circle:before{border:10px solid #56ccf2;background:#56ccf2}.wave-icon.wave-icon-info .icon{background-color:#56ccf2}.wave-icon.wave-icon-primary .wave-circle:after,.wave-icon.wave-icon-primary .wave-circle:before{border:10px solid #2196f3;background:#2196f3}.wave-icon.wave-icon-primary .icon{background-color:#2196f3}.wave-icon.wave-icon-warning .wave-circle:after,.wave-icon.wave-icon-warning .wave-circle:before{border:10px solid #f09819;background:#f09819}.wave-icon.wave-icon-warning .icon{background-color:#f09819}.wave-icon.wave-icon-success .wave-circle:after,.wave-icon.wave-icon-success .wave-circle:before{border:10px solid #5cb85c;background:#5cb85c}.wave-icon.wave-icon-success .icon{background-color:#5cb85c}.wave-icon.wave-icon-danger .wave-circle:after,.wave-icon.wave-icon-danger .wave-circle:before{border:10px solid #ff512f;background:#ff512f}.wave-icon.wave-icon-danger .icon{background-color:#ff512f}@-webkit-keyframes pulse{0%{-webkit-transform:scale(0);opacity:0}25%{-webkit-transform:scale(0);opacity:.1}50%{-webkit-transform:scale(.1);opacity:.3}75%{-webkit-transform:scale(.5);opacity:.5}100%{-webkit-transform:scale(1);opacity:0}}.repo-list{list-style:none;padding-left:0}.repo{position:relative;list-style-type:none;border:1px solid #f2f2f2;margin-bottom:15px;overflow:hidden}.repo-title{padding:0 15px;margin:15px 0;font-size:16px;font-weight:600}.repo-body{display:-webkit-box;padding:0 15px;margin:0 0 20px;overflow:hidden;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:2;line-height:1.5em;height:3em;word-break:break-all!important;word-wrap:break-word!important}.repo-image{position:relative;display:table;width:101%;height:3px;margin:-1px -1px 15px;background-color:#666}.repo-meta{padding:0 15px;margin-top:5px;margin-bottom:15px;color:#777;font-size:12px;text-align:right}.repo-meta:after,.repo-meta:before{content:\" \";display:table}.repo-meta:after{clear:both}.repo-meta .meta+.meta{margin-left:15px}.text-collapsed{display:none}.collapsed .text-collapsed,.text-in{display:inline-block}.collapsed .text-in{display:none}.sub-header{padding-bottom:10px;border-bottom:1px solid #eee}.article-header{margin-bottom:20px}.article-footer{margin-top:20px}.collection{position:relative}.collection a.collection-item{display:block;-webkit-transition:.25s;transition:.25s;color:#777}.collection a:not(.active):hover{color:#333}.collection .collection-item{padding:8px 0;margin:0}.article-list .article-title{font-size:18px}.article-toc .toc-title{font-size:18px;color:#000}.article-toc .toc{list-style:none;padding-left:0;line-height:2}.article-toc .toc ol{list-style:none;padding-left:10px}.article-toc .toc .toc-item{position:relative}.article-toc .toc .toc-item .markdownIt-Anchor{position:absolute;left:0;right:0;top:0;padding:14px 0}.marked-body h1,.marked-body h2,.marked-body h3,.marked-body h4,.marked-body h5,.marked-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.marked-body h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #f2f2f2}.marked-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #f2f2f2}.marked-body a{color:#2196f3;text-decoration:none}.marked-body a:focus,.marked-body a:hover{color:#0a6ebd;text-decoration:none}.marked-body ol,.marked-body ul{padding-left:0;margin-left:20px}body.okayNav-loaded{overflow-x:hidden}.okayNav{position:relative}.okayNav:after,.okayNav:before{content:\" \";display:table}.okayNav:after{clear:both}.okayNav:not(.loaded){visibility:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.okayNav ul{float:left;padding-left:0}.okayNav ul li{display:inline-block;margin-left:15px}.okayNav a{position:relative;z-index:1;color:#2e2e33;font-weight:400}.okayNav a.active{color:#0a6ebd}.okayNav__nav--visible{overflow:hidden;white-space:nowrap}.okayNav__nav--visible li{display:inline-block;margin-left:15px}.okayNav__nav--visible li:first-child{margin-left:0}.okayNav__nav--visible a{display:block;-webkit-transition:color .2s cubic-bezier(.55,0,.1,1);transition:color .2s cubic-bezier(.55,0,.1,1)}.okayNav__nav--visible:empty~.okayNav__menu-toggle{top:0}.okayNav__nav--invisible{display:none;position:absolute;width:100%;top:24px;overflow-y:auto;-webkit-overflow-scrolling:touch;-webkit-box-shadow:0 1px 2px rgba(0,0,0,.05);box-shadow:0 1px 2px rgba(0,0,0,.05);padding-top:15px;padding-bottom:15px;background:#fff}.okayNav__nav--invisible li{display:inline-block}.okayNav__nav--invisible li a{display:block;padding:6px 15px;min-width:100px}.okayNav__nav--invisible.nav-left{left:0}.okayNav__nav--invisible.nav-right{right:0}.okayNav__nav--invisible.transition-enabled{-webkit-transition:-webkit-transform .4s cubic-bezier(.55,0,.1,1);transition:-webkit-transform .4s cubic-bezier(.55,0,.1,1);transition:transform .4s cubic-bezier(.55,0,.1,1);transition:transform .4s cubic-bezier(.55,0,.1,1),-webkit-transform .4s cubic-bezier(.55,0,.1,1)}.okayNav__nav--invisible.nav-open{display:block;z-index:99;border:1px solid #f2f2f2}.okayNav__menu-toggle{position:relative;z-index:1;float:right;cursor:pointer;-webkit-transition:-webkit-transform .4s cubic-bezier(.55,0,.1,1);transition:-webkit-transform .4s cubic-bezier(.55,0,.1,1);transition:transform .4s cubic-bezier(.55,0,.1,1);transition:transform .4s cubic-bezier(.55,0,.1,1),-webkit-transform .4s cubic-bezier(.55,0,.1,1)}.okayNav__menu-toggle.okay-invisible{position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;opacity:0}.okayNav__menu-toggle span{background:#666;display:inline-block;width:2px;height:2px;margin:auto 1px;pointer-events:none;border-radius:50%;vertical-align:middle}.okayNav__menu-toggle.icon--active span{background:#0a6ebd}.okayNav a:hover{color:#0a6ebd}.social-links{list-style:none;padding:0;text-align:left}.social-links li{list-style:none;display:inline-block;margin-left:10px}.social-links li:first-child{margin-left:0}.header .social-links{padding:10px 20px}.footer .social-links{margin-bottom:5px}@font-face{font-family:socialshare;src:url(../fonts/iconfont.eot);src:url(../fonts/iconfont.eot?#iefix) format(\"embedded-opentype\"),url(../fonts/iconfont.woff) format(\"woff\"),url(../fonts/iconfont.ttf) format(\"truetype\"),url(../fonts/iconfont.svg#iconfont) format(\"svg\")}.social-share{display:inline-block;font-size:16px}.social-share a{position:relative;text-decoration:none;margin-left:16px;display:inline-block;outline:0;line-height:32px}.social-share .social-share-icon{position:relative;display:inline-block;height:32px;line-height:32px;color:#999;text-align:center;vertical-align:middle;-webkit-transition:background .6s ease-out 0s;transition:background .6s ease-out 0s}.social-share .social-share-icon:hover{color:#666}.social-share .icon-weibo:hover{color:#ff763b}.social-share .icon-qq:hover,.social-share .icon-tencent:hover{color:#56b6e7}.social-share .icon-qzone:hover{color:#fdbe3d}.social-share .icon-douban:hover{color:#33b045}.social-share .icon-linkedin:hover{color:#0077b5}.social-share .icon-facebook:hover{color:#44619d}.social-share .icon-google:hover{color:#db4437}.social-share .icon-twitter:hover{color:#55acee}.social-share .icon-diandian:hover{color:#307dca}.social-share .icon-wechat{position:relative}.social-share .icon-wechat:hover{color:#7bc549}.social-share .icon-wechat .wechat-qrcode{display:none;border:1px solid #eee;position:absolute;z-index:9;top:-209px;left:-90px;width:200px;height:200px;color:#666;font-size:12px;text-align:center;background-color:#fff;-webkit-transition:all .2s;transition:all .2s;-webkit-tansition:all 350ms;-moz-transition:all 350ms}.social-share .icon-wechat .wechat-qrcode.bottom{top:40px;left:-84px}.social-share .icon-wechat .wechat-qrcode.bottom:after{display:none}.social-share .icon-wechat .wechat-qrcode h4{font-weight:400;height:26px;line-height:26px;font-size:12px;background-color:#f3f3f3;margin:0;padding:0;color:#777}.social-share .icon-wechat .wechat-qrcode .qrcode{width:105px;margin:15px auto}.social-share .icon-wechat .wechat-qrcode .qrcode table{margin:0!important}.social-share .icon-wechat .wechat-qrcode .help p{font-weight:400;line-height:16px;padding:0;margin:0}.social-share .icon-wechat .wechat-qrcode:before{content:'';position:absolute;left:50%;margin-left:-6px;bottom:-15px;width:0;height:0;border-width:8px 6px 6px;border-style:solid;border-color:#eee transparent transparent}.social-share .icon-wechat .wechat-qrcode:after{content:'';position:absolute;left:50%;margin-left:-6px;bottom:-13px;width:0;height:0;border-width:8px 6px 6px;border-style:solid;border-color:#fff transparent transparent}.social-share .icon-wechat:hover .wechat-qrcode{display:block}.btn-donate{position:absolute;bottom:10px;left:50%;margin-left:-25px;width:50px;height:50px;line-height:50px;padding:0;border-radius:50%;font-size:18px;cursor:pointer;z-index:99}.btn-donate:active,.btn-donate:focus,.btn-donate:hover{border-color:transparent!important;outline:0!important}.btn-donate.btn-fancy{background-color:transparent}.btn-donate.btn-fancy span{width:50px;height:50px;padding:0}.donate{overflow:hidden}.donate-box{text-align:center;padding-top:30px}.donate-box .donate-head{width:100%;height:80px;text-align:center;line-height:60px;color:#a3a3a3;font-size:16px;position:relative}.donate-box .donate-head:after,.donate-box .donate-head:before{font-family:Arial,Helvetica,sans-serif;background:0 0;width:0;height:0;font-style:normal;color:#eee;font-size:100px;position:absolute;top:15px}.donate-box .donate-head:before{content:'\\201c';left:30px}.donate-box .donate-head:after{content:'\\201d';right:70px}.donate-box .donate-footer{padding-top:35px}.donate-box .donate-payimg{display:inline-block;padding:10px;border:6px solid #ea5f00;margin:0 auto;border-radius:3px}.donate-box .donate-payimg img{display:block;text-align:center;width:140px;height:140px}.book .media-middle{display:inline-block;width:115px}.ins-search{display:none}.ins-search.show{display:block}.ins-selectable{cursor:pointer}.ins-search-container,.ins-search-mask{position:fixed}.ins-search-mask{top:0;left:0;width:100%;height:100%;z-index:1050;background:rgba(0,0,0,.5)}.ins-input-wrapper{position:relative}.ins-search-input{width:100%;border:none;outline:0;font-size:16px;-webkit-box-shadow:none;box-shadow:none;font-weight:200;border-radius:0;background:#fff;line-height:20px;-webkit-box-sizing:border-box;box-sizing:border-box;padding:12px 28px 12px 20px;border-bottom:1px solid #e2e2e2;font-family:\"Microsoft Yahei Light\",\"Microsoft Yahei\",Helvetica,Arial,sans-serif}.ins-close{top:50%;right:6px;width:20px;height:20px;font-size:24px;margin-top:-15px;position:absolute;text-align:center;opacity:1;color:#666;display:inline-block}.ins-close:hover{color:#006bde}.ins-search-container{left:50%;top:100px;z-index:1051;bottom:100px;-webkit-box-sizing:border-box;box-sizing:border-box;width:540px;margin-left:-270px}.ins-section-wrapper{left:0;right:0;top:45px;bottom:0;overflow-y:auto;position:absolute}.ins-section-container{position:relative;background:#f7f7f7}.ins-section{font-size:14px;line-height:16px}.ins-section .ins-search-item,.ins-section .ins-section-header{padding:8px 15px}.ins-section .ins-section-header{color:#9a9a9a;border-bottom:1px solid #e2e2e2}.ins-section .ins-slug{margin-left:5px;color:#9a9a9a}.ins-section .ins-slug:before{content:'('}.ins-section .ins-slug:after{content:')'}.ins-section .ins-search-item .ins-search-preview,.ins-section .ins-search-item header{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.ins-section .ins-search-item header .icon{margin-right:8px}.ins-section .ins-search-item .ins-search-preview{height:15px;font-size:12px;color:#9a9a9a;margin:5px 0 0 20px}.ins-section .ins-search-item.active,.ins-section .ins-search-item:hover{color:#fff;background:#006bde}.ins-section .ins-search-item.active .ins-search-preview,.ins-section .ins-search-item.active .ins-slug,.ins-section .ins-search-item:hover .ins-search-preview,.ins-section .ins-search-item:hover .ins-slug,.theme-black .header,.theme-blue .header,.theme-green .header,.theme-purple .header{color:#fff}.theme-black .header a,.theme-blue .header a,.theme-green .header a,.theme-purple .header a{color:#efefef}.theme-black .header #location,.theme-blue .header #location,.theme-green .header #location,.theme-purple .header #location{color:rgba(255,255,255,.75)!important}.theme-black .header .navbar-toggle .icon-bar,.theme-blue .header .navbar-toggle .icon-bar,.theme-green .header .navbar-toggle .icon-bar,.theme-purple .header .navbar-toggle .icon-bar{background-color:#fff}.theme-black .footer,.theme-black .footer a,.theme-blue .footer,.theme-blue .footer a,.theme-green .footer,.theme-green .footer a,.theme-purple .footer,.theme-purple .footer a{color:rgba(255,255,255,.75)}.theme-black .footer a.active,.theme-black .footer a:focus,.theme-black .footer a:hover,.theme-black .header a.active,.theme-black .header a:focus,.theme-black .header a:hover,.theme-blue .footer a.active,.theme-blue .footer a:focus,.theme-blue .footer a:hover,.theme-blue .header a.active,.theme-blue .header a:focus,.theme-blue .header a:hover,.theme-green .footer a.active,.theme-green .footer a:focus,.theme-green .footer a:hover,.theme-green .header a.active,.theme-green .header a:focus,.theme-green .header a:hover,.theme-purple .footer a.active,.theme-purple .footer a:focus,.theme-purple .footer a:hover,.theme-purple .header a.active,.theme-purple .header a:focus,.theme-purple .header a:hover{color:#fff}.theme-black .main-nav>li>a.active,.theme-black .main-nav>li>a:focus,.theme-black .main-nav>li>a:hover,.theme-blue .main-nav>li>a.active,.theme-blue .main-nav>li>a:focus,.theme-blue .main-nav>li>a:hover,.theme-green .main-nav>li>a.active,.theme-green .main-nav>li>a:focus,.theme-green .main-nav>li>a:hover,.theme-purple .main-nav>li>a.active,.theme-purple .main-nav>li>a:focus,.theme-purple .main-nav>li>a:hover{color:#fff;background:rgba(0,0,0,.15)}.theme-black .main-nav>.active a,.theme-black .main-nav>.active a.active,.theme-black .main-nav>.active a:focus,.theme-black .main-nav>.active a:hover,.theme-blue .main-nav>.active a,.theme-blue .main-nav>.active a.active,.theme-blue .main-nav>.active a:focus,.theme-blue .main-nav>.active a:hover,.theme-green .main-nav>.active a,.theme-green .main-nav>.active a.active,.theme-green .main-nav>.active a:focus,.theme-green .main-nav>.active a:hover,.theme-purple .main-nav>.active a,.theme-purple .main-nav>.active a.active,.theme-purple .main-nav>.active a:focus,.theme-purple .main-nav>.active a:hover{color:#fff;background:rgba(0,0,0,.2)}.theme-black .search .sidebar-form,.theme-blue .search .sidebar-form,.theme-green .search .sidebar-form,.theme-purple .search .sidebar-form{border:0;background:rgba(0,0,0,.2)}.theme-black .search .sidebar-form input::-webkit-input-placeholder,.theme-blue .search .sidebar-form input::-webkit-input-placeholder,.theme-green .search .sidebar-form input::-webkit-input-placeholder,.theme-purple .search .sidebar-form input::-webkit-input-placeholder{color:rgba(255,255,255,.5)}.theme-black .search .sidebar-form input:-moz-placeholder,.theme-blue .search .sidebar-form input:-moz-placeholder,.theme-green .search .sidebar-form input:-moz-placeholder,.theme-purple .search .sidebar-form input:-moz-placeholder{color:rgba(255,255,255,.5)}.theme-black .search .sidebar-form input::-moz-placeholder,.theme-blue .search .sidebar-form input::-moz-placeholder,.theme-green .search .sidebar-form input::-moz-placeholder,.theme-purple .search .sidebar-form input::-moz-placeholder{color:rgba(255,255,255,.5)}.theme-black .search .sidebar-form input:-ms-input-placeholder,.theme-blue .search .sidebar-form input:-ms-input-placeholder,.theme-green .search .sidebar-form input:-ms-input-placeholder,.theme-purple .search .sidebar-form input:-ms-input-placeholder{color:rgba(255,255,255,.5)}.theme-black .search input[type=text],.theme-blue .search input[type=text],.theme-green .search input[type=text],.theme-purple .search input[type=text]{color:#666}.theme-black .search input[type=text]+.input-group-btn .btn,.theme-blue .search input[type=text]+.input-group-btn .btn,.theme-green .search input[type=text]+.input-group-btn .btn,.theme-purple .search input[type=text]+.input-group-btn .btn{color:rgba(255,255,255,.5)}.theme-black .search input[type=text]:focus,.theme-black .search input[type=text]:focus+.input-group-btn .btn,.theme-blue .search input[type=text]:focus,.theme-blue .search input[type=text]:focus+.input-group-btn .btn,.theme-green .search input[type=text]:focus,.theme-green .search input[type=text]:focus+.input-group-btn .btn,.theme-purple .search input[type=text]:focus,.theme-purple .search input[type=text]:focus+.input-group-btn .btn{background-color:#fff;color:#666}.theme-black .header{background:#1a2433;background:-webkit-linear-gradient(left,#1a2433 0,#253449 80%,#253449 100%);background:-webkit-gradient(linear,left top,right top,from(#1a2433),color-stop(80%,#253449),to(#253449));background:linear-gradient(to right,#1a2433 0,#253449 80%,#253449 100%)}.theme-blue .header{background:#0062c5;background:-webkit-linear-gradient(left,#0062c5 0,#0073e6 80%,#0073e6 100%);background:-webkit-gradient(linear,left top,right top,from(#0062c5),color-stop(80%,#0073e6),to(#0073e6));background:linear-gradient(to right,#0062c5 0,#0073e6 80%,#0073e6 100%)}.theme-green .header{background:#08a283;background:-webkit-linear-gradient(left,#08a283 0,#0ac29d 80%,#0ac29d 100%);background:-webkit-gradient(linear,left top,right top,from(#08a283),color-stop(80%,#0ac29d),to(#0ac29d));background:linear-gradient(to right,#08a283 0,#0ac29d 80%,#0ac29d 100%)}.theme-purple .header{background:#494683;background:-webkit-linear-gradient(left,#494683 0,#555299 80%,#555299 100%);background:-webkit-gradient(linear,left top,right top,from(#494683),color-stop(80%,#555299),to(#555299));background:linear-gradient(to right,#494683 0,#555299 80%,#555299 100%)}@media (min-width:767px){.modal-center{text-align:center;padding:0!important}.modal-center:before{content:'';display:inline-block;height:100%;vertical-align:middle;margin-right:-4px}.modal-center .modal-dialog{display:inline-block;text-align:left;vertical-align:middle}.donate-box .donate-footer{margin:0 -15px -16px}}@media (min-width:768px){.lead{font-size:21px}.dl-horizontal dt{float:left;width:160px;clear:left;text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}.container{width:750px}.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-1{width:8.33333%}.col-sm-2{width:16.66667%}.col-sm-3{width:25%}.col-sm-4{width:33.33333%}.col-sm-5{width:41.66667%}.col-sm-6{width:50%}.col-sm-7{width:58.33333%}.col-sm-8{width:66.66667%}.col-sm-9{width:75%}.col-sm-10{width:83.33333%}.col-sm-11{width:91.66667%}.col-sm-12{width:100%}.col-sm-pull-0{right:auto}.col-sm-pull-1{right:8.33333%}.col-sm-pull-2{right:16.66667%}.col-sm-pull-3{right:25%}.col-sm-pull-4{right:33.33333%}.col-sm-pull-5{right:41.66667%}.col-sm-pull-6{right:50%}.col-sm-pull-7{right:58.33333%}.col-sm-pull-8{right:66.66667%}.col-sm-pull-9{right:75%}.col-sm-pull-10{right:83.33333%}.col-sm-pull-11{right:91.66667%}.col-sm-pull-12{right:100%}.col-sm-push-0{left:auto}.col-sm-push-1{left:8.33333%}.col-sm-push-2{left:16.66667%}.col-sm-push-3{left:25%}.col-sm-push-4{left:33.33333%}.col-sm-push-5{left:41.66667%}.col-sm-push-6{left:50%}.col-sm-push-7{left:58.33333%}.col-sm-push-8{left:66.66667%}.col-sm-push-9{left:75%}.col-sm-push-10{left:83.33333%}.col-sm-push-11{left:91.66667%}.col-sm-push-12{left:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333%}.col-sm-offset-2{margin-left:16.66667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333%}.col-sm-offset-5{margin-left:41.66667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333%}.col-sm-offset-8{margin-left:66.66667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333%}.col-sm-offset-11{margin-left:91.66667%}.col-sm-offset-12{margin-left:100%}.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{left:0;right:auto}.nav-justified>li,.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a,.nav-tabs.nav-justified>li>a{margin-bottom:0}.nav-tabs-justified>li>a,.nav-tabs.nav-justified>li>a{border-bottom:1px solid #f2f2f2;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover,.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}.navbar{border-radius:4px}.navbar-header{float:left}.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-left:0;padding-right:0}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}.navbar-fixed-bottom,.navbar-fixed-top,.navbar-static-top{border-radius:0}.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}.navbar-toggle{display:none}.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:14.5px;padding-bottom:14.5px}.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}.navbar-form{width:auto;border:0;margin-left:0;margin-right:0;padding-top:0;padding-bottom:0;-webkit-box-shadow:none;box-shadow:none}.navbar-text{float:left;margin-left:15px;margin-right:15px}.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.05);box-shadow:0 5px 15px rgba(0,0,0,.05)}.modal-sm{width:300px}.header{position:fixed;top:0;bottom:0;left:0;z-index:1000;display:block;padding:0;overflow-y:auto;border-right:1px solid #f6f6f6;width:4.16667%}.sidebar{position:fixed;top:0;bottom:0;left:0;display:block;padding:0;overflow-x:hidden;overflow-y:auto;border-right:1px solid #f6f6f6;width:33.33333%}.main{width:62.5%;padding-right:20px;padding-left:20px}.footer{position:fixed;left:0;bottom:0;background-color:transparent;z-index:1050;width:4.16667%}body.main-center .main{margin-left:4.16667%}body.main-left .sidebar{margin-right:4.16667%}body.main-right .sidebar{margin-left:4.16667%}body.main-right .main{margin-left:37.5%}body.no-sidebar.main-left .main{width:95.83333333%;margin-right:4.16667%}body.no-sidebar.main-center .main,body.no-sidebar.main-right .main{width:95.83333333%;margin-left:4.16667%}.header .navbar-header{float:none}#avatar img{padding:5px}.bar.bar-footer:before{width:-webkit-calc(100% + 40px);width:calc(100% + 40px);left:-20px}.header .social-links{display:none}}@media (min-width:992px){.container{width:970px}.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-1{width:8.33333%}.col-md-2{width:16.66667%}.col-md-3{width:25%}.col-md-4{width:33.33333%}.col-md-5{width:41.66667%}.col-md-6{width:50%}.col-md-7{width:58.33333%}.col-md-8{width:66.66667%}.col-md-9{width:75%}.col-md-10{width:83.33333%}.col-md-11{width:91.66667%}.col-md-12{width:100%}.col-md-pull-0{right:auto}.col-md-pull-1{right:8.33333%}.col-md-pull-2{right:16.66667%}.col-md-pull-3{right:25%}.col-md-pull-4{right:33.33333%}.col-md-pull-5{right:41.66667%}.col-md-pull-6{right:50%}.col-md-pull-7{right:58.33333%}.col-md-pull-8{right:66.66667%}.col-md-pull-9{right:75%}.col-md-pull-10{right:83.33333%}.col-md-pull-11{right:91.66667%}.col-md-pull-12{right:100%}.col-md-push-0{left:auto}.col-md-push-1{left:8.33333%}.col-md-push-2{left:16.66667%}.col-md-push-3{left:25%}.col-md-push-4{left:33.33333%}.col-md-push-5{left:41.66667%}.col-md-push-6{left:50%}.col-md-push-7{left:58.33333%}.col-md-push-8{left:66.66667%}.col-md-push-9{left:75%}.col-md-push-10{left:83.33333%}.col-md-push-11{left:91.66667%}.col-md-push-12{left:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333%}.col-md-offset-2{margin-left:16.66667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333%}.col-md-offset-5{margin-left:41.66667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333%}.col-md-offset-8{margin-left:66.66667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333%}.col-md-offset-11{margin-left:91.66667%}.col-md-offset-12{margin-left:100%}.modal-lg{width:900px}.header{width:16.66667%}.sidebar{width:25%}.sidebar .slimContent{padding-right:25px;padding-left:25px}.main{width:58.33333%;padding-right:25px;padding-left:25px}.footer{width:16.66667%}body.main-center .main{margin-left:16.66667%}body.main-left .sidebar{margin-right:16.66667%}body.main-right .sidebar{margin-left:16.66667%}body.main-right .main{margin-left:41.66667%}body.no-sidebar.main-left .main{width:83.33333333%;margin-right:16.66667%}body.no-sidebar.main-center .main,body.no-sidebar.main-right .main{width:83.33333333%;margin-left:16.66667%}.bar.bar-footer:before{width:-webkit-calc(100% + 50px);width:calc(100% + 50px);left:-25px}.marked-body .headerlink:before,.marked-body .markdownIt-Anchor:before{display:inline-block;width:18px;content:\"#\";color:#0a6ebd;text-align:right;float:left;visibility:hidden}.marked-body .headerlink:before{margin-left:-15px;padding-right:2px}.marked-body .markdownIt-Anchor:before{margin-left:-20px}.marked-body h1:hover .headerlink:before,.marked-body h1:hover .markdownIt-Anchor:before,.marked-body h2:hover .headerlink:before,.marked-body h2:hover .markdownIt-Anchor:before,.marked-body h3:hover .headerlink:before,.marked-body h3:hover .markdownIt-Anchor:before,.marked-body h4:hover .headerlink:before,.marked-body h4:hover .markdownIt-Anchor:before,.marked-body h5:hover .headerlink:before,.marked-body h5:hover .markdownIt-Anchor:before,.marked-body h6:hover .headerlink:before,.marked-body h6:hover .markdownIt-Anchor:before{visibility:visible}}@media (min-width:1200px){.container{width:1170px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-1{width:8.33333%}.col-lg-2{width:16.66667%}.col-lg-3{width:25%}.col-lg-4{width:33.33333%}.col-lg-5{width:41.66667%}.col-lg-6{width:50%}.col-lg-7{width:58.33333%}.col-lg-8{width:66.66667%}.col-lg-9{width:75%}.col-lg-10{width:83.33333%}.col-lg-11{width:91.66667%}.col-lg-12{width:100%}.col-lg-pull-0{right:auto}.col-lg-pull-1{right:8.33333%}.col-lg-pull-2{right:16.66667%}.col-lg-pull-3{right:25%}.col-lg-pull-4{right:33.33333%}.col-lg-pull-5{right:41.66667%}.col-lg-pull-6{right:50%}.col-lg-pull-7{right:58.33333%}.col-lg-pull-8{right:66.66667%}.col-lg-pull-9{right:75%}.col-lg-pull-10{right:83.33333%}.col-lg-pull-11{right:91.66667%}.col-lg-pull-12{right:100%}.col-lg-push-0{left:auto}.col-lg-push-1{left:8.33333%}.col-lg-push-2{left:16.66667%}.col-lg-push-3{left:25%}.col-lg-push-4{left:33.33333%}.col-lg-push-5{left:41.66667%}.col-lg-push-6{left:50%}.col-lg-push-7{left:58.33333%}.col-lg-push-8{left:66.66667%}.col-lg-push-9{left:75%}.col-lg-push-10{left:83.33333%}.col-lg-push-11{left:91.66667%}.col-lg-push-12{left:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333%}.col-lg-offset-2{margin-left:16.66667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333%}.col-lg-offset-5{margin-left:41.66667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333%}.col-lg-offset-8{margin-left:66.66667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333%}.col-lg-offset-11{margin-left:91.66667%}.col-lg-offset-12{margin-left:100%}.visible-lg{display:block!important}table.visible-lg{display:table!important}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}.visible-lg-block{display:block!important}.visible-lg-inline{display:inline!important}.visible-lg-inline-block{display:inline-block!important}.hidden-lg{display:none!important}.header{width:16.66667%}.sidebar{width:23%}.sidebar .slimContent{padding-right:30px;padding-left:30px}.main{width:60.33333%;padding-right:30px;padding-left:30px}.footer{width:16.66667%}body.main-center .main{margin-left:16.66667%}body.main-left .sidebar{margin-right:16.66667%}body.main-right .sidebar{margin-left:16.66667%}body.main-right .main{margin-left:39.66667%}body.no-sidebar.main-left .main{width:83.33333333%;margin-right:16.66667%}body.no-sidebar.main-center .main,body.no-sidebar.main-right .main{width:83.33333333%;margin-left:16.66667%}.main-nav>li>a{padding:10px 20px}.bar.bar-footer:before{width:-webkit-calc(100% + 60px);width:calc(100% + 60px);left:-30px}}@media (min-width:1440px){.header{width:16.66667%}.sidebar{width:21%}.main{width:62.33333%}.footer{width:16.66667%}body.main-center .main{margin-left:16.66667%}body.main-left .sidebar{margin-right:16.66667%}body.main-right .sidebar{margin-left:16.66667%}body.main-right .main{margin-left:37.66667%}body.no-sidebar.main-left .main{width:83.33333333%;margin-right:16.66667%}body.no-sidebar.main-center .main,body.no-sidebar.main-right .main{width:83.33333333%;margin-left:16.66667%}.header #title{font-size:15px}}@media (max-width:1199px){.main-nav>li>a{padding:6px 20px}.bar .pager li a span,.footer .copyright{display:none}}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:21px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#090909}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#090909}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#090909}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}.visible-xs{display:block!important}table.visible-xs{display:table!important}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}.visible-xs-block{display:block!important}.visible-xs-inline{display:inline!important}.visible-xs-inline-block{display:inline-block!important}.hidden-xs{display:none!important}body{padding-top:53px}.list-circle-num,.list-square-num{margin:0 0 40px}.modal-xs-full .modal-content,.modal-xs-full .modal-dialog{height:100%;width:100%;margin:0;border-radius:0;-webkit-box-shadow:none;box-shadow:none}.modal-xs-full .modal-content .donate-box,.modal-xs-full .modal-dialog .donate-box{padding-top:50px}.highlight table:before{display:block;content:' ';height:38px;position:absolute;top:0;left:0;right:0;margin-left:-10px;margin-right:-10px;margin-top:-38px;background-color:#f6f6f6;border-top-left-radius:4px;border-top-right-radius:4px}.header{position:fixed;left:0;right:0;top:0;width:100%;z-index:1050}.header:after,.header:before{content:\" \";display:table}.header:after{clear:both}.sidebar{display:none}.main{min-height:auto}.main-nav>li>a{padding:10px 20px}.sidebar-form{border:0;margin:9px 45px 9px 0}.sidebar-form .input-group-btn .btn{color:#2196f3}.sidebar-form input[type=text]:focus{background-color:transparent}.sidebar-form input[type=text]:focus+.input-group-btn .btn{color:#2196f3;background-color:transparent}.header .navbar-toggle{position:absolute;top:0;right:0;margin-right:5px}.header .navbar-toggle .icon-bar{width:18px}.header .search{width:90%;float:right}.header .profile-block{padding:0;margin:10px 0;width:8.33333%;float:left}.header #avatar{width:32px;height:32px}.header #location,.header #name,.header #title{display:none}#main-navbar{position:absolute;width:100%;background-color:#fbfbfb;border-bottom:1px solid #f6f6f6;z-index:99}.main .content{min-height:auto}.sidebar-toc.in{position:fixed;top:50px;bottom:50px;z-index:9}.bar.bar-footer{top:auto!important;bottom:0!important}.footer{display:none;position:static}.footer .copyright{display:block}.social-links .tooltip{display:none!important;visibility:hidden}.theme-black .search input[type=text]:focus,.theme-blue .search input[type=text]:focus,.theme-green .search input[type=text]:focus,.theme-purple .search input[type=text]:focus{background-color:transparent}.theme-black .search input[type=text]:focus+.input-group-btn .btn,.theme-blue .search input[type=text]:focus+.input-group-btn .btn,.theme-green .search input[type=text]:focus+.input-group-btn .btn,.theme-purple .search input[type=text]:focus+.input-group-btn .btn{color:rgba(255,255,255,.5);background-color:transparent}.theme-black #main-navbar{background:#1a2433;background:-webkit-linear-gradient(left,#1a2433 0,#253449 80%,#253449 100%);background:-webkit-gradient(linear,left top,right top,from(#1a2433),color-stop(80%,#253449),to(#253449));background:linear-gradient(to right,#1a2433 0,#253449 80%,#253449 100%)}.theme-blue #main-navbar{background:#0062c5;background:-webkit-linear-gradient(left,#0062c5 0,#0073e6 80%,#0073e6 100%);background:-webkit-gradient(linear,left top,right top,from(#0062c5),color-stop(80%,#0073e6),to(#0073e6));background:linear-gradient(to right,#0062c5 0,#0073e6 80%,#0073e6 100%)}.theme-green #main-navbar{background:#08a283;background:-webkit-linear-gradient(left,#08a283 0,#0ac29d 80%,#0ac29d 100%);background:-webkit-gradient(linear,left top,right top,from(#08a283),color-stop(80%,#0ac29d),to(#0ac29d));background:linear-gradient(to right,#08a283 0,#0ac29d 80%,#0ac29d 100%)}.theme-purple #main-navbar{background:#494683;background:-webkit-linear-gradient(left,#494683 0,#555299 80%,#555299 100%);background:-webkit-gradient(linear,left top,right top,from(#494683),color-stop(80%,#555299),to(#555299));background:linear-gradient(to right,#494683 0,#555299 80%,#555299 100%)}}@media screen and (max-width:559px),screen and (max-height:479px){.ins-search-container{top:0;left:0;margin:0;width:100%;height:100%;background:#f7f7f7}}@media (max-width:480px){.header #avatar{width:24px;height:24px;margin-top:3px;margin-left:15px}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table!important}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}.visible-sm-block{display:block!important}.visible-sm-inline{display:inline!important}.visible-sm-inline-block{display:inline-block!important}.hidden-sm{display:none!important}.sidebar-form{display:none}.header .main-nav>li>a{text-align:center;padding-left:0;padding-right:0}.header .main-nav>li>a span{display:none}.header .profile-block{padding-top:10px;padding-left:0;padding-right:0}.header #avatar{width:32px;height:32px}.footer{padding-left:0;padding-right:0}.social-links{display:block;width:100%;text-align:center;margin-bottom:0}.social-links:after,.social-links:before{content:\" \";display:table}.social-links:after{clear:both}.social-links li{display:block;margin-left:0;margin-top:10px}.social-links li:after,.social-links li:before{content:\" \";display:table}.social-links li:after{clear:both}.social-links .tooltip{display:none!important;visibility:hidden}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table!important}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}.visible-md-block{display:block!important}.visible-md-inline{display:inline!important}.visible-md-inline-block{display:inline-block!important}.hidden-md{display:none!important}}@media print{*,:after,:before{background:0 0!important;color:#000!important;-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}a[href^=\"#\"]:after,a[href^=\"javascript:\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}.visible-print{display:block!important}table.visible-print{display:table!important}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}.visible-print-block{display:block!important}.visible-print-inline{display:inline!important}.visible-print-inline-block{display:inline-block!important}.hidden-print{display:none!important}}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}"},{"title":"","date":"2022-06-24T17:19:04.513Z","updated":"2022-06-24T17:19:04.513Z","comments":true,"path":"js/insight.js","permalink":"http://fyupeng.github.io/js/insight.js","excerpt":"","text":"/** * Insight search plugin * @author PPOffice { @link https://github.com/ppoffice } */ (function ($, CONFIG) { var $main = $('.ins-search'); var $input = $main.find('.ins-search-input'); var $wrapper = $main.find('.ins-section-wrapper'); var $container = $main.find('.ins-section-container'); $main.parent().remove('.ins-search'); $('body').append($main); function section (title) { return $('').addClass('ins-section') .append($('').addClass('ins-section-header').text(title)); } function searchItem (icon, title, slug, preview, url) { return $('').addClass('ins-selectable').addClass('ins-search-item') .append($('').append($('').addClass('icon').addClass('icon-' + icon)).append(title != null && title != '' ? title : CONFIG.TRANSLATION['UNTITLED']) .append(slug ? $('').addClass('ins-slug').text(slug) : null)) .append(preview ? $('').addClass('ins-search-preview').text(preview) : null) .attr('data-url', url); } function sectionFactory (type, array) { var sectionTitle; var $searchItems; if (array.length === 0) return null; sectionTitle = CONFIG.TRANSLATION[type]; switch (type) { case 'POSTS': case 'PAGES': $searchItems = array.map(function (item) { // Use config.root instead of permalink to fix url issue return searchItem('file', item.title, null, item.text.slice(0, 150), CONFIG.ROOT_URL + item.path); }); break; case 'CATEGORIES': case 'TAGS': $searchItems = array.map(function (item) { return searchItem(type === 'CATEGORIES' ? 'folder' : 'tag', item.name, item.slug, null, item.permalink); }); break; default: return null; } return section(sectionTitle).append($searchItems); } function extractToSet (json, key) { var values = {}; var entries = json.pages.concat(json.posts); entries.forEach(function (entry) { if (entry[key]) { entry[key].forEach(function (value) { values[value.name] = value; }); } }); var result = []; for (var key in values) { result.push(values[key]); } return result; } function parseKeywords (keywords) { return keywords.split(' ').filter(function (keyword) { return !!keyword; }).map(function (keyword) { return keyword.toUpperCase(); }); } /** * Judge if a given post/page/category/tag contains all of the keywords. * @param Object obj Object to be weighted * @param Array fields Object's fields to find matches */ function filter (keywords, obj, fields) { var result = false; var keywordArray = parseKeywords(keywords); var containKeywords = keywordArray.filter(function (keyword) { var containFields = fields.filter(function (field) { if (!obj.hasOwnProperty(field)) return false; if (obj[field].toUpperCase().indexOf(keyword) > -1) return true; }); if (containFields.length > 0) return true; return false; }); return containKeywords.length === keywordArray.length; } function filterFactory (keywords) { return { POST: function (obj) { return filter(keywords, obj, ['title', 'text']); }, PAGE: function (obj) { return filter(keywords, obj, ['title', 'text']); }, CATEGORY: function (obj) { return filter(keywords, obj, ['name', 'slug']); }, TAG: function (obj) { return filter(keywords, obj, ['name', 'slug']); } }; } /** * Calculate the weight of a matched post/page/category/tag. * @param Object obj Object to be weighted * @param Array fields Object's fields to find matches * @param Array weights Weight of every field */ function weight (keywords, obj, fields, weights) { var value = 0; parseKeywords(keywords).forEach(function (keyword) { var pattern = new RegExp(keyword, 'img'); // Global, Multi-line, Case-insensitive fields.forEach(function (field, index) { if (obj.hasOwnProperty(field)) { var matches = obj[field].match(pattern); value += matches ? matches.length * weights[index] : 0; } }); }); return value; } function weightFactory (keywords) { return { POST: function (obj) { return weight(keywords, obj, ['title', 'text'], [3, 1]); }, PAGE: function (obj) { return weight(keywords, obj, ['title', 'text'], [3, 1]); }, CATEGORY: function (obj) { return weight(keywords, obj, ['name', 'slug'], [1, 1]); }, TAG: function (obj) { return weight(keywords, obj, ['name', 'slug'], [1, 1]); } }; } function search (json, keywords) { var WEIGHTS = weightFactory(keywords); var FILTERS = filterFactory(keywords); var posts = json.posts; var pages = json.pages; var tags = extractToSet(json, 'tags'); var categories = extractToSet(json, 'categories'); return { posts: posts.filter(FILTERS.POST).sort(function (a, b) { return WEIGHTS.POST(b) - WEIGHTS.POST(a); }).slice(0, 5), pages: pages.filter(FILTERS.PAGE).sort(function (a, b) { return WEIGHTS.PAGE(b) - WEIGHTS.PAGE(a); }).slice(0, 5), categories: categories.filter(FILTERS.CATEGORY).sort(function (a, b) { return WEIGHTS.CATEGORY(b) - WEIGHTS.CATEGORY(a); }).slice(0, 5), tags: tags.filter(FILTERS.TAG).sort(function (a, b) { return WEIGHTS.TAG(b) - WEIGHTS.TAG(a); }).slice(0, 5) }; } function searchResultToDOM (searchResult) { $container.empty(); for (var key in searchResult) { $container.append(sectionFactory(key.toUpperCase(), searchResult[key])); } } function scrollTo ($item) { if ($item.length === 0) return; var wrapperHeight = $wrapper[0].clientHeight; var itemTop = $item.position().top - $wrapper.scrollTop(); var itemBottom = $item[0].clientHeight + $item.position().top; if (itemBottom > wrapperHeight + $wrapper.scrollTop()) { $wrapper.scrollTop(itemBottom - $wrapper[0].clientHeight); } if (itemTop < 0) { $wrapper.scrollTop($item.position().top); } } function selectItemByDiff (value) { var $items = $.makeArray($container.find('.ins-selectable')); var prevPosition = -1; $items.forEach(function (item, index) { if ($(item).hasClass('active')) { prevPosition = index; return; } }); var nextPosition = ($items.length + prevPosition + value) % $items.length; $($items[prevPosition]).removeClass('active'); $($items[nextPosition]).addClass('active'); scrollTo($($items[nextPosition])); } function gotoLink ($item) { if ($item && $item.length) { location.href = $item.attr('data-url'); } } $.getJSON(CONFIG.CONTENT_URL, function (json) { if (location.hash.trim() === '#ins-search') { $main.addClass('show'); } $input.on('input', function () { var keywords = $(this).val(); searchResultToDOM(search(json, keywords)); }); $input.trigger('input'); }); $(document).on('click focus', '.search-form-input', function () { $main.addClass('show'); $main.find('.ins-search-input').focus(); }).on('click', '.ins-search-item', function () { gotoLink($(this)); }).on('click', '.ins-close', function () { $main.removeClass('show'); }).on('keydown', function (e) { if (!$main.hasClass('show')) return; switch (e.keyCode) { case 27: // ESC $main.removeClass('show'); break; case 38: // UP selectItemByDiff(-1); break; case 40: // DOWN selectItemByDiff(1); break; case 13: //ENTER gotoLink($container.find('.ins-selectable.active').eq(0)); break; } }); })(jQuery, window.INSIGHT_CONFIG);"},{"title":"","date":"2022-06-24T17:19:04.514Z","updated":"2022-06-24T17:19:04.514Z","comments":true,"path":"js/jquery.min.js","permalink":"http://fyupeng.github.io/js/jquery.min.js","excerpt":"","text":"/*! jQuery v1.12.4 | (c) jQuery Foundation | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m=\"1.12.4\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray||function(a){return\"array\"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!k.call(a,\"constructor\")&&!k.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(!l.ownFirst)for(b in a)return k.call(a,b);for(b in a);return void 0===b||k.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?i[j.call(a)]||\"object\":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(h)return h.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=e.call(arguments,2),d=function(){return a.apply(b||this,c.concat(e.call(arguments)))},d.guid=a.guid=a.guid||n.guid++,d):void 0},now:function(){return+new Date},support:l}),\"function\"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(a,b){i[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=!!a&&\"length\"in a&&a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1"},{"title":"","date":"2022-06-24T18:07:49.466Z","updated":"2022-06-24T18:07:49.466Z","comments":true,"path":"js/plugin.js","permalink":"http://fyupeng.github.io/js/plugin.js","excerpt":"","text":"/** * baiduTemplate简单好用的Javascript模板引擎 1.0.6 版本 * http://baidufe.github.com/BaiduTemplate * 开源协议：BSD License * 浏览器环境占用命名空间 baidu.template ，nodejs环境直接安装 npm install baidutemplate * @param str{String} dom结点ID，或者模板string * @param data{Object} 需要渲染的json对象，可以为空。当data为{}时，仍然返回html。 * @return 如果无data，直接返回编译后的函数；如果有data，返回html。 * @author wangxiao * @email 1988wangxiao@gmail.com */ ;(function(window){ //取得浏览器环境的baidu命名空间，非浏览器环境符合commonjs规范exports出去 //修正在nodejs环境下，采用baidu.template变量名 var baidu = typeof module === 'undefined' ? (window.baidu = window.baidu || {}) : module.exports; //模板函数（放置于baidu.template命名空间下） baidu.template = function(str, data){ //检查是否有该id的元素存在，如果有元素则获取元素的innerHTML/value，否则认为字符串为模板 var fn = (function(){ //判断如果没有document，则为非浏览器环境 if(!window.document){ return bt._compile(str); }; //HTML5规定ID可以由任何不包含空格字符的字符串组成 var element = document.getElementById(str); if (element) { //取到对应id的dom，缓存其编译后的HTML模板函数 if (bt.cache[str]) { return bt.cache[str]; }; //textarea或input则取value，其它情况取innerHTML var html = /^(textarea|input)$/i.test(element.nodeName) ? element.value : element.innerHTML; return bt._compile(html); }else{ //是模板字符串，则生成一个函数 //如果直接传入字符串作为模板，则可能变化过多，因此不考虑缓存 return bt._compile(str); }; })(); //有数据则返回HTML字符串，没有数据则返回函数 支持data={}的情况 var result = bt._isObject(data) ? fn( data ) : fn; fn = null; return result; }; //取得命名空间 baidu.template var bt = baidu.template; //标记当前版本 bt.versions = bt.versions || []; bt.versions.push('1.0.6'); //缓存 将对应id模板生成的函数缓存下来。 bt.cache = {}; //自定义分隔符，可以含有正则中的字符，可以是HTML注释开头 bt.LEFT_DELIMITER = bt.LEFT_DELIMITER||'{ %'; bt.RIGHT_DELIMITER = bt.RIGHT_DELIMITER||'% }'; //自定义默认是否转义，默认为默认自动转义 bt.ESCAPE = true; //HTML转义 bt._encodeHTML = function (source) { return String(source) .replace(/&/g,'&amp;') .replace(//g,'&gt;') .replace(/\\\\/g,'&#92;') .replace(/\"/g,'&quot;') .replace(/'/g,'&#39;'); }; //转义影响正则的字符 bt._encodeReg = function (source) { return String(source).replace(/([.*+?^=!:${}()|[\\]/\\\\])/g,'\\\\$1'); }; //转义UI UI变量使用在HTML页面标签onclick等事件函数参数中 bt._encodeEventHTML = function (source) { return String(source) .replace(/&/g,'&amp;') .replace(//g,'&gt;') .replace(/\"/g,'&quot;') .replace(/'/g,'&#39;') .replace(/\\\\\\\\/g,'\\\\') .replace(/\\\\\\//g,'\\/') .replace(/\\\\n/g,'\\n') .replace(/\\\\r/g,'\\r'); }; //将字符串拼接生成函数，即编译过程(compile) bt._compile = function(str){ var funBody = \"var _template_fun_array=[];\\nvar fn=(function(__data__){\\nvar _template_varName='';\\nfor(name in __data__){\\n_template_varName+=('var '+name+'=__data__[\\\"'+name+'\\\"];');\\n};\\neval(_template_varName);\\n_template_fun_array.push('\"+bt._analysisStr(str)+\"');\\n_template_varName=null;\\n})(_template_object);\\nfn = null;\\nreturn _template_fun_array.join('');\\n\"; return new Function(\"_template_object\",funBody); }; //判断是否是Object类型 bt._isObject = function (source) { return 'function' === typeof source || !!(source && 'object' === typeof source); }; //解析模板字符串 bt._analysisStr = function(str){ //取得分隔符 var _left_ = bt.LEFT_DELIMITER; var _right_ = bt.RIGHT_DELIMITER; //对分隔符进行转义，支持正则中的元字符，可以是HTML注释 var _left = bt._encodeReg(_left_); var _right = bt._encodeReg(_right_); str = String(str) //去掉分隔符中js注释 .replace(new RegExp(\"(\"+_left+\"[^\"+_right+\"]*)//.*\\n\",\"g\"), \"$1\") //去掉注释内容 //默认支持HTML注释，将HTML注释匹配掉的原因是用户有可能用 来做分割符 .replace(new RegExp(\"\", \"g\"),\"\") .replace(new RegExp(_left+\"\\\\*.*?\\\\*\"+_right, \"g\"),\"\") //把所有换行去掉 \\r回车符 \\t制表符 \\n换行符 .replace(new RegExp(\"[\\\\r\\\\t\\\\n]\",\"g\"), \"\") //用来处理非分隔符内部的内容中含有 斜杠 \\ 单引号 ‘ ，处理办法为HTML转义 .replace(new RegExp(_left+\"(?:(?!\"+_right+\")[\\\\s\\\\S])*\"+_right+\"|((?:(?!\"+_left+\")[\\\\s\\\\S])+)\",\"g\"),function (item, $1) { var str = ''; if($1){ //将 斜杠 单引 HTML转义 str = $1.replace(/\\\\/g,\"&#92;\").replace(/'/g,'&#39;'); while(/\"+8*h+\")\");for(c.getLengthInBits()+4=8*h)&&(c.put(o,8),!(c.getLengthInBits()>=8*h));)c.put(a,8);return C(c,n)};return w.addData=function(r){var t=c(r);p.push(t),v=null},w.isDark=function(r,t){if(0>r||r>=d||0>t||t>=d)throw new Error(r+\",\"+t);return h[r][t]},w.getModuleCount=function(){return d},w.make=function(){m(!1,y())},w.createTableTag=function(r,t){r=r||2,t=\"undefined\"==typeof t?4*r:t;var e=\"\";e+='',e+=\"\";for(var n=0;nt&&e>=n&&o>e){var i=Math.floor((t-n)/r),a=Math.floor((e-n)/r);return w.isDark(a,i)?0:1}return 1})},w};t.stringToBytes=function(r){for(var t=new Array,e=0;e>=1;return t};return f.getBCHTypeInfo=function(r){for(var t=r=t))for(var f=-1;1>=f;f+=1)0>o+f||o+f>=t||(0!=u||0!=f)&&a==r.isDark(n+u,o+f)&&(i+=1);i>5&&(e+=3+i-5)}for(var n=0;t-1>n;n+=1)for(var o=0;t-1>o;o+=1){var c=0;r.isDark(n,o)&&(c+=1),r.isDark(n+1,o)&&(c+=1),r.isDark(n,o+1)&&(c+=1),r.isDark(n+1,o+1)&&(c+=1),(0==c||4==c)&&(e+=3)}for(var n=0;t>n;n+=1)for(var o=0;t-6>o;o+=1)r.isDark(n,o)&&!r.isDark(n,o+1)&&r.isDark(n,o+2)&&r.isDark(n,o+3)&&r.isDark(n,o+4)&&!r.isDark(n,o+5)&&r.isDark(n,o+6)&&(e+=40);for(var o=0;t>o;o+=1)for(var n=0;t-6>n;n+=1)r.isDark(n,o)&&!r.isDark(n+1,o)&&r.isDark(n+2,o)&&r.isDark(n+3,o)&&r.isDark(n+4,o)&&!r.isDark(n+5,o)&&r.isDark(n+6,o)&&(e+=40);for(var s=0,o=0;t>o;o+=1)for(var n=0;t>n;n+=1)r.isDark(n,o)&&(s+=1);var l=Math.abs(100*s/t/t-50)/5;return e+=10*l},f}(),a=function(){for(var r=new Array(256),t=new Array(256),e=0;8>e;e+=1)r[e]=1e;e+=1)t[r[e]]=e;var n={};return n.glog=function(r){if(1>r)throw new Error(\"glog(\"+r+\")\");return t[r]},n.gexp=function(t){for(;0>t;)t+=255;for(;t>=256;)t-=255;return r[t]},n}(),u=function(){var r=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],t=function(r,t){var e={};return e.totalCount=r,e.dataCount=t,e},e={},o=function(t,e){switch(e){case n.L:return r[4*(t-1)+0];case n.M:return r[4*(t-1)+1];case n.Q:return r[4*(t-1)+2];case n.H:return r[4*(t-1)+3];default:return}};return e.getRSBlocks=function(r,e){var n=o(r,e);if(\"undefined\"==typeof n)throw new Error(\"bad rs block @ typeNumber:\"+r+\"/errorCorrectLevel:\"+e);for(var i=n.length/3,a=new Array,u=0;i>u;u+=1)for(var f=n[3*u+0],c=n[3*u+1],s=n[3*u+2],l=0;f>l;l+=1)a.push(t(c,s));return a},e}(),f=function(){var r=new Array,t=0,e={};return e.getBuffer=function(){return r},e.getAt=function(t){var e=Math.floor(t/8);return 1==(r[e]>>>7-t%8&1)},e.put=function(r,t){for(var n=0;t>n;n+=1)e.putBit(1==(r>>>t-n-1&1))},e.getLengthInBits=function(){return t},e.putBit=function(e){var n=Math.floor(t/8);r.length>>t%8),t+=1},e},c=function(r){var n=e.MODE_8BIT_BYTE,o=t.stringToBytes(r),i={};return i.getMode=function(){return n},i.getLength=function(r){return o.length},i.write=function(r){for(var t=0;t>>8)},t.writeBytes=function(r,e,n){e=e||0,n=n||r.length;for(var o=0;n>o;o+=1)t.writeByte(r[o+e])},t.writeString=function(r){for(var e=0;er);else{if(26>r)return 65+r;if(52>r)return 97+(r-26);if(62>r)return 48+(r-52);if(62==r)return 43;if(63==r)return 47}throw new Error(\"n:\"+r)};return o.writeByte=function(n){for(r=r>>t-6),t-=6},o.flush=function(){if(t>0&&(i(ro;){if(e>=t.length){if(0==o)return-1;throw new Error(\"unexpected end of file./\"+o)}var r=t.charAt(e);if(e+=1,\"=\"==r)return o=0,-1;r.match(/^\\s$/)||(n=n>o-8&255;return o-=8,i};var a=function(r){if(r>=65&&90>=r)return r-65;if(r>=97&&122>=r)return r-97+26;if(r>=48&&57>=r)return r-48+52;if(43==r)return 62;if(47==r)return 63;throw new Error(\"c:\"+r)};return i},d=function(r,t){var e=r,n=t,o=new Array(r*t),i={};i.setPixel=function(r,t,n){o[t*e+r]=n},i.write=function(r){r.writeString(\"GIF87a\"),r.writeShort(e),r.writeShort(n),r.writeByte(128),r.writeByte(0),r.writeByte(0),r.writeByte(0),r.writeByte(0),r.writeByte(0),r.writeByte(255),r.writeByte(255),r.writeByte(255),r.writeString(\",\"),r.writeShort(0),r.writeShort(0),r.writeShort(e),r.writeShort(n),r.writeByte(0);var t=2,o=u(t);r.writeByte(t);for(var i=0;o.length-i>255;)r.writeByte(255),r.writeBytes(o,i,255),i+=255;r.writeByte(o.length-i),r.writeBytes(o,i,o.length-i),r.writeByte(0),r.writeString(\";\")};var a=function(r){var t=r,e=0,n=0,o={};return o.write=function(r,o){if(r>>>o!=0)throw new Error(\"length over\");for(;e+o>=8;)t.writeByte(255&(r>=8-e,n=0,e=0;n|=r12,128|n>>6&63,128|63&n):(e++,n=65536+((1023&n)18,128|n>>12&63,128|n>>6&63,128|63&n))}return t}return t(r)}}(r),r}()),function(r){r.fn.share=function(t){function e(t,e){var n=o(e);\"prepend\"==e.mode?n.reverse():n,n.length&&r.each(n,function(n,o){var a=i(o,e),u=e.initialized?t.find(\".icon-\"+o):r('');return!u.length||(u.prop(\"aria-label\",\"分享到 \"+h[o]),u.prop(\"href\",a),\"wechat\"===o?u.prop(\"tabindex\",-1):u.prop(\"target\",\"_blank\"),void(e.initialized||(\"prepend\"==e.mode?t.prepend(u):t.append(u))))})}function n(r,t){var e=r.find(\"a.icon-wechat\");e.length&&(e.append(''+t.wechatQrcodeTitle+''+t.wechatQrcodeHelper+\"\"),e.find(\".qrcode\").qrcode({render:\"image\",size:t.wechatQrcodeSize,text:t.url}),e.offset().top"},{"title":"友情链接","date":"2022-06-24T18:09:11.563Z","updated":"2022-06-24T18:09:11.563Z","comments":true,"path":"links/index.html","permalink":"http://fyupeng.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-24T18:11:07.170Z","updated":"2022-06-24T18:11:07.170Z","comments":true,"path":"js/plugin.min.js","permalink":"http://fyupeng.github.io/js/plugin.min.js","excerpt":"","text":"!function(t){var e=\"undefined\"==typeof module?t.baidu=t.baidu||{}:module.exports;e.template=function(e,n){var o=function(){if(!t.document)return i._compile(e);var n=document.getElementById(e);if(n){if(i.cache[e])return i.cache[e];var o=/^(textarea|input)$/i.test(n.nodeName)?n.value:n.innerHTML;return i._compile(o)}return i._compile(e)}(),r=i._isObject(n)?o(n):o;return o=null,r};var i=e.template;i.versions=i.versions||[],i.versions.push(\"1.0.6\"),i.cache={},i.LEFT_DELIMITER=i.LEFT_DELIMITER||\"{ %\",i.RIGHT_DELIMITER=i.RIGHT_DELIMITER||\"% }\",i.ESCAPE=!0,i._encodeHTML=function(t){return String(t).replace(/&/g,\"&amp;\").replace(//g,\"&gt;\").replace(/\\\\/g,\"&#92;\").replace(/\"/g,\"&quot;\").replace(/'/g,\"&#39;\")},i._encodeReg=function(t){return String(t).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},i._encodeEventHTML=function(t){return String(t).replace(/&/g,\"&amp;\").replace(//g,\"&gt;\").replace(/\"/g,\"&quot;\").replace(/'/g,\"&#39;\").replace(/\\\\\\\\/g,\"\\\\\").replace(/\\\\\\//g,\"/\").replace(/\\\\n/g,\"\\n\").replace(/\\\\r/g,\"\\r\")},i._compile=function(t){var e=\"var _template_fun_array=[];\\nvar fn=(function(__data__){\\nvar _template_varName='';\\nfor(name in __data__){\\n_template_varName+=('var '+name+'=__data__[\\\"'+name+'\\\"];');\\n};\\neval(_template_varName);\\n_template_fun_array.push('\"+i._analysisStr(t)+\"');\\n_template_varName=null;\\n})(_template_object);\\nfn = null;\\nreturn _template_fun_array.join('');\\n\";return new Function(\"_template_object\",e)},i._isObject=function(t){return\"function\"==typeof t||!(!t||\"object\"!=typeof t)},i._analysisStr=function(t){var e=i.LEFT_DELIMITER,n=i.RIGHT_DELIMITER,o=i._encodeReg(e),r=i._encodeReg(n);return t=String(t).replace(new RegExp(\"(\"+o+\"[^\"+r+\"]*)//.*\\n\",\"g\"),\"$1\").replace(new RegExp(\"\",\"g\"),\"\").replace(new RegExp(o+\"\\\\*.*?\\\\*\"+r,\"g\"),\"\").replace(new RegExp(\"[\\\\r\\\\t\\\\n]\",\"g\"),\"\").replace(new RegExp(o+\"(?:(?!\"+r+\")[\\\\s\\\\S])*\"+r+\"|((?:(?!\"+o+\")[\\\\s\\\\S])+)\",\"g\"),function(t,e){var i=\"\";if(e)for(i=e.replace(/\\\\/g,\"&#92;\").replace(/'/g,\"&#39;\");/i?t+6*(e-t)*i:.5>i?e:2/3>i?t+(e-t)*(2/3-i)*6:t}var i,n,o,r=t.h,s=t.s,a=t.l;if(0===s)i=n=o=a;else{var l=.5>a?a*(1+s):a+s-a*s,h=2*a-l;i=e(h,l,r+1/3),n=e(h,l,r),o=e(h,l,r-1/3)}return{r:Math.round(255*i),g:Math.round(255*n),b:Math.round(255*o)}}e.exports={hex2rgb:i,rgb2hex:n,rgb2hsl:o,hsl2rgb:r,rgb2rgbString:function(t){return\"rgb(\"+[t.r,t.g,t.b].join(\",\")+\")\"}}},{}],3:[function(t,e){!function(i){\"use strict\";function n(t){return function(e,i){return\"object\"==typeof e&&(i=e,e=null),(null===e||void 0===e)&&(e=(new Date).toString()),i||(i={}),t.call(this,e,i)}}var o=t(\"./pattern\"),r=e.exports={generate:n(function(t,e){return new o(t,e)})};i&&(i.fn.geopattern=n(function(t,e){return this.each(function(){var n=i(this).attr(\"data-title-sha\");n&&(e=i.extend({hash:n},e));var o=r.generate(t,e);i(this).css(\"background-image\",o.toDataUrl())})}))}(\"undefined\"!=typeof jQuery?jQuery:null)},{\"./pattern\":4}],4:[function(t,e){(function(i){\"use strict\";function n(t,e,i){return parseInt(t.substr(e,i||1),16)}function o(t,e,i,n,o){var r=parseFloat(t),s=i-e,a=o-n;return(r-e)*a/s+n}function r(t){return t%2===0?k:_}function s(t){return o(t,0,15,S,I)}function a(t){var e=t,i=e/2,n=Math.sin(60*Math.PI/180)*e;return[0,n,i,0,i+e,0,2*e,n,i+e,2*n,i,2*n,0,n].join(\",\")}function l(t,e){var i=.66*e;return[[0,0,t/2,e-i,t/2,e,0,i,0,0],[t/2,e-i,t,0,t,i,t/2,e,t/2,e-i]].map(function(t){return t.join(\",\")})}function h(t){return[[t,0,t,3*t],[0,t,3*t,t]]}function c(t){var e=t,i=.33*e;return[i,0,e-i,0,e,i,e,e-i,e-i,e,i,e,0,e-i,0,i,i,0].join(\",\")}function u(t,e){var i=t/2;return[i,0,t,e,0,e,i,0].join(\",\")}function f(t,e){return[t/2,0,t,e/2,t/2,e,0,e/2].join(\",\")}function p(t){return[0,0,t,t,0,t,0,0].join(\",\")}function d(t,e,i,n,o){var a=p(n),l=s(o[0]),h=r(o[0]),c={stroke:E,\"stroke-opacity\":x,\"fill-opacity\":l,fill:h};t.polyline(a,c).transform({translate:[e+n,i],scale:[-1,1]}),t.polyline(a,c).transform({translate:[e+n,i+2*n],scale:[1,-1]}),l=s(o[1]),h=r(o[1]),c={stroke:E,\"stroke-opacity\":x,\"fill-opacity\":l,fill:h},t.polyline(a,c).transform({translate:[e+n,i+2*n],scale:[-1,-1]}),t.polyline(a,c).transform({translate:[e+n,i],scale:[1,1]})}function g(t,e,i,n,o){var a=s(o),l=r(o),h=p(n),c={stroke:E,\"stroke-opacity\":x,\"fill-opacity\":a,fill:l};t.polyline(h,c).transform({translate:[e,i+n],scale:[1,-1]}),t.polyline(h,c).transform({translate:[e+2*n,i+n],scale:[-1,-1]}),t.polyline(h,c).transform({translate:[e,i+n],scale:[1,1]}),t.polyline(h,c).transform({translate:[e+2*n,i+n],scale:[-1,1]})}function v(t,e){var i=t/2;return[0,0,e,i,0,t,0,0].join(\",\")}var m=t(\"extend\"),y=t(\"./color\"),b=t(\"./sha1\"),w=t(\"./svg\"),T={baseColor:\"#933c3c\"},C=[\"octogons\",\"overlappingCircles\",\"plusSigns\",\"xes\",\"sineWaves\",\"hexagons\",\"overlappingRings\",\"plaid\",\"triangles\",\"squares\",\"concentricCircles\",\"diamonds\",\"tessellation\",\"nestedSquares\",\"mosaicSquares\",\"chevrons\"],_=\"#222\",k=\"#ddd\",E=\"#000\",x=.02,S=.02,I=.15,A=e.exports=function(t,e){return this.opts=m({},T,e),this.hash=e.hash||b(t),this.svg=new w,this.generateBackground(),this.generatePattern(),this};A.prototype.toSvg=function(){return this.svg.toString()},A.prototype.toString=function(){return this.toSvg()},A.prototype.toBase64=function(){var t,e=this.toSvg();return t=\"undefined\"!=typeof window&&\"function\"==typeof window.btoa?window.btoa(e):new i(e).toString(\"base64\")},A.prototype.toDataUri=function(){return\"data:image/svg+xml;base64,\"+this.toBase64()},A.prototype.toDataUrl=function(){return'url(\"'+this.toDataUri()+'\")'},A.prototype.generateBackground=function(){var t,e,i,r;this.opts.color?i=y.hex2rgb(this.opts.color):(e=o(n(this.hash,14,3),0,4095,0,359),r=n(this.hash,17),t=y.rgb2hsl(y.hex2rgb(this.opts.baseColor)),t.h=(360*t.h-e+360)%360/360,t.s=r%2===0?Math.min(1,(100*t.s+r)/100):Math.max(0,(100*t.s-r)/100),i=y.hsl2rgb(t)),this.color=y.rgb2hex(i),this.svg.rect(0,0,\"100%\",\"100%\",{fill:y.rgb2rgbString(i)})},A.prototype.generatePattern=function(){var t=this.opts.generator;if(t){if(C.indexOf(t)f;f++)for(u=0;6>u;u++)c=n(this.hash,i),t=u%2===0?f*g:f*g+g/2,l=s(c),e=r(c),h={fill:e,\"fill-opacity\":l,stroke:E,\"stroke-opacity\":x},this.svg.polyline(m,h).transform({translate:[u*d*1.5-v/2,t-g/2]}),0===u&&this.svg.polyline(m,h).transform({translate:[6*d*1.5-v/2,t-g/2]}),0===f&&(t=u%2===0?6*g:6*g+g/2,this.svg.polyline(m,h).transform({translate:[u*d*1.5-v/2,t-g/2]})),0===u&&0===f&&this.svg.polyline(m,h).transform({translate:[6*d*1.5-v/2,5*g+g/2]}),i++},A.prototype.geoSineWaves=function(){var t,e,i,a,l,h,c,u=Math.floor(o(n(this.hash,0),0,15,100,400)),f=Math.floor(o(n(this.hash,1),0,15,30,100)),p=Math.floor(o(n(this.hash,2),0,15,3,30));for(this.svg.setWidth(u),this.svg.setHeight(36*p),e=0;36>e;e++)h=n(this.hash,e),i=s(h),t=r(h),c=u/4*.7,l={fill:\"none\",stroke:t,opacity:i,\"stroke-width\":\"\"+p+\"px\"},a=\"M0 \"+f+\" C \"+c+\" 0, \"+(u/2-c)+\" 0, \"+u/2+\" \"+f+\" S \"+(u-c)+\" \"+2*f+\", \"+u+\" \"+f+\" S \"+(1.5*u-c)+\" 0, \"+1.5*u+\", \"+f,this.svg.path(a,l).transform({translate:[-u/4,p*e-1.5*f]}),this.svg.path(a,l).transform({translate:[-u/4,p*e-1.5*f+36*p]})},A.prototype.geoChevrons=function(){var t,e,i,a,h,c,u,f=o(n(this.hash,0),0,15,30,80),p=o(n(this.hash,0),0,15,30,80),d=l(f,p);for(this.svg.setWidth(6*f),this.svg.setHeight(6*p*.66),e=0,u=0;6>u;u++)for(c=0;6>c;c++)h=n(this.hash,e),i=s(h),t=r(h),a={stroke:E,\"stroke-opacity\":x,fill:t,\"fill-opacity\":i,\"stroke-width\":1},this.svg.group(a).transform({translate:[c*f,u*p*.66-p/2]}).polyline(d).end(),0===u&&this.svg.group(a).transform({translate:[c*f,6*p*.66-p/2]}).polyline(d).end(),e+=1},A.prototype.geoPlusSigns=function(){var t,e,i,a,l,c,u,f,p=o(n(this.hash,0),0,15,10,25),d=3*p,g=h(p);for(this.svg.setWidth(12*p),this.svg.setHeight(12*p),i=0,f=0;6>f;f++)for(u=0;6>u;u++)c=n(this.hash,i),a=s(c),e=r(c),t=f%2===0?0:1,l={fill:e,stroke:E,\"stroke-opacity\":x,\"fill-opacity\":a},this.svg.group(l).transform({translate:[u*d-u*p+t*p-p,f*d-f*p-d/2]}).rect(g).end(),0===u&&this.svg.group(l).transform({translate:[4*d-u*p+t*p-p,f*d-f*p-d/2]}).rect(g).end(),0===f&&this.svg.group(l).transform({translate:[u*d-u*p+t*p-p,4*d-f*p-d/2]}).rect(g).end(),0===u&&0===f&&this.svg.group(l).transform({translate:[4*d-u*p+t*p-p,4*d-f*p-d/2]}).rect(g).end(),i++},A.prototype.geoXes=function(){var t,e,i,a,l,c,u,f,p=o(n(this.hash,0),0,15,10,25),d=h(p),g=3*p*.943;for(this.svg.setWidth(3*g),this.svg.setHeight(3*g),i=0,f=0;6>f;f++)for(u=0;6>u;u++)c=n(this.hash,i),a=s(c),t=u%2===0?f*g-.5*g:f*g-.5*g+g/4,e=r(c),l={fill:e,opacity:a},this.svg.group(l).transform({translate:[u*g/2-g/2,t-f*g/2],rotate:[45,g/2,g/2]}).rect(d).end(),0===u&&this.svg.group(l).transform({translate:[6*g/2-g/2,t-f*g/2],rotate:[45,g/2,g/2]}).rect(d).end(),0===f&&(t=u%2===0?6*g-g/2:6*g-g/2+g/4,this.svg.group(l).transform({translate:[u*g/2-g/2,t-6*g/2],rotate:[45,g/2,g/2]}).rect(d).end()),5===f&&this.svg.group(l).transform({translate:[u*g/2-g/2,t-11*g/2],rotate:[45,g/2,g/2]}).rect(d).end(),0===u&&0===f&&this.svg.group(l).transform({translate:[6*g/2-g/2,t-6*g/2],rotate:[45,g/2,g/2]}).rect(d).end(),i++},A.prototype.geoOverlappingCircles=function(){var t,e,i,a,l,h,c,u=n(this.hash,0),f=o(u,0,15,25,200),p=f/2;for(this.svg.setWidth(6*p),this.svg.setHeight(6*p),e=0,c=0;6>c;c++)for(h=0;6>h;h++)l=n(this.hash,e),i=s(l),t=r(l),a={fill:t,opacity:i},this.svg.circle(h*p,c*p,p,a),0===h&&this.svg.circle(6*p,c*p,p,a),0===c&&this.svg.circle(h*p,6*p,p,a),0===h&&0===c&&this.svg.circle(6*p,6*p,p,a),e++},A.prototype.geoOctogons=function(){var t,e,i,a,l,h,u=o(n(this.hash,0),0,15,10,60),f=c(u);for(this.svg.setWidth(6*u),this.svg.setHeight(6*u),e=0,h=0;6>h;h++)for(l=0;6>l;l++)a=n(this.hash,e),i=s(a),t=r(a),this.svg.polyline(f,{fill:t,\"fill-opacity\":i,stroke:E,\"stroke-opacity\":x}).transform({translate:[l*u,h*u]}),e+=1},A.prototype.geoSquares=function(){var t,e,i,a,l,h,c=o(n(this.hash,0),0,15,10,60);for(this.svg.setWidth(6*c),this.svg.setHeight(6*c),e=0,h=0;6>h;h++)for(l=0;6>l;l++)a=n(this.hash,e),i=s(a),t=r(a),this.svg.rect(l*c,h*c,c,c,{fill:t,\"fill-opacity\":i,stroke:E,\"stroke-opacity\":x}),e+=1},A.prototype.geoConcentricCircles=function(){var t,e,i,a,l,h,c=n(this.hash,0),u=o(c,0,15,10,60),f=u/5;for(this.svg.setWidth(6*(u+f)),this.svg.setHeight(6*(u+f)),e=0,h=0;6>h;h++)for(l=0;6>l;l++)a=n(this.hash,e),i=s(a),t=r(a),this.svg.circle(l*u+l*f+(u+f)/2,h*u+h*f+(u+f)/2,u/2,{fill:\"none\",stroke:t,opacity:i,\"stroke-width\":f+\"px\"}),a=n(this.hash,39-e),i=s(a),t=r(a),this.svg.circle(l*u+l*f+(u+f)/2,h*u+h*f+(u+f)/2,u/4,{fill:t,\"fill-opacity\":i}),e+=1},A.prototype.geoOverlappingRings=function(){var t,e,i,a,l,h,c,u=n(this.hash,0),f=o(u,0,15,10,60),p=f/4;for(this.svg.setWidth(6*f),this.svg.setHeight(6*f),e=0,c=0;6>c;c++)for(h=0;6>h;h++)l=n(this.hash,e),i=s(l),t=r(l),a={fill:\"none\",stroke:t,opacity:i,\"stroke-width\":p+\"px\"},this.svg.circle(h*f,c*f,f-p/2,a),0===h&&this.svg.circle(6*f,c*f,f-p/2,a),0===c&&this.svg.circle(h*f,6*f,f-p/2,a),0===h&&0===c&&this.svg.circle(6*f,6*f,f-p/2,a),e+=1},A.prototype.geoTriangles=function(){var t,e,i,a,l,h,c,f,p=n(this.hash,0),d=o(p,0,15,15,80),g=d/2*Math.sqrt(3),v=u(d,g);for(this.svg.setWidth(3*d),this.svg.setHeight(6*g),e=0,f=0;6>f;f++)for(c=0;6>c;c++)h=n(this.hash,e),i=s(h),t=r(h),l={fill:t,\"fill-opacity\":i,stroke:E,\"stroke-opacity\":x},a=f%2===0?c%2===0?180:0:c%2!==0?180:0,this.svg.polyline(v,l).transform({translate:[c*d*.5-d/2,g*f],rotate:[a,d/2,g/2]}),0===c&&this.svg.polyline(v,l).transform({translate:[6*d*.5-d/2,g*f],rotate:[a,d/2,g/2]}),e+=1},A.prototype.geoDiamonds=function(){var t,e,i,a,l,h,c,u,p=o(n(this.hash,0),0,15,10,50),d=o(n(this.hash,1),0,15,10,50),g=f(p,d);for(this.svg.setWidth(6*p),this.svg.setHeight(3*d),i=0,u=0;6>u;u++)for(c=0;6>c;c++)h=n(this.hash,i),a=s(h),e=r(h),l={fill:e,\"fill-opacity\":a,stroke:E,\"stroke-opacity\":x},t=u%2===0?0:p/2,this.svg.polyline(g,l).transform({translate:[c*p-p/2+t,d/2*u-d/2]}),0===c&&this.svg.polyline(g,l).transform({translate:[6*p-p/2+t,d/2*u-d/2]}),0===u&&this.svg.polyline(g,l).transform({translate:[c*p-p/2+t,d/2*6-d/2]}),0===c&&0===u&&this.svg.polyline(g,l).transform({translate:[6*p-p/2+t,d/2*6-d/2]}),i+=1},A.prototype.geoNestedSquares=function(){var t,e,i,a,l,h,c,u=o(n(this.hash,0),0,15,4,12),f=7*u;for(this.svg.setWidth(6*(f+u)+6*u),this.svg.setHeight(6*(f+u)+6*u),e=0,c=0;6>c;c++)for(h=0;6>h;h++)l=n(this.hash,e),i=s(l),t=r(l),a={fill:\"none\",stroke:t,opacity:i,\"stroke-width\":u+\"px\"},this.svg.rect(h*f+h*u*2+u/2,c*f+c*u*2+u/2,f,f,a),l=n(this.hash,39-e),i=s(l),t=r(l),a={fill:\"none\",stroke:t,opacity:i,\"stroke-width\":u+\"px\"},this.svg.rect(h*f+h*u*2+u/2+2*u,c*f+c*u*2+u/2+2*u,3*u,3*u,a),e+=1},A.prototype.geoMosaicSquares=function(){var t,e,i,r=o(n(this.hash,0),0,15,15,50);for(this.svg.setWidth(8*r),this.svg.setHeight(8*r),t=0,i=0;4>i;i++)for(e=0;4>e;e++)e%2===0?i%2===0?g(this.svg,e*r*2,i*r*2,r,n(this.hash,t)):d(this.svg,e*r*2,i*r*2,r,[n(this.hash,t),n(this.hash,t+1)]):i%2===0?d(this.svg,e*r*2,i*r*2,r,[n(this.hash,t),n(this.hash,t+1)]):g(this.svg,e*r*2,i*r*2,r,n(this.hash,t)),t+=1},A.prototype.geoPlaid=function(){var t,e,i,o,a,l,h,c=0,u=0;for(e=0;36>e;)o=n(this.hash,e),c+=o+5,h=n(this.hash,e+1),i=s(h),t=r(h),a=h+5,this.svg.rect(0,c,\"100%\",a,{opacity:i,fill:t}),c+=a,e+=2;for(e=0;36>e;)o=n(this.hash,e),u+=o+5,h=n(this.hash,e+1),i=s(h),t=r(h),l=h+5,this.svg.rect(u,0,l,\"100%\",{opacity:i,fill:t}),u+=l,e+=2;this.svg.setWidth(u),this.svg.setHeight(c)},A.prototype.geoTessellation=function(){var t,e,i,a,l,h=o(n(this.hash,0),0,15,5,40),c=h*Math.sqrt(3),u=2*h,f=h/2*Math.sqrt(3),p=v(h,f),d=3*h+2*f,g=2*c+2*h;for(this.svg.setWidth(d),this.svg.setHeight(g),e=0;20>e;e++)switch(l=n(this.hash,e),i=s(l),t=r(l),a={stroke:E,\"stroke-opacity\":x,fill:t,\"fill-opacity\":i,\"stroke-width\":1},e){case 0:this.svg.rect(-h/2,-h/2,h,h,a),this.svg.rect(d-h/2,-h/2,h,h,a),this.svg.rect(-h/2,g-h/2,h,h,a),this.svg.rect(d-h/2,g-h/2,h,h,a);break;case 1:this.svg.rect(u/2+f,c/2,h,h,a);break;case 2:this.svg.rect(-h/2,g/2-h/2,h,h,a),this.svg.rect(d-h/2,g/2-h/2,h,h,a);break;case 3:this.svg.rect(u/2+f,1.5*c+h,h,h,a);break;case 4:this.svg.polyline(p,a).transform({translate:[h/2,-h/2],rotate:[0,h/2,f/2]}),this.svg.polyline(p,a).transform({translate:[h/2,g- -h/2],rotate:[0,h/2,f/2],scale:[1,-1]});break;case 5:this.svg.polyline(p,a).transform({translate:[d-h/2,-h/2],rotate:[0,h/2,f/2],scale:[-1,1]}),this.svg.polyline(p,a).transform({translate:[d-h/2,g+h/2],rotate:[0,h/2,f/2],scale:[-1,-1]});break;case 6:this.svg.polyline(p,a).transform({translate:[d/2+h/2,c/2]});break;case 7:this.svg.polyline(p,a).transform({translate:[d-d/2-h/2,c/2],scale:[-1,1]});break;case 8:this.svg.polyline(p,a).transform({translate:[d/2+h/2,g-c/2],scale:[1,-1]});break;case 9:this.svg.polyline(p,a).transform({translate:[d-d/2-h/2,g-c/2],scale:[-1,-1]});break;case 10:this.svg.polyline(p,a).transform({translate:[h/2,g/2-h/2]});break;case 11:this.svg.polyline(p,a).transform({translate:[d-h/2,g/2-h/2],scale:[-1,1]});break;case 12:this.svg.rect(0,0,h,h,a).transform({translate:[h/2,h/2],rotate:[-30,0,0]});break;case 13:this.svg.rect(0,0,h,h,a).transform({scale:[-1,1],translate:[-d+h/2,h/2],rotate:[-30,0,0]});break;case 14:this.svg.rect(0,0,h,h,a).transform({translate:[h/2,g/2-h/2-h],rotate:[30,0,h]});break;case 15:this.svg.rect(0,0,h,h,a).transform({scale:[-1,1],translate:[-d+h/2,g/2-h/2-h],rotate:[30,0,h]});break;case 16:this.svg.rect(0,0,h,h,a).transform({scale:[1,-1],translate:[h/2,-g+g/2-h/2-h],rotate:[30,0,h]});break;case 17:this.svg.rect(0,0,h,h,a).transform({scale:[-1,-1],translate:[-d+h/2,-g+g/2-h/2-h],rotate:[30,0,h]});break;case 18:this.svg.rect(0,0,h,h,a).transform({scale:[1,-1],translate:[h/2,-g+h/2],rotate:[-30,0,0]});break;case 19:this.svg.rect(0,0,h,h,a).transform({scale:[-1,-1],translate:[-d+h/2,-g+h/2],rotate:[-30,0,0]})}}}).call(this,t(\"buffer\").Buffer)},{\"./color\":2,\"./sha1\":5,\"./svg\":6,buffer:8,extend:9}],5:[function(t,e){\"use strict\";function i(){function t(){for(var t=16;80>t;t++){var e=u[t-3]^u[t-8]^u[t-14]^u[t-16];u[t]=e>31}var i,n,o=s,r=a,p=l,d=h,g=c;for(t=0;80>t;t++){20>t?(i=d^r&(p^d),n=1518500249):40>t?(i=r^p^d,n=1859775393):60>t?(i=r&p|d&(r|p),n=2400959708):(i=r^p^d,n=3395469782);var v=(o>27)+i+g+n+(0|u[t]);g=d,d=p,p=r>2,r=o,o=v}for(s=s+o|0,a=a+r|0,l=l+p|0,h=h+d|0,c=c+g|0,f=0,t=0;16>t;t++)u[t]=0}function e(e){u[f]|=(255&e)o;o++)e(t[o])}function o(t){for(var e=\"\",i=28;i>=0;i-=4)e+=(t>>i&15).toString(16);return e}function r(){e(128),(f>14||14===f&&24>p)&&t(),f=14,p=24,e(0),e(0),e(d>0xffffffffff?d/1099511627776:0),e(d>4294967295?d/4294967296:0);for(var i=24;i>=0;i-=8)e(d>>i);return o(s)+o(a)+o(l)+o(h)+o(c)}var s=1732584193,a=4023233417,l=2562383102,h=271733878,c=3285377520,u=new Uint32Array(80),f=0,p=24,d=0;return{update:n,digest:r}}e.exports=function(t){if(void 0===t)return i();var e=i();return e.update(t),e.digest()}},{}],6:[function(t,e){\"use strict\";function i(){return this.width=100,this.height=100,this.svg=new o(\"svg\"),this.context=[],this.setAttributes(this.svg,{xmlns:\"http://www.w3.org/2000/svg\",width:this.width,height:this.height}),this}var n=t(\"extend\"),o=t(\"./xml\");e.exports=i,i.prototype.currentContext=function(){return this.context[this.context.length-1]||this.svg},i.prototype.end=function(){return this.context.pop(),this},i.prototype.currentNode=function(){var t=this.currentContext();return t.lastChild||t},i.prototype.transform=function(t){return this.currentNode().setAttribute(\"transform\",Object.keys(t).map(function(e){return e+\"(\"+t[e].join(\",\")+\")\"}).join(\" \")),this},i.prototype.setAttributes=function(t,e){Object.keys(e).forEach(function(i){t.setAttribute(i,e[i])})},i.prototype.setWidth=function(t){this.svg.setAttribute(\"width\",Math.floor(t))},i.prototype.setHeight=function(t){this.svg.setAttribute(\"height\",Math.floor(t))},i.prototype.toString=function(){return this.svg.toString()},i.prototype.rect=function(t,e,i,r,s){var a=this;if(Array.isArray(t))return t.forEach(function(t){a.rect.apply(a,t.concat(s))}),this;var l=new o(\"rect\");return this.currentContext().appendChild(l),this.setAttributes(l,n({x:t,y:e,width:i,height:r},s)),this},i.prototype.circle=function(t,e,i,r){var s=new o(\"circle\");return this.currentContext().appendChild(s),this.setAttributes(s,n({cx:t,cy:e,r:i},r)),this},i.prototype.path=function(t,e){var i=new o(\"path\");return this.currentContext().appendChild(i),this.setAttributes(i,n({d:t},e)),this},i.prototype.polyline=function(t,e){var i=this;if(Array.isArray(t))return t.forEach(function(t){i.polyline(t,e)}),this;var r=new o(\"polyline\");return this.currentContext().appendChild(r),this.setAttributes(r,n({points:t},e)),this},i.prototype.group=function(t){var e=new o(\"g\");return this.currentContext().appendChild(e),this.context.push(e),this.setAttributes(e,n({},t)),this}},{\"./xml\":7,extend:9}],7:[function(t,e){\"use strict\";var i=e.exports=function(t){return this instanceof i?(this.tagName=t,this.attributes=Object.create(null),this.children=[],this.lastChild=null,this):new i(t)};i.prototype.appendChild=function(t){return this.children.push(t),this.lastChild=t,this},i.prototype.setAttribute=function(t,e){return this.attributes[t]=e,this},i.prototype.toString=function(){var t=this;return[\"\",t.children.map(function(t){return t.toString()}).join(\"\"),\"\"].join(\"\")}},{}],8:[function(){},{}],9:[function(t,e){function i(t){if(!t||\"[object Object]\"!==o.call(t)||t.nodeType||t.setInterval)return!1;var e=n.call(t,\"constructor\"),i=n.call(t.constructor.prototype,\"isPrototypeOf\");if(t.constructor&&!e&&!i)return!1;var r;for(r in t);return void 0===r||n.call(t,r)}var n=Object.prototype.hasOwnProperty,o=Object.prototype.toString;e.exports=function r(){var t,e,n,o,s,a,l=arguments[0]||{},h=1,c=arguments.length,u=!1;for(\"boolean\"==typeof l&&(u=l,l=arguments[1]||{},h=2),\"object\"!=typeof l&&\"function\"!=typeof l&&(l={});c>h;h++)if(null!=(t=arguments[h]))for(e in t)n=l[e],o=t[e],l!==o&&(u&&o&&(i(o)||(s=Array.isArray(o)))?(s?(s=!1,a=n&&Array.isArray(n)?n:[]):a=n&&i(n)?n:{},l[e]=r(u,a,o)):void 0!==o&&(l[e]=o));return l}},{}]},{},[1])(1)}),function(){\"use strict\";if(navigator.userAgent.match(/IEMobile\\/10\\.0/)){var t=document.createElement(\"style\");t.appendChild(document.createTextNode(\"@-ms-viewport{width:auto!important}\")),document.querySelector(\"head\").appendChild(t)}}(),function(t){\"function\"==typeof define&&define.amd?define([\"jquery\"],t):\"object\"==typeof module&&module.exports?module.exports=function(e,i){return void 0===i&&(i=\"undefined\"!=typeof window?require(\"jquery\"):require(\"jquery\")(e)),t(i),i}:t(jQuery)}(function(t){function e(e,i){var o=this;this.options=t.extend({},n,i),o.navigation=t(e),o.document=t(document),o.window=t(window),\"\"==this.options.parent?this.options.parent=o.navigation.parent():\"\",o.nav_open=!1,o.parent_full_width=0,o.radCoef=180/Math.PI,o.sTouch={x:0,y:0},o.cTouch={x:0,y:0},o.sTime=0,o.nav_position=0,o.percent_open=0,o.nav_moving=!1,o.init()}var i=\"okayNav\",n={parent:\"\",toggle_icon_class:\"okayNav__menu-toggle\",toggle_icon_content:\"\",align_right:!0,swipe_enabled:!0,threshold:50,resize_delay:10,beforeOpen:function(){},afterOpen:function(){},beforeClose:function(){},afterClose:function(){},itemHidden:function(){},itemDisplayed:function(){}};t.extend(e.prototype,{init:function(){var e=this;t(\"body\").addClass(\"okayNav-loaded\"),e.navigation.addClass(\"okayNav loaded\").children(\"ul\").addClass(\"okayNav__nav--visible\"),e.options.align_right?e.navigation.append('').append(''+e.options.toggle_icon_content+\"\"):e.navigation.prepend('').prepend(''+e.options.toggle_icon_content+\"\"),e.nav_visible=e.navigation.children(\".okayNav__nav--visible\"),e.nav_invisible=e.navigation.children(\".okayNav__nav--invisible\"),e.toggle_icon=e.navigation.children(\".\"+e.options.toggle_icon_class),e.toggle_icon_width=e.toggle_icon.outerWidth(!0),e.default_width=e.getChildrenWidth(e.navigation),e.parent_full_width=t(e.options.parent).outerWidth(!0),e.last_visible_child_width=0,e.initEvents(),e.nav_visible.contents().filter(function(){return this.nodeType=Node.TEXT_NODE&&/\\S/.test(this.nodeValue)===!1}).remove(),1==e.options.swipe_enabled&&e.initSwipeEvents()},initEvents:function(){var e=this;e.document.on(\"click.okayNav\",function(i){var n=t(i.target);e.nav_open===!0&&0==n.closest(\".okayNav\").length&&e.closeInvisibleNav(),i.target===e.toggle_icon.get(0)&&(i.preventDefault(),e.toggleInvisibleNav())});var i=e._debounce(function(){e.recalcNav()},e.options.resize_delay);e.window.on(\"load.okayNav resize.okayNav\",i)},initSwipeEvents:function(){var e=this;e.document.on(\"touchstart.okayNav\",function(i){if(e.nav_invisible.removeClass(\"transition-enabled\"),1==i.originalEvent.touches.length){var n=i.originalEvent.touches[0];(n.pageXt(e.options.parent).outerWidth(!0)-25&&1==e.options.align_right||e.nav_open===!0)&&(e.sTouch.x=e.cTouch.x=n.pageX,e.sTouch.y=e.cTouch.y=n.pageY,e.sTime=Date.now())}}).on(\"touchmove.okayNav\",function(t){var i=t.originalEvent.touches[0];e._triggerMove(i.pageX,i.pageY),e.nav_moving=!0}).on(\"touchend.okayNav\",function(t){e.sTouch={x:0,y:0},e.cTouch={x:0,y:0},e.sTime=0,e.percent_open>100-e.options.threshold?(e.nav_position=0,e.closeInvisibleNav()):1==e.nav_moving&&(e.nav_position=e.nav_invisible.width(),e.openInvisibleNav()),e.nav_moving=!1,e.nav_invisible.addClass(\"transition-enabled\")})},_getDirection:function(t){return this.options.align_right?t>0?-1:1:t=a||0>e||e>=a)&&s.isDark(t,e)}var s=t(n,i);s.addData(e),s.make(),o=o||0;var a=s.getModuleCount(),l=s.getModuleCount()+2*o,h=function(t,e,i,n){var o=this.isDark,r=1/l;this.isDark=function(s,a){var l=a*r,h=s*r,c=l+r,u=h+r;return o(s,a)&&(t>c||l>i||e>u||h>n)}};this.text=e,this.level=i,this.version=n,this.moduleCount=l,this.isDark=r,this.addBlank=h}function i(t,i,n,o,r){n=Math.max(1,n||1),o=Math.min(40,o||40);for(var s=n;o>=s;s+=1)try{return new e(t,i,s,r)}catch(t){}}function n(t,e,i){var n=i.size,o=\"bold \"+i.mSize*n+\"px \"+i.fontname,r=v(\"\")[0].getContext(\"2d\");r.font=o;var s=r.measureText(i.label).width,a=i.mSize,l=s/n,h=(1-l)*i.mPosX,c=(1-a)*i.mPosY,u=h+l,f=c+a,p=.01;1===i.mode?t.addBlank(0,c-p,n,f+p):t.addBlank(h-p,c-p,u+p,f+p),e.fillStyle=i.fontcolor,e.font=o,e.fillText(i.label,h*n,c*n+.75*i.mSize*n)}function o(t,e,i){var n=i.size,o=i.image.naturalWidth||1,r=i.image.naturalHeight||1,s=i.mSize,a=s*o/r,l=(1-a)*i.mPosX,h=(1-s)*i.mPosY,c=l+a,u=h+s,f=.01;3===i.mode?t.addBlank(0,h-f,n,u+f):t.addBlank(l-f,h-f,c+f,u+f),e.drawImage(i.image,l*n,h*n,a*n,s*n)}function r(t,e,i){v(i.background).is(\"img\")?e.drawImage(i.background,0,0,i.size,i.size):i.background&&(e.fillStyle=i.background,e.fillRect(i.left,i.top,i.size,i.size));var r=i.mode;1===r||2===r?n(t,e,i):(3===r||4===r)&&o(t,e,i)}function s(t,e,i,n,o,r,s,a){t.isDark(s,a)&&e.rect(n,o,r,r)}function a(t,e,i,n,o,r,s,a,l,h){s?t.moveTo(e+r,i):t.moveTo(e,i),a?(t.lineTo(n-r,i),t.arcTo(n,i,n,o,r)):t.lineTo(n,i),l?(t.lineTo(n,o-r),t.arcTo(n,o,e,o,r)):t.lineTo(n,o),h?(t.lineTo(e+r,o),t.arcTo(e,o,e,i,r)):t.lineTo(e,o),s?(t.lineTo(e,i+r),t.arcTo(e,i,n,i,r)):t.lineTo(e,i)}function l(t,e,i,n,o,r,s,a,l,h){s&&(t.moveTo(e+r,i),t.lineTo(e,i),t.lineTo(e,i+r),t.arcTo(e,i,e+r,i,r)),a&&(t.moveTo(n-r,i),t.lineTo(n,i),t.lineTo(n,i+r),t.arcTo(n,i,n-r,i,r)),l&&(t.moveTo(n-r,o),t.lineTo(n,o),t.lineTo(n,o-r), t.arcTo(n,o,n-r,o,r)),h&&(t.moveTo(e+r,o),t.lineTo(e,o),t.lineTo(e,o-r),t.arcTo(e,o,e+r,o,r))}function h(t,e,i,n,o,r,s,h){var c=t.isDark,u=n+r,f=o+r,p=i.radius*r,d=s-1,g=s+1,v=h-1,m=h+1,y=c(s,h),b=c(d,v),w=c(d,h),T=c(d,m),C=c(s,m),_=c(g,m),k=c(g,h),E=c(g,v),x=c(s,v);y?a(e,n,o,u,f,p,!w&&!x,!w&&!C,!k&&!C,!k&&!x):l(e,n,o,u,f,p,w&&x&&b,w&&C&&T,k&&C&&_,k&&x&&E)}function c(t,e,i){var n,o,r=t.moduleCount,a=i.size/r,l=s;for(y&&i.radius>0&&i.radiusn;n+=1)for(o=0;r>o;o+=1){var c=i.left+o*a,u=i.top+n*a,f=a;l(t,e,i,c,u,f,n,o)}if(v(i.fill).is(\"img\")){e.strokeStyle=\"rgba(0,0,0,0.5)\",e.lineWidth=2,e.stroke();var p=e.globalCompositeOperation;e.globalCompositeOperation=\"destination-out\",e.fill(),e.globalCompositeOperation=p,e.clip(),e.drawImage(i.fill,0,0,i.size,i.size),e.restore()}else e.fillStyle=i.fill,e.fill()}function u(t,e){var n=i(e.text,e.ecLevel,e.minVersion,e.maxVersion,e.quiet);if(!n)return null;var o=v(t).data(\"qrcode\",n),s=o[0].getContext(\"2d\");return r(n,s,e),c(n,s,e),o}function f(t){var e=v(\"\").attr(\"width\",t.size).attr(\"height\",t.size);return u(e,t)}function p(t){return v(\"\").attr(\"src\",f(t)[0].toDataURL(\"image/png\"))}function d(t){var e=i(t.text,t.ecLevel,t.minVersion,t.maxVersion,t.quiet);if(!e)return null;var n,o,r=t.size,s=t.background,a=Math.floor,l=e.moduleCount,h=a(r/l),c=a(.5*(r-h*l)),u={position:\"relative\",left:0,top:0,padding:0,margin:0,width:r,height:r},f={position:\"absolute\",padding:0,margin:0,width:h,height:h,\"background-color\":t.fill},p=v(\"\").data(\"qrcode\",e).css(u);for(s&&p.css(\"background-color\",s),n=0;l>n;n+=1)for(o=0;l>o;o+=1)e.isDark(n,o)&&v(\"\").css(f).css({left:c+o*h,top:c+n*h}).appendTo(p);return p}function g(t){return m&&\"canvas\"===t.render?f(t):m&&\"image\"===t.render?p(t):d(t)}var v=jQuery,m=function(){var t=document.createElement(\"canvas\");return Boolean(t.getContext&&t.getContext(\"2d\"))}(),y=\"[object Opera]\"!==Object.prototype.toString.call(window.opera),b={render:\"canvas\",minVersion:1,maxVersion:40,ecLevel:\"L\",left:0,top:0,size:200,fill:\"#000\",background:null,text:\"no text\",radius:0,quiet:0,mode:0,mSize:.1,mPosX:.5,mPosY:.5,label:\"no label\",fontname:\"sans\",fontcolor:\"#000\",image:null};v.fn.qrcode=function(t){var e=v.extend({},b,t);return this.each(function(){\"canvas\"===this.nodeName.toLowerCase()?u(this,e):v(this).append(g(e))})}}(function(){var t=function(){function t(e,i){if(\"undefined\"==typeof e.length)throw new Error(e.length+\"/\"+i);var n=function(){for(var t=0;t=n;n+=1)-1>=e+n||e+n>=p||(i>=0&&6>=i&&(0==n||6==n)||n>=0&&6>=n&&(0==i||6==i)||i>=2&&4>=i&&n>=2&&4>=n?f[t+i][e+n]=!0:f[t+i][e+n]=!1)},w=function(){for(var t=0,e=0,i=0;8>i;i+=1){y(!0,i);var n=r.getLostPoint(m);(0==i||t>n)&&(t=n,e=i)}return e},T=function(){for(var t=8;p-8>t;t+=1)null==f[t][6]&&(f[t][6]=t%2==0);for(var e=8;p-8>e;e+=1)null==f[6][e]&&(f[6][e]=e%2==0)},C=function(){for(var t=r.getPatternPosition(c),e=0;e=a;a+=1)-2==s||2==s||-2==a||2==a||0==s&&0==a?f[n+s][o+a]=!0:f[n+s][o+a]=!1}},_=function(t){for(var e=r.getBCHTypeNumber(c),i=0;18>i;i+=1){var n=!t&&1==(e>>i&1);f[Math.floor(i/3)][i%3+p-8-3]=n}for(var i=0;18>i;i+=1){var n=!t&&1==(e>>i&1);f[i%3+p-8-3][Math.floor(i/3)]=n}},k=function(t,e){for(var i=u>o&1);6>o?f[o][8]=s:8>o?f[o+1][8]=s:f[p-15+o][8]=s}for(var o=0;15>o;o+=1){var s=!t&&1==(n>>o&1);8>o?f[8][p-o-1]=s:9>o?f[8][15-o-1+1]=s:f[8][15-o-1]=s}f[p-8][8]=!t},E=function(t,e){for(var i=-1,n=p-1,o=7,s=0,a=r.getMaskFunction(e),l=p-1;l>0;l-=2)for(6==l&&(l-=1);;){for(var h=0;2>h;h+=1)if(null==f[n][l-h]){var c=!1;s>>o&1));var u=a(n,l-h);u&&(c=!c),f[n][l-h]=c,o-=1,-1==o&&(s+=1,o=7)}if(n+=i,0>n||n>=p){n-=i,i=-i;break}}},x=function(e,i){for(var n=0,o=0,s=0,a=new Array(i.length),l=new Array(i.length),h=0;h=n&&o>i){var r=Math.floor((e-n)/t),s=Math.floor((i-n)/t);return m.isDark(s,r)?0:1}return 1})},m};e.stringToBytes=function(t){for(var e=new Array,i=0;i>=1;return e};return l.getBCHTypeInfo=function(t){for(var e=t=e))for(var l=-1;1>=l;l+=1)0>o+l||o+l>=e||(0!=a||0!=l)&&s==t.isDark(n+a,o+l)&&(r+=1);r>5&&(i+=3+r-5)}for(var n=0;e-1>n;n+=1)for(var o=0;e-1>o;o+=1){var h=0;t.isDark(n,o)&&(h+=1),t.isDark(n+1,o)&&(h+=1),t.isDark(n,o+1)&&(h+=1),t.isDark(n+1,o+1)&&(h+=1),(0==h||4==h)&&(i+=3)}for(var n=0;e>n;n+=1)for(var o=0;e-6>o;o+=1)t.isDark(n,o)&&!t.isDark(n,o+1)&&t.isDark(n,o+2)&&t.isDark(n,o+3)&&t.isDark(n,o+4)&&!t.isDark(n,o+5)&&t.isDark(n,o+6)&&(i+=40);for(var o=0;e>o;o+=1)for(var n=0;e-6>n;n+=1)t.isDark(n,o)&&!t.isDark(n+1,o)&&t.isDark(n+2,o)&&t.isDark(n+3,o)&&t.isDark(n+4,o)&&!t.isDark(n+5,o)&&t.isDark(n+6,o)&&(i+=40);for(var c=0,o=0;e>o;o+=1)for(var n=0;e>n;n+=1)t.isDark(n,o)&&(c+=1);var u=Math.abs(100*c/e/e-50)/5;return i+=10*u},l}(),s=function(){for(var t=new Array(256),e=new Array(256),i=0;8>i;i+=1)t[i]=1i;i+=1)e[t[i]]=i;var n={};return n.glog=function(t){if(1>t)throw new Error(\"glog(\"+t+\")\");return e[t]},n.gexp=function(e){for(;0>e;)e+=255;for(;e>=256;)e-=255;return t[e]},n}(),a=function(){var t=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],e=function(t,e){var i={};return i.totalCount=t,i.dataCount=e,i},i={},o=function(e,i){switch(i){case n.L:return t[4*(e-1)+0];case n.M:return t[4*(e-1)+1];case n.Q:return t[4*(e-1)+2];case n.H:return t[4*(e-1)+3];default:return}};return i.getRSBlocks=function(t,i){var n=o(t,i);if(\"undefined\"==typeof n)throw new Error(\"bad rs block @ typeNumber:\"+t+\"/errorCorrectLevel:\"+i);for(var r=n.length/3,s=new Array,a=0;r>a;a+=1)for(var l=n[3*a+0],h=n[3*a+1],c=n[3*a+2],u=0;l>u;u+=1)s.push(e(h,c));return s},i}(),l=function(){var t=new Array,e=0,i={};return i.getBuffer=function(){return t},i.getAt=function(e){var i=Math.floor(e/8);return 1==(t[i]>>>7-e%8&1)},i.put=function(t,e){for(var n=0;e>n;n+=1)i.putBit(1==(t>>>e-n-1&1))},i.getLengthInBits=function(){return e},i.putBit=function(i){var n=Math.floor(e/8);t.length>>e%8),e+=1},i},h=function(t){var n=i.MODE_8BIT_BYTE,o=e.stringToBytes(t),r={};return r.getMode=function(){return n},r.getLength=function(t){return o.length},r.write=function(t){for(var e=0;e>>8)},e.writeBytes=function(t,i,n){i=i||0,n=n||t.length;for(var o=0;n>o;o+=1)e.writeByte(t[o+i])},e.writeString=function(t){for(var i=0;it);else{if(26>t)return 65+t;if(52>t)return 97+(t-26);if(62>t)return 48+(t-52);if(62==t)return 43;if(63==t)return 47}throw new Error(\"n:\"+t)};return o.writeByte=function(n){for(t=t>>e-6),e-=6},o.flush=function(){if(e>0&&(r(to;){if(i>=e.length){if(0==o)return-1;throw new Error(\"unexpected end of file./\"+o)}var t=e.charAt(i);if(i+=1,\"=\"==t)return o=0,-1;t.match(/^\\s$/)||(n=n>o-8&255;return o-=8,r};var s=function(t){if(t>=65&&90>=t)return t-65;if(t>=97&&122>=t)return t-97+26;if(t>=48&&57>=t)return t-48+52;if(43==t)return 62;if(47==t)return 63;throw new Error(\"c:\"+t)};return r},p=function(t,e){var i=t,n=e,o=new Array(t*e),r={};r.setPixel=function(t,e,n){o[e*i+t]=n},r.write=function(t){t.writeString(\"GIF87a\"),t.writeShort(i),t.writeShort(n),t.writeByte(128),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(0),t.writeByte(255),t.writeByte(255),t.writeByte(255),t.writeString(\",\"),t.writeShort(0),t.writeShort(0),t.writeShort(i),t.writeShort(n),t.writeByte(0);var e=2,o=a(e);t.writeByte(e);for(var r=0;o.length-r>255;)t.writeByte(255),t.writeBytes(o,r,255),r+=255;t.writeByte(o.length-r),t.writeBytes(o,r,o.length-r),t.writeByte(0),t.writeString(\";\")};var s=function(t){var e=t,i=0,n=0,o={};return o.write=function(t,o){if(t>>>o!=0)throw new Error(\"length over\");for(;i+o>=8;)e.writeByte(255&(t>=8-i,n=0,i=0;n|=t12,128|n>>6&63,128|63&n):(i++,n=65536+((1023&n)18,128|n>>12&63,128|n>>6&63,128|63&n))}return e}return e(t)}}(t),t}()),function(t){t.fn.share=function(e){function i(e,i){var n=o(i);\"prepend\"==i.mode?n.reverse():n,n.length&&t.each(n,function(n,o){var s=r(o,i),a=i.initialized?e.find(\".icon-\"+o):t('');return!a.length||(a.prop(\"aria-label\",\"分享到 \"+f[o]),a.prop(\"href\",s),\"wechat\"===o?a.prop(\"tabindex\",-1):a.prop(\"target\",\"_blank\"),void(i.initialized||(\"prepend\"==i.mode?e.prepend(a):e.append(a))))})}function n(t,e){var i=t.find(\"a.icon-wechat\");i.length&&(i.append(''+e.wechatQrcodeTitle+''+e.wechatQrcodeHelper+\"\"),i.find(\".qrcode\").qrcode({render:\"image\",size:e.wechatQrcodeSize,text:e.url}),i.offset().top"},{"title":"Repositories","date":"2022-06-25T04:52:51.994Z","updated":"2022-06-25T04:52:51.994Z","comments":false,"path":"repository/index.html","permalink":"http://fyupeng.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-25T05:51:47.109Z","updated":"2022-06-25T05:51:47.109Z","comments":false,"path":"tags/index.html","permalink":"http://fyupeng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"nacos一键启动、停止、查看状态脚本","slug":"nacos一键启动、停止、查看状态脚本","date":"2023-02-28T02:17:50.000Z","updated":"2023-02-28T03:11:47.921Z","comments":true,"path":"2023/02/28/nacos一键启动、停止、查看状态脚本/","link":"","permalink":"http://fyupeng.github.io/2023/02/28/nacos%E4%B8%80%E9%94%AE%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E8%84%9A%E6%9C%AC/","excerpt":"","text":"一、直接给代码1. start.sh 使用方法1234[root@localhost] #lsnacos./start.sh ./nacos -m standalone # 单机模式./start.sh ./nacos -m cluster # 集群模式 代码12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bashfunction read_dir() &#123; for file in `ls $1` do if [[ -d $1&quot;/&quot;$file ]]; then read_dir $1&quot;/&quot;$file $2 $3 else if [[ -f $1&quot;/&quot;$file ]] &amp;&amp; [[ &quot;$file&quot; = startup.sh ]]; then cd ./$1 if [[ &quot;$2&quot; = &quot;-m&quot; ]]; then if [[ &quot;$3&quot; = &quot;standalone&quot; ]]; then ./startup.sh -m standalone &gt; /dev/null echo $1$file 单机模式启动成功！ cd - &gt; /dev/null elif [[ &quot;$3&quot; = &quot;cluster&quot; ]]; then ./startup.sh -m cluster &gt; /dev/null echo $1$file 集群模式启动成功！ cd - &gt; /dev/null else echo &quot;1adUsage: ./startup.sh [Directory] -m [standalone | cluster]&quot; fi else echo &quot;2Usage: ./startup.sh [Directory] -m [standalone | cluster]&quot; exit -1; fi fi fi done&#125;# 读取第一个参数read_dir $1 $2 $3 2. status.sh 使用方法 1234[root@localhost] #lsnacos./status.sh ./nacos -m standalone # 单机模式./status.sh ./nacos -m cluster # 集群模式 代码 1234567891011121314151617181920212223#!/bin/bashtarget_dir=$1if [[ &quot;$target_dir&quot; = &quot;&quot; ]] || [[ ! -d $target_dir ]];then echo &quot;Usage: ./status.sh [Dir]&quot;fipid=`ps ax | grep -i &#x27;nacos.nacos&#x27; | grep $&#123;target_dir&#125; | grep java | grep -v grep | awk &#x27;&#123;print $1&#125;&#x27;`if [[ -z &quot;$pid&quot; ]];then echo &quot;No NacosServer running.&quot; exit -1;fiecho &quot;The nacosServer $1&quot;nacos-server.jar&quot; is running, it&#x27;s pids as follow:&quot;echo &quot;$pid&quot; 3.stop.sh 使用方法 1234[root@localhost] #lsnacos./status.sh ./nacos -m standalone # 单机模式./status.sh ./nacos -m cluster # 集群模式 代码 12345678910111213141516171819#!/bin/bashtarget_dir=$1pid=`ps ax | grep -i &#x27;nacos.nacos&#x27; | grep $&#123;target_dir&#125; | grep java | grep -v grep | awk &#x27;&#123;print $1&#125;&#x27;`if [ -z &quot;$pid&quot; ] ; then echo &quot;No nacosServer running.&quot; exit -1;fiecho &quot;The nacosServer $1&quot;nacos-server.jar&quot; is running, it&#x27;s pids as follow:&quot;echo &quot;$pid&quot;kill $&#123;pid&#125;echo &quot;Services stop successfully！ which has been killed forcibly!&quot;echo pid as follow: echo &quot;$pid&quot; 二、结束语评论区可留言，可私信，可互相交流学习，共同进步，小生会努力写出优质文章，期待同友多多回访。 专注品质，热爱生活。交流技术，寻求同志。","categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"http://fyupeng.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java工具","slug":"Java工具","permalink":"http://fyupeng.github.io/tags/Java%E5%B7%A5%E5%85%B7/"}],"author":null},{"title":"vue一键启动、停止、查看状态实用工具","slug":"vue一键启动、停止、查看状态实用工具","date":"2023-02-01T04:07:59.000Z","updated":"2023-02-01T04:08:28.254Z","comments":true,"path":"2023/02/01/vue一键启动、停止、查看状态实用工具/","link":"","permalink":"http://fyupeng.github.io/2023/02/01/vue%E4%B8%80%E9%94%AE%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/","excerpt":"","text":"一、直接给代码1. start.sh1234567891011121314151617181920#!/bin/bashfunction read_dir() &#123;if [ $# -eq 0 ]then echo &quot;Usage: $0 [DirFile]&quot; exit 1fiecho &quot;Service is starting....&quot; cd ./$1mkdir logs/ &amp;&gt; /dev/null &amp;nohup npm run serve &gt;&amp; logs/catalina-$(date +%Y-%m-%d).log &amp;echo &quot;Service starting succuesful!&quot;&#125;read_dir $1 2. stop.sh1234567891011121314151617181920212223242526272829303132# !/bin/bashfunction read_dir() &#123;if [ $# -eq 0 ]then echo &quot;Usage: $0 [DirFile]&quot; exit 1fiecho &quot;Service is stop....&quot;if [[ -f $1 ]]then echo &quot;$1 is not a DirFile!&quot; exit 1fipid=`ps -ef | grep $1 | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`if [ -z $pid ]; then echo &quot;&quot; echo &quot;Service $1 is not running! It&#x27;s not necessary to stop it!&quot; echo &quot;&quot;else kill -9 $pid echo &quot;&quot; echo &quot;Servuce stop successfuly! pid:$&#123;pid&#125; which has been killid forcibly!&quot; echo &quot;&quot;fi&#125;read_dir $1 3.status.sh1234567891011121314151617181920212223242526272829# !/bin/bashfunction read_dir() &#123;if [ $# -eq 0 ]then echo &quot;Usage: $0 [DirFile]&quot; exit 1fiif [[ -f $1 ]]then echo &quot;$1 is not a DirFile!&quot; exit 1fipid=`ps -ef | grep $1 | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`if [ -z $pid ]; then echo &quot;&quot; echo &quot;Service $1 is not running!&quot; echo &quot;&quot;else echo &quot;&quot; echo &quot;Servuce $1 is running. It&#x27;s pids=$&#123;pid&#125;&quot; echo &quot;&quot;fi&#125;read_dir $1 二、结束语评论区可留言，可私信，可互相交流学习，共同进步，欢迎各位给出意见或评价，本人致力于做到优质文章，希望能有幸拜读各位的建议！ 专注品质，热爱生活。交流技术，寻求同志。—— 嗝屁小孩纸 QQ：1160886967","categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"http://fyupeng.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java工具","slug":"Java工具","permalink":"http://fyupeng.github.io/tags/Java%E5%B7%A5%E5%85%B7/"}],"author":null},{"title":"jar包批量启动、查看状态、关闭脚本","slug":"jar包批量启动、查看状态、关闭脚本","date":"2023-02-01T03:55:30.000Z","updated":"2023-02-01T03:58:10.664Z","comments":true,"path":"2023/02/01/jar包批量启动、查看状态、关闭脚本/","link":"","permalink":"http://fyupeng.github.io/2023/02/01/jar%E5%8C%85%E6%89%B9%E9%87%8F%E5%90%AF%E5%8A%A8%E3%80%81%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E3%80%81%E5%85%B3%E9%97%AD%E8%84%9A%E6%9C%AC/","excerpt":"","text":"一、直接给代码1. start.sh1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env bash # 配置文件名称# (该配置文件放置在jar包同级目录下并且必须存在已经配置文件名称具备统一性！！！请根据实际的配置文件名称进行修改)CONFIG_FILE_NAME=&quot;application.properties&quot;# 启动一个目录下的所有jar包function read_dir()&#123;for file in `ls $1`do #如果当前文件是文件夹则递归处理 if [ -d $1&quot;/&quot;$file ]; then read_dir $1&quot;/&quot;$file else # 当前文件不是一个文件夹 if [[ -f $1&quot;/&quot;$file ]]; then # 如果当前文件是一个.jar结尾的文件则启动它 if [[ $&#123;file:0-4&#125; == &#x27;.jar&#x27; ]]; then echo $1/$file 开始启动... cd ./$1 #nohup java -jar $1&quot;/&quot;$file --spring.config.location=$1&quot;/&quot;$CONFIG_FILE_NAME &gt; /dev/null &amp; if [[ ! -d &quot;./logs/&quot; ]]; then mkdir &quot;./logs&quot; &gt; /dev/nul fi nohup java -jar -Dlogging.config=&quot;./config/logback.xml&quot; &quot;./&quot;$file &gt; &quot;./logs/catalina.log&quot; &amp; #nohup java -jar ./$file &gt; ./logs/catalina.log &amp; echo $1&quot;/&quot;$file 启动成功! echo &quot;&quot; cd - &gt; /dev/null fi fi fidone&#125;#读取第一个参数read_dir $1 2. status.sh123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env bash# 查看某个目录下所有jar程序的状态function read_dir()&#123;for file in `ls $1`do #如果当前文件是文件夹则递归处理 if [ -d $1&quot;/&quot;$file ] then read_dir $1&quot;/&quot;$file else # 当前文件不是一个文件夹 if [[ -f $1&quot;/&quot;$file ]] then if [[ $&#123;file:0-4&#125; == &#x27;.jar&#x27; ]]; then # 获取pid pid=`ps -ef | grep $file | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;` # -z 表示如果$pid为空时则输出提示 if [ -z $pid ];then echo &quot;&quot; echo &quot;Service $file is not running!&quot; echo &quot;&quot; else echo &quot;&quot; echo &quot;Service $1&quot;/&quot;$file is running. It&#x27;s pids=$&#123;pid&#125;&quot; echo &quot;&quot; fi fi fi fidone&#125;#读取第一个参数read_dir $1 3.stop.sh123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env bash# 停止一个目录下的所有jar程序function read_dir()&#123;for file in `ls $1`do #如果当前文件是文件夹则递归处理 if [ -d $1&quot;/&quot;$file ] then read_dir $1&quot;/&quot;$file else # 当前文件不是一个文件夹 if [[ -f $1&quot;/&quot;$file ]] then if [[ $&#123;file:0-4&#125; == &#x27;.jar&#x27; ]]; then # 获取pid # 模糊匹配 $file 进程| 过滤自身命令进程 | 输出进程表中的进程号 pid=`ps -ef | grep $file | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;` # -z 表示如果$pid为空时则输出提示 if [ -z $pid ]; then echo &quot;Service $file is not running! It&#x27;s not necessary to stop it!&quot; else # 杀死进程 kill -9 $pid echo &quot;Service stop successfully！pid:$&#123;pid&#125; which has been killed forcibly!&quot; echo &quot;&quot; fi fi fi fidone&#125;#读取第一个参数read_dir $1 二、结束语评论区可留言，可私信，可互相交流学习，共同进步，欢迎各位给出意见或评价，本人致力于做到优质文章，希望能有幸拜读各位的建议！ 专注品质，热爱生活。交流技术，寻求同志。","categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"http://fyupeng.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java工具","slug":"Java工具","permalink":"http://fyupeng.github.io/tags/Java%E5%B7%A5%E5%85%B7/"}],"author":null},{"title":"宕机检测、重启、告警开发工具","slug":"宕机检测、重启、告警开发工具","date":"2023-02-01T03:55:08.000Z","updated":"2023-02-01T03:57:29.585Z","comments":true,"path":"2023/02/01/宕机检测、重启、告警开发工具/","link":"","permalink":"http://fyupeng.github.io/2023/02/01/%E5%AE%95%E6%9C%BA%E6%A3%80%E6%B5%8B%E3%80%81%E9%87%8D%E5%90%AF%E3%80%81%E5%91%8A%E8%AD%A6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/","excerpt":"","text":"一、直接给代码1. keepalived.conf安装详见 keepalived安装教程配置前请备份好原文件，新建文件夹/etc/keepalived并将副本keepalived.conf复制到/etc/keepalived即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546!Configuration File for keepalivedglobal_defs &#123; router_id master notification_email &#123; ******@163.com &#125; notification_email_from ******@126.com smtp_server 127.0.0.1 smtp_connect_timeout 30&#125;vrrp_script chk_http_port &#123; # 脚本检测工具，见 3.nginx_check.sh script &quot;/usr/local/src/nginx_check.sh&quot; interval 2 #（检测脚本执行的间隔） weight -20&#125;vrrp_instance VI_1 &#123; state MASTER # 备份服务器上将 MASTER 改为 BACKUP ## 具体网卡请 键入命令 ip a 查看有哪些来进行配置 interface eth0 //网卡 virtual_router_id 1 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 authentication &#123; auth_type PASS auth_pass root123 &#125; track_script&#123; # 这里调用检测脚本执行，一秒检测一次 chk_http_port &#125; # 根据 内网子网 设置虚拟地址，用于转发，keepalived集群不在此章节 virtual_ipaddress &#123; 192.168.0.100/24 dev eth0 label eth0:1 &#125; #配置keepalived发生故障转移时，触发执行的脚本 notify_master &quot;/etc/keepalived/notify.sh master &quot; notify_backup &quot;/etc/keepalived/notify.sh backup &quot; notify_fault &quot;/etc/keepalived/notify.sh fault &quot;&#125; 2. notify.sh12345678910111213141516171819202122232425262728293031#!/bin/bash#接收者邮箱，多个以空格分隔contact=(******@163.com ******@qq.com)#本机ipHOST_IP=192.168.0.100/24notify() &#123;#邮件主题 mailsubject=&quot;vip转移,$HOST_IP keepalived to be $1&quot; #邮件正文 mailbody=&quot;$(date +&#x27;%F %T&#x27;): 节点切换, $HOST_IP keepalived changed to be $1&quot; for receiver in $&#123;contact[*]&#125; do #发送邮件 echo &quot;$mailbody&quot; | mail -s &quot;$mailsubject&quot; $receiver done&#125;case $1 inmaster) notify master ;;backup) notify backup ;;fault) notify fault ;;*) echo &quot;Usage:&#123;master|backup|fault&#125;&quot; exit 1 ;;esac 3.nginx_check.sh以nginx为例，脚本用于宕机检测和重启 12345678910111213#!/usr/bin/env bashecho &#x27; a&#x27;A=`ps -C nginx --no-header |wc -l`if [ $A -eq 0 ];then # 开启nginx服务 /usr/local/nginx/sbin/nginx sleep 1 # nginx没有启动成功 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then # 杀死keepalived进程 killall keepalived fifi 4.mail.rc告警邮件发送配置，需要安装相关依赖 1yum -y install mailx 配置/etc/mail.rc 12345678910111213141516171819202122232425# This is the configuration file for Heirloom mailx (formerly# known under the name &quot;nail&quot;.# See mailx(1) for further options.# This file is not overwritten when &#x27;make install&#x27; is run in# the mailx build process again.# Sccsid @(#)nail.rc 2.11 (gritter) 8/2/08# Do not forward to mbox by default since this is likely to be# irritating for most users today.# 末尾追加6行配置即可#发送邮件的邮箱set from=******@126.com#smtp邮件服务器set smtp=smtp.126.com#发送邮件的邮箱用户set smtp-auth-user=******@126.com#邮箱授权码set smtp-auth-password=******set smtp-auth=loginset ssl-verify=ignore 二、效果展示 keepalived 服务 启动1systemctl start keepalived 查看状态1systemctl status keepalived 关闭1systemctl stop keepalived 重启1systemctl restart keepalived 手动关闭nginx服务，keepalived自动检测并重启 注意 检测周期必须大于notify.sh脚本睡眠时间。 告警邮件 三、结束语评论区可留言，可私信，可互相交流学习，共同进步，欢迎各位给出意见或评价，本人致力于做到优质文章，希望能有幸拜读各位的建议！ 专注品质，热爱生活。交流技术，寻求同志。","categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"http://fyupeng.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java脚本","slug":"Java脚本","permalink":"http://fyupeng.github.io/tags/Java%E8%84%9A%E6%9C%AC/"}],"author":null},{"title":"TCP三次握手和四次挥手","slug":"TCP三次握手和四次挥手","date":"2023-01-09T09:43:24.000Z","updated":"2023-01-09T09:44:48.118Z","comments":true,"path":"2023/01/09/TCP三次握手和四次挥手/","link":"","permalink":"http://fyupeng.github.io/2023/01/09/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"","text":"三次握手 先ping域名为www.baidu.com，便于`DNS`解析。`ping`走的协议就包括`DNS`、`ARP`和`ICMP`。![image-20230109150250842](https://yupeng-tuchuang.oss-cn-shenzhen.aliyuncs.com/image-20230109150250842.png) 接着使用Wireshark去抓包，抓包这里导航栏直接过滤ip就可以了，输入ip.host == 183.232.231.174 接着直接在浏览器输入百度域名www.baidu.com访问请求，Wireshark就能抓取包来分析了![image-20230109150841554](https://yupeng-tuchuang.oss-cn-shenzhen.aliyuncs.com/image-20230109150841554.png) 这里我们可以看到，本地通过ipconfig就可以看到source那一列为自己的ip地址，而且是客户端为前后各一次，服务端是第二次。 第一次为SYN标记请求，全英文名我的理解是Synchronized，即为同步，表示同步连接请求； 第二次为SYN + ACK组合标记请求，准确来说是两次请求（SYN第一次，ACK第二次），只不过优化对它进行合并了，SYN也表示连接，显而易见，想建立连接两方都要与对方发送同步包请求连接，ACK表示百度接收到了你的同步包，但怎么告知人家？用ACK = SYN(第一次握手的Sequence) + 1，算是一种默契，你收到该包后客户端完成了连接，但百度还未连接成功； 第三次为ACK标记请求，百度第二次握手发了一个ACK标记，说明这个包是对你前一个包的回应，由前两个图可知。剩下的一个SYN标记，是表明这个包也是一个连接请求包，需要你发回ACK包，即表明我收到了，但得告知你，最后你收到后，你也成功完成连接。 四次挥手 三次挥手需要客户端与服务端断开连接，我这里使用vmware去连接虚拟机centos来演示。跟三次握手一样，你要抓那个网络的包，你就要在这个网络中去连接，比如我的是192.168.10.1这个，用这个通过子网分配给了一台虚拟机192.168.10.100 通过xsell连接后，使用命令init 0来断开连接，这会让服务器和客户端都断开连接。分清楚我是虚拟机，服务器是虚拟适配器VMnet8，因为我是在虚拟机里主动命令断开的。抓取信息如下：（将FIN顺带的ACK忽略，就是标准的四次挥手） 第一次为FIN标记请求，表示自己要断开连接了，不会再发送消息。 第二次为ACK标记请求，表示服务器收到了，然后服务器不再接收消息，但还是会发送消息，所以这是还未发送FIN包。从这个时候我还是可以接收服务器的消息的，所以我这边还不能断开。 而有些不用接收数据就可以是三次挥手，是将ACK与FIN结合一起，如上图就是，只不过是发FIN请求时带上了ACK，但第一次还是发了ACK，才不会让对方以为没收到导致重发，这样才不会对网络造成阻塞。 第三次为FIN 标记请求，这时FIN表示服务器收到我要断开连接的消息，那它也准备断开连接了，不再发送消息，那我也不必再接收了，于是我就完成挥手，原则上是可以断开了，但服务端还不知情，还是不能断开。这里要注意，其实第二次与第三次之间应该还是有很多次请求，这些请求是消息的发送和接收，不算入断开连接中的挥手，而且这些请求都跟第二次挥手以及本次挥手的Acknowledgment number相同。 第四次是ACK标记请求，就是我要告知VMnet8我已经完成挥手了，你可以断开了。VMnet8收到就可以立即断开，而我等待2MSL时间内没收到服务端重发包就可以断开。因为MSL即为包在网络中的最大生存时间，我发一次和对方未收到超时重发。","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"计算机网络面经","slug":"计算机网络面经","permalink":"http://fyupeng.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/"}],"author":null},{"title":"牛客必会SQL","slug":"牛客必会SQL","date":"2022-12-06T01:17:59.000Z","updated":"2022-12-06T01:19:27.466Z","comments":true,"path":"2022/12/06/牛客必会SQL/","link":"","permalink":"http://fyupeng.github.io/2022/12/06/%E7%89%9B%E5%AE%A2%E5%BF%85%E4%BC%9ASQL/","excerpt":"","text":"牛客SQL 1. SQL91 返回购买价格为 10 美元或以上产品的顾客列表 描述 示例1 解法1 - 内联 解法2 - 子查询 2. SQL92 确定哪些订单购买了 prod_id 为 BR01 的产品（一） 描述 示例1 解法1 - 内联 解法2 - 子查询 3. SQL93 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一） 描述 示例1 解法1 解法2 4. SQL94 返回每个顾客不同订单的总金额 描述 示例1 5. SQL100 确定最佳顾客的另一种方式（二） 描述 示例1 解法 6. SQL108 组合 Products 表中的产品名称和 Customers 表中的顾客名称 描述 示例1 解法 1. SQL91 返回购买价格为 10 美元或以上产品的顾客列表描述OrderItems表示订单商品表，含有字段订单号：order_num、订单价格：item_price；Orders表代表订单信息表，含有顾客id：cust_id和订单号：order_num OrderItems表 order_num item_price a1 10 a2 1 a2 1 a4 2 a5 5 a2 1 a7 7 Orders表 order_num cust_id a1 cust10 a2 cust1 a2 cust1 a4 cust2 a5 cust5 a2 cust1 a7 cust7 【问题】使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。注意：你需要使用 OrderItems 表查找匹配的订单号（order_num），然后使用Order 表检索这些匹配订单的顾客 ID（cust_id）。 【示例结果】返回顾客id cust_id cust_id cust10 【示例解析】 cust10顾客下单的订单为a1，a1的售出价格大于等于10 示例1输入： 12345678910111213DROP TABLE IF EXISTS `OrderItems`; CREATE TABLE IF NOT EXISTS `OrderItems`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, item_price INT(16) NOT NULL COMMENT &#x27;售出价格&#x27; ); INSERT `OrderItems` VALUES (&#x27;a1&#x27;,10),(&#x27;a2&#x27;,1),(&#x27;a2&#x27;,1),(&#x27;a4&#x27;,2),(&#x27;a5&#x27;,5),(&#x27;a2&#x27;,1),(&#x27;a7&#x27;,7); DROP TABLE IF EXISTS `Orders`; CREATE TABLE IF NOT EXISTS `Orders`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, cust_id VARCHAR(255) NOT NULL COMMENT &#x27;顾客id&#x27; ); INSERT `Orders` VALUES (&#x27;a1&#x27;,&#x27;cust10&#x27;),(&#x27;a2&#x27;,&#x27;cust1&#x27;),(&#x27;a2&#x27;,&#x27;cust1&#x27;),(&#x27;a4&#x27;,&#x27;cust2&#x27;),(&#x27;a5&#x27;,&#x27;cust5&#x27;),(&#x27;a2&#x27;,&#x27;cust1&#x27;),(&#x27;a7&#x27;,&#x27;cust7&#x27;); 输出： 1cust10 解法1 - 内联12345select cust_idfrom OrderItems oiinner join Orders oon oi.order_num = o.order_numwhere item_price &gt;= 10 解法2 - 子查询123456789select cust_idfrom Orderswhere order_num in( select order_num from OrderItems where item_price &gt;= 10) 数据量大的情况下，使用连接查询效率更高，因为子查询相当于for循环，要执行多次子查询，而连接只需要查询一次; 数据量小的情况下，子查询更容易控制和操作。 2. SQL92 确定哪些订单购买了 prod_id 为 BR01 的产品（一）描述表OrderItems代表订单商品信息表，prod_id为产品id；Orders表代表订单表有cust_id代表顾客id和订单日期order_date OrderItems表 prod_id order_num BR01 a0001 BR01 a0002 BR02 a0003 BR02 a0013 Orders表 order_num cust_id order_date a0001 cust10 2022-01-01 00:00:00 a0002 cust1 2022-01-01 00:01:00 a0003 cust1 2022-01-02 00:00:00 a0013 cust2 2022-01-01 00:20:00 【问题】 编写 SQL 语句，使用子查询来确定哪些订单（在 OrderItems 中）购买了 prod_id 为 “BR01“ 的产品，然后从 Orders 表中返回每个产品对应的顾客 ID（cust_id）和订单日期（order_date），按订购日期对结果进行升序排序。 【示例结果】返回顾客id cust_id和定单日期order_date。 cust_id order_date cust10 2022-01-01 00:00:00 cust1 2022-01-01 00:01:00 【示例解析】 产品id为”BR01“的订单a0001和a002的下单顾客cust10和cust1的下单时间分别为2022-01-01 00:00:00和2022-01-01 00:01:00 示例1输入： 1234567891011121314DROP TABLE IF EXISTS `OrderItems`; CREATE TABLE IF NOT EXISTS `OrderItems`( prod_id VARCHAR(255) NOT NULL COMMENT &#x27;产品id&#x27;, order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27; ); INSERT `OrderItems` VALUES (&#x27;BR01&#x27;,&#x27;a0001&#x27;),(&#x27;BR01&#x27;,&#x27;a0002&#x27;),(&#x27;BR02&#x27;,&#x27;a0003&#x27;),(&#x27;BR02&#x27;,&#x27;a0013&#x27;); DROP TABLE IF EXISTS `Orders`; CREATE TABLE IF NOT EXISTS `Orders`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, cust_id VARCHAR(255) NOT NULL COMMENT &#x27;顾客id&#x27;, order_date TIMESTAMP NOT NULL COMMENT &#x27;下单时间&#x27; ); INSERT `Orders` VALUES (&#x27;a0001&#x27;,&#x27;cust10&#x27;,&#x27;2022-01-01 00:00:00&#x27;),(&#x27;a0002&#x27;,&#x27;cust1&#x27;,&#x27;2022-01-01 00:01:00&#x27;),(&#x27;a0003&#x27;,&#x27;cust1&#x27;,&#x27;2022-01-02 00:00:00&#x27;),(&#x27;a0013&#x27;,&#x27;cust2&#x27;,&#x27;2022-01-01 00:20:00&#x27;); 复制 输出： 12cust10|2022-01-01 00:00:00cust1|2022-01-01 00:01:00 解法1 - 内联1234567select cust_id, order_datefrom OrderItems oiinner joinOrders oon oi.order_num = o.order_numwhere prod_id = &#x27;BR01&#x27;order by order_date 解法2 - 子查询123456789select cust_id, order_datefrom Orderswhere order_num in( select order_num from OrderItems where prod_id = &#x27;BR01&#x27;)order by order_date 3. SQL93 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）描述你想知道订购 BR01 产品的日期，有表OrderItems代表订单商品信息表，prod_id为产品id；Orders表代表订单表有cust_id代表顾客id和订单日期order_date；Customers表含有cust_email 顾客邮件和cust_id顾客id OrderItems表 prod_id order_num BR01 a0001 BR01 a0002 BR02 a0003 BR02 a0013 Orders表 order_num cust_id order_date a0001 cust10 2022-01-01 00:00:00 a0002 cust1 2022-01-01 00:01:00 a0003 cust1 2022-01-02 00:00:00 a0013 cust2 2022-01-01 00:20:00 Customers表代表顾客信息，cust_id为顾客id，cust_email为顾客email cust_id cust_email cust10 cust10@cust.com cust1 cust1@cust.com cust2 cust2@cust.com 【问题】返回购买 prod_id 为BR01 的产品的所有顾客的电子邮件（Customers 表中的 cust_email），结果无需排序。 提示：这涉及 SELECT 语句，最内层的从 OrderItems 表返回 order_num，中间的从 Customers 表返回 cust_id。 【示例结果】 返回顾客email cust_email cust_email cust10@cust.com cust1@cust.com `【示例解析】 产品id为BR01的订单a0001和a002的下单顾客cust10和cust1的顾客email cust_email分别是：&#99;&#x75;&#x73;&#x74;&#49;&#48;&#x40;&#99;&#117;&#115;&#x74;&#46;&#x63;&#x6f;&#109; 、&#99;&#117;&#115;&#116;&#x31;&#64;&#x63;&#x75;&#115;&#116;&#46;&#x63;&#111;&#109; 示例1输入： 123456789101112131415161718192021DROP TABLE IF EXISTS `OrderItems`; CREATE TABLE IF NOT EXISTS `OrderItems`( prod_id VARCHAR(255) NOT NULL COMMENT &#x27;产品id&#x27;, order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27; ); INSERT `OrderItems` VALUES (&#x27;BR01&#x27;,&#x27;a0001&#x27;),(&#x27;BR01&#x27;,&#x27;a0002&#x27;),(&#x27;BR02&#x27;,&#x27;a0003&#x27;),(&#x27;BR02&#x27;,&#x27;a0013&#x27;); DROP TABLE IF EXISTS `Orders`; CREATE TABLE IF NOT EXISTS `Orders`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, cust_id VARCHAR(255) NOT NULL COMMENT &#x27;顾客id&#x27;, order_date TIMESTAMP NOT NULL COMMENT &#x27;下单时间&#x27; ); INSERT `Orders` VALUES (&#x27;a0001&#x27;,&#x27;cust10&#x27;,&#x27;2022-01-01 00:00:00&#x27;),(&#x27;a0002&#x27;,&#x27;cust1&#x27;,&#x27;2022-01-01 00:01:00&#x27;),(&#x27;a0003&#x27;,&#x27;cust1&#x27;,&#x27;2022-01-02 00:00:00&#x27;),(&#x27;a0013&#x27;,&#x27;cust2&#x27;,&#x27;2022-01-01 00:20:00&#x27;);DROP TABLE IF EXISTS `Customers`;CREATE TABLE IF NOT EXISTS `Customers`( cust_id VARCHAR(255) NOT NULL COMMENT &#x27;顾客id&#x27;, cust_email VARCHAR(255) NOT NULL COMMENT &#x27;顾客email&#x27; );INSERT `Customers` VALUES (&#x27;cust10&#x27;,&#x27;cust10@cust.com&#x27;),(&#x27;cust1&#x27;,&#x27;cust1@cust.com&#x27;),(&#x27;cust2&#x27;,&#x27;cust2@cust.com&#x27;); 输出： 12cust10@cust.comcust1@cust.com 解法11234567select cust_emailfrom OrderItems oiinner join Orders oinner join Customers con oi.order_num = o.order_num ando.cust_id = c.cust_idwhere prod_id = &#x27;BR01&#x27; 解法212345678910111213select cust_emailfrom Customerswhere cust_id in( select cust_id from Orders where order_num in ( select order_num from OrderItems where prod_id = &#x27;BR01&#x27; )) 4. SQL94 返回每个顾客不同订单的总金额描述我们需要一个顾客 ID 列表，其中包含他们已订购的总金额。 OrderItems表代表订单信息，OrderItems表有订单号：order_num和商品售出价格：item_price、商品数量：quantity。 order_num item_price quantity a0001 10 105 a0002 1 1100 a0002 1 200 a0013 2 1121 a0003 5 10 a0003 1 19 a0003 7 5 Orders表订单号：order_num、顾客id：cust_id order_num cust_id a0001 cust10 a0002 cust1 a0003 cust1 a0013 cust2 【问题】 编写 SQL语句，返回顾客 ID（Orders 表中的 cust_id），并使用子查询返回total_ordered 以便返回每个顾客的订单总数，将结果按金额从大到小排序。 提示：你之前已经使用 SUM()计算订单总数。 【示例结果】返回顾客id cust_id和total_order下单总额 cust_id total_ordered cust2 2242 cust1 1300 cust10 1050 cust2 104 【示例解析】cust2在Orders里面的订单a0013，a0013的售出价格是2售出数量是1121，总额是2242，最后返回cust2的支付总额是2242。 示例1输入： 1234567891011121314DROP TABLE IF EXISTS `OrderItems`;CREATE TABLE IF NOT EXISTS `OrderItems`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, item_price INT(16) NOT NULL COMMENT &#x27;售出价格&#x27;, quantity INT(16) NOT NULL COMMENT &#x27;商品数量&#x27;);INSERT `OrderItems` VALUES (&#x27;a0001&#x27;,10,105),(&#x27;a0002&#x27;,1,1100),(&#x27;a0002&#x27;,1,200),(&#x27;a0013&#x27;,2,1121),(&#x27;a0003&#x27;,5,10),(&#x27;a0003&#x27;,1,19),(&#x27;a0003&#x27;,7,5);DROP TABLE IF EXISTS `Orders`;CREATE TABLE IF NOT EXISTS `Orders`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, cust_id VARCHAR(255) NOT NULL COMMENT &#x27;顾客id&#x27;);INSERT `Orders` VALUES (&#x27;a0001&#x27;,&#x27;cust10&#x27;),(&#x27;a0003&#x27;,&#x27;cust1&#x27;),(&#x27;a0013&#x27;,&#x27;cust2&#x27;); 输出： 123cust2|2242.000cust10|1050.000cust1|104.000 解法123456select cust_id, sum(item_price * quantity) as total_orderedfrom OrderItems oiinner join Orders oon oi.order_num = o.order_numgroup by cust_idorder by sum(item_price * quantity) desc 5. SQL100 确定最佳顾客的另一种方式（二）描述OrderItems表代表订单信息，确定最佳顾客的另一种方式是看他们花了多少钱，OrderItems表有订单号order_num和item_price商品售出价格、quantity商品数量 order_num item_price quantity a1 10 105 a2 1 1100 a2 1 200 a4 2 1121 a5 5 10 a2 1 19 a7 7 5 Orders表含有字段order_num 订单号、cust_id顾客id order_num cust_id a1 cust10 a2 cust1 a3 cust2 a4 cust22 a5 cust221 a7 cust2217 顾客表Customers有字段cust_id 客户id、cust_name 客户姓名 cust_id cust_name cust10 andy cust1 ben cust2 tony cust22 tom cust221 an cust2217 hex 【问题】编写 SQL 语句，返回订单总价不小于1000 的客户名称和总额（OrderItems 表中的order_num）。 提示：需要计算总和（item_price 乘以 quantity）。按总额对结果进行排序，请使用INNER JOIN 语法。 【示例结果】 cust_name total_price andy 1050 ben 1319 tom 2242 【示例解析】 总额（item_price 乘以 quantity）大于等于1000的订单号，例如a2对应的顾客id为cust1，cust1的顾客名称cust_name是ben，最后返回ben作为order_num a2的quantity * item_price总和的结果1319。 示例1输入： 12345678910111213141516171819202122DROP TABLE IF EXISTS `OrderItems`;CREATE TABLE IF NOT EXISTS `OrderItems`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, item_price INT(16) NOT NULL COMMENT &#x27;售出价格&#x27;, quantity INT(16) NOT NULL COMMENT &#x27;商品数量&#x27;);INSERT `OrderItems` VALUES (&#x27;a1&#x27;,10,105),(&#x27;a2&#x27;,1,1100),(&#x27;a2&#x27;,1,200),(&#x27;a4&#x27;,2,1121),(&#x27;a5&#x27;,5,10),(&#x27;a2&#x27;,1,19),(&#x27;a7&#x27;,7,5);DROP TABLE IF EXISTS `Customers`;CREATE TABLE IF NOT EXISTS `Customers`( cust_id VARCHAR(255) NOT NULL COMMENT &#x27;客户id&#x27;, cust_name VARCHAR(255) NOT NULL COMMENT &#x27;客户姓名&#x27;);INSERT `Customers` VALUES (&#x27;cust10&#x27;,&#x27;andy&#x27;),(&#x27;cust1&#x27;,&#x27;ben&#x27;),(&#x27;cust2&#x27;,&#x27;tony&#x27;),(&#x27;cust22&#x27;,&#x27;tom&#x27;),(&#x27;cust221&#x27;,&#x27;an&#x27;),(&#x27;cust2217&#x27;,&#x27;hex&#x27;);DROP TABLE IF EXISTS `Orders`;CREATE TABLE IF NOT EXISTS `Orders`( order_num VARCHAR(255) NOT NULL COMMENT &#x27;商品订单号&#x27;, cust_id VARCHAR(255) NOT NULL COMMENT &#x27;顾客id&#x27;);INSERT `Orders` VALUES (&#x27;a1&#x27;,&#x27;cust10&#x27;),(&#x27;a2&#x27;,&#x27;cust1&#x27;),(&#x27;a3&#x27;,&#x27;cust2&#x27;),(&#x27;a4&#x27;,&#x27;cust22&#x27;),(&#x27;a5&#x27;,&#x27;cust221&#x27;),(&#x27;a7&#x27;,&#x27;cust2217&#x27;); 输出： 123andy|1050.000ben|1319.000tom|2242.000 解法123456789select cust_name, sum(item_price * quantity) as total_pricefrom OrderItems oiinner join Orders oinner join Customers con oi.order_num = o.order_numand o.cust_id = c.cust_idgroup by cust_namehaving sum(item_price * quantity) &gt;= 1000order by total_price 6. SQL108 组合 Products 表中的产品名称和 Customers 表中的顾客名称描述Products表含有字段prod_name代表产品名称 prod_name flower rice ring umbrella Customers表代表顾客信息，cust_name代表顾客名称 cust_name andy ben tony tom an lee hex 【问题】 编写 SQL 语句，组合 Products 表中的产品名称（prod_name）和 Customers 表中的顾客名称（cust_name）并返回，然后按产品名称对结果进行升序排序。 【示例结果】 prod_name an andy ben flower hex lee rice ring tom tony umbrella 【示例解析】 拼接cust_name和prod_name并根据结果升序排序 示例1输入： 1234567891011121314DROP TABLE IF EXISTS `Products`;CREATE TABLE IF NOT EXISTS `Products` (`prod_name` VARCHAR(255) NOT NULL COMMENT &#x27;产品名称&#x27;);INSERT INTO `Products` VALUES (&#x27;flower&#x27;),(&#x27;rice&#x27;),(&#x27;ring&#x27;),(&#x27;umbrella&#x27;);DROP TABLE IF EXISTS `Customers`;CREATE TABLE IF NOT EXISTS `Customers`( cust_name VARCHAR(255) NOT NULL COMMENT &#x27;客户姓名&#x27;);INSERT `Customers` VALUES (&#x27;andy&#x27;),(&#x27;ben&#x27;),(&#x27;tony&#x27;),(&#x27;tom&#x27;),(&#x27;an&#x27;),(&#x27;lee&#x27;),(&#x27;hex&#x27;); 输出： 1234567891011anandybenflowerhexleericeringtomtonyumbrella 解法123456select prod_namefrom Productsunionselect cust_name as prod_namefrom Customersorder by prod_name","categories":[],"tags":[{"name":"SQL基础","slug":"SQL基础","permalink":"http://fyupeng.github.io/tags/SQL%E5%9F%BA%E7%A1%80/"}],"author":null},{"title":"腾讯一面","slug":"腾讯一面","date":"2022-11-29T13:08:12.000Z","updated":"2022-11-29T13:10:20.156Z","comments":true,"path":"2022/11/29/腾讯一面/","link":"","permalink":"http://fyupeng.github.io/2022/11/29/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/","excerpt":"","text":"自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目 + 意向岗位 腾讯子公司云智研发一面 1. 有了解过C++吗？接受转语言吗？2. 有没有了解过一些框架的底层原理、底层优化、数据库的索引优化3. 了解过哪些Map，可以从底层简单说下嘛？比如我最常使用的有HashMap、HashTable、CurrentHashMap这三种 HashMap它的底层是采用了数组+链表的数据结构 从源码中分析，HashMap有一个静态内部类Node，HashMap通过成员变量table（Node数组类型）来采取put和get操作，该成员变量用关键字transient加以修饰，表明禁止序列化。 而Node是table数组的一个结点，内部成员数据有hash、key、value和指向Node类的next – 初始化阶段 – 在这里，put操作后，table会先调用resize方法进行扩展，扩展后table才从null变为16位的Node数组，初始化后的每一个下标依旧为null，并且初始化阈值threshold，默认为0.75 * size,作用是与成员变量size（成员变量size会在每次put而且要该key值为首次操作即不存在该Map中会自增）进行比较，如果size数即表明put的key-value对的数量超过阈值threshold，进行下一步操作，即resize方法另一作用。 – 扩容阶段 – 扩容阶段更简单，就是将阈值*2来扩容，然后遍历整个table即Node数组，如果发现有Node结点，那么这里就出现了两种情况，第一种为每个结点上是链表结构，另一种则是红黑树结构。 扩容操作是创建新table来扩容，没有在旧table上直接扩容，遍历旧table进行扩容时，将会对每个table槽位置空，多线程在扩容时会发生一些导致线程安全的问题。 ConcurrentHashMap在JDK7扩容时使用到了ReentrantLock对段加锁，这样该段的旧table也无法操作，JDK则通过一种手段设置标志位，后面操作使用CAS乐观锁来操作，成功则退出，不成功发现扩容标志后则参与扩容。 扩容成功的结果就是发生链表转移或者是红黑树转移，都是为了将节点分散，以至于发挥出Hash一次命中取出和保存的高性能。 当然刚开始没有结点数据，oldTable为null，不需要转移结点，然后什么事都没干，接着通过hash与table的长度进行&amp;操作命中槽位，put操作会保存到数组对应下标处即槽位中的结点。 – 结点初始化 – 保存之前很简单，得判断对应Node数组下标结点是否为null，因为这里是懒加载嘛，刚开始没有初始化数组的每一个元素，resize初始化方法也只是new了个Node数组，而且这也一样是懒加载。 所以在这里会将put中key的hash、key和value值封装到Node结点中并实例化，然后赋值到对应的Node数组下标中。 如果结点已经实例化了，那么这里有两种方式，一是链表寻址，二是树寻址，然后就是找到就覆盖，找不到就追加。 – 链表寻址 – 寻址前会先判断结点类型，如果instanceof不是TreeNode，那么便是链表，然后就可以开始遍历链表了，如果找到了的话，key-value当然就是要覆盖了，但是这里对key的处理分为了两种： 分析之前，其实链表中所有结点都位于同一个数组下标，那么应该都必须满足每个结点的hash值相同，即槽位相同，所以会再一次判断hash值，才会用key去比较。 如果key为基本数据类型，那么是直接通过运算符==来比较的，为true，那么就直接跳出链表遍历了，然后将刚刚在链表访问后命中的Node结点value覆盖 如果key为复杂类型，那么仅仅通过==运算符比较是错误的，这里就需要我们去主动重写equals方法，让key值怎么比较才能相等，因为默认equals是Object比较，这里涉及到内存指针了，所以创建的对象一般内存都不同，除非浅拷贝。 只是我们一般都用String类型，而String类型已经帮我们重写过了，虽然String类型也算是复杂类型，它重写了Object的equals方法，使得不同对象可以进行比较，比较的是对应字符串序列的内容是否相同。 如果没找到，那么将实例化新的Node结点，然后追加到链表末尾，在JDK7中是追加到头结点，后来发现线程安全，即多线程情况下，有几率会导致链表出现死锁。 – 树寻址 – 首先了解下TreeNode，它继承了LinkedHashMap.Entry，而Entry又继承了HashMap.Node，归根结底还是跟链表的Node类似，只不过多了一些成员和方法。 树寻址是判断结点是否为树节点，一般在链表转变为红黑树之后才会进行，红黑树是一棵平衡的二叉有序树，即由哈希值排序的二叉树，从根节点依次比较哈希值并遍历到叶子节点依旧没有找到，通过哈希值比较的大小直接实例出一个新的树节点给原来叶子节点的左孩子节点或右孩子节点。 如果找到该节点，与链表一样的方法，则中断遍历并将该节点返回，在外部进行赋值操作。 – 链表转移 – 链表转移前会判断链表是否只有表头，即只有一个元素，那么通过寻找该结点Node的Hash值，与扩容后的lenth长度&amp;操作命中新的槽位 1234567/**e : table即Node数组中的一个下标元素newCap: 新table的容量e.hash: 哈希值，常用于与table长度做&amp;操作来命中寻址newTab: 新table*/newTab[e.hash &amp; (newCap - 1)] = e; 如果是链表结构，那么按照hash值对链表拆成高位和低位链表，这里的高低位不是字面意思，我是直译源码字面意思，从代码分析： 12345678/** 如果 hash 二进制数中 与 旧table的容量表示的二进制数 所在的 位为1 &amp; 为 真，则表示为高位链表如果 hash 二进制数中 与 旧table的容量表示的二进制数 所在的 位为1 &amp; 为 假，则表示为低位链表从随机性角度考虑，这两种散列均匀的话各占一半hash: 4字节的 int 类型oldCap: 4字节的 int 类型，默认初始化为 16，二进制表示为 10000*/e.hash &amp; oldCap) == 0 由于新table是旧table的两倍，那么低位链表命中赋值给新table中与旧table相同的下标，而高位从字面上理解，就要比低位更靠右，所以它的下标是原下标+oldCap，oldCap大小也是新table大小的一半，看图 – 转化红黑树 – 转化红黑树刚开始是不会触发的，在put操作的时候，在table中某个槽遍历链表时，如果链表长度达到扩展树阈值8，并且table长度要大于64。 链表满足长度8是树转移的必要条件，在table初始化后且发生转化红黑树前，会先去判断table长度是否达到64，没有则会扩容，扩容前面也详细说了，上面的图就很明确，达到8个节点的链表，扩容后链表拆成两部分，很明显没有必要再次去转化了。 如果长度满足，这时会先转变为双向链表，用于辅助树节点增加和删除以及维护树根节点。 转换红黑树是从遍历该链表开始，特殊处理第一个链表节点转成树节点，遍历这棵树，通过哈希值构造一颗排序树，每次构造新节点都是从叶子节点开始，不平衡就利用红黑标记来转为平衡树。 – 树转移 – 树转移发生在resize方法中，触发的事件是当前put成功后的所有元素个数大于table的阈值（容量 * 负载因子），接着会先扩容table的容量，树转移时，在put时hash命中的table中一个插槽发现是树节点，就开始转移，转移不是从树的逻辑转移，跟链表一样，只不过还有考虑前置节点，也就是跟树转移一样构造双向链表，拆成两条待转移成树的双向链表。 拆成的子双向链表，长度小于6就直接退化为链表，否则才将红黑树转移到新table的高低位上。 – 特殊key – 对于key为null值，JDK7与JDK8做法不同，但结果都是从table的0下标开始遍历。 JDK7的做法是对Null做了单独的put处理，不与非空的key放一起，直接单独在一个方法里面遍历table的0下标。 1234public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); 所以常常说JDK7版本可读性比JDK8版本要强，这是无须质疑的。 JDK8的做法更绝了，是对Null做了单独的hash处理，因为前面的JDK7版本对key做单独处理，无外乎就是null没法调用本地native方法hashCode取的哈希值，所以干脆就在外面传入hash值，并且将为null的key哈希值处理为0。 1return putVal(hash(key), key, value, false, true); – 哈希定位 – 在HashMap中其实哈希的影响还是蛮大的，所以版本迭代对哈希也做了一些改进。 JDK7版本的做法其实也是将32位的int哈希类型在命中table中的下标是能够分布均衡，因为table的数组长度没有像哈希值一样每个位随机均匀，它高位字节一般为0，这就导致很多时候不同的哈希值高位虽然不同，但结果命中了同一个下标，JDK的做法通过无符号右移，让每12位无差别异或，即高低位能够很好的利用到了。 1234567h ^= k.hashCode();// This function ensures that hashCodes that differ only by// constant multiples at each bit position have a bounded// number of collisions (approximately 8 at default load factor).h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); 但这种做法还不够极致，JDK8版本的做法，更加简单明了。 1return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); 4. 你项目中是如何去实现幂等性的？先说下我对幂等性的理解，这样再去理解我项目对幂等性的处理。 定义 用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 实现 幂等性在RPC上的实现，不仅要考虑结果一致性，还有考虑请求失败后负载到其他机器依旧保证幂等性，这就不能使用本地缓存来实现，而要用到分布式缓存，推荐的分布式缓存可以是Redis。 需要考虑到重试的时机来恰当设置缓存的失效时间，一般逻辑上只要保证请求次数达到阈值后重试请求成功即可失效，可从逻辑成功调用后去手动失效，或者是达到阈值后手动失效，不过这种做法增大了Redis的阻塞，因为Redis是单线程，没法做到并发，Jedis虽然可以并发，但会导致线程安全问题，而Jedis每次请求都需要建立连接， 所以可以考虑共享一个连接，不过请求速度将大大降低。 而考虑Lettuce则需要提前准备线程池，后面就可以直接从从线程池取连接，连接数更好管控，性能也相对高一些。 5. RPC的协议讲一讲，怎么处理的？RPC的请求过程： 服务端启动，并将服务注册到注册中心； 客户端启动通过代理调用所需的远程方法； 代理从注册中心拉取服务，并使用某种负载策略调用其中一个服务； 代理将客户端想要调用的方法等调用信息序列化，然后通过网络传输给服务端； 服务端接收到数据后，进行反序列化； 服务端得到反序列化的数据，包含需要调用的方法、参数数据，接着调用本地方法； 服务端调用完成将结果进行序列化，然后通过网络传输给代理； 代理拿到结果后，将结果反序列化，然后返回给客户端； 客户端接收到服务端远程方法调用的结果； 6. 项目中是怎么序列化的？项目中使用到了两种序列化方式，一种是Jackson，另一种是Kryo序列化； 这两种序列化工具都提供对Java对象的序列化，即转成二进制，然后进行网络传输； 接收到网络传输的二进制，再反过来进行反序列化成对象； 不过项目序列化的是核心数据，对一些请求包头协议，是使用了自定义编解码的方式； 对特定的字节码进行编解码解析，从而可以避免出现粘包的问题； 拆完包之后，对包中的核心数据进行反序列化操作; 当然具体的操作还有考虑到包的其他安全问题，比如重发包和校验码失败包。 7.说一说深拷贝和浅拷贝浅拷贝主要拷贝了对象的指针，本身数据引用的是同一块内存； 深拷贝则拷贝了对象本身，引用的是不同的内存。 在Java中，深拷贝和浅拷贝有Object的clone拷贝方法（浅拷贝）； Arrays.copy（浅拷贝）和System.arraycopy（浅拷贝） 序列化则是深拷贝，比如Java内置的ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法； 更深入来讲，浅拷贝中，目标对象对内存的操作会影响到原对象，而深拷贝则受影响。 8. TCP和UDP了解下？TCP与UDP都是传输层协议，TCP基于连接的，UDP基于非连接的； 从连接上看，TCP需要有三次握手才能完成连接，之后才能进行通信，是可靠的连接； 而UDP不需要连接，没有TCP严谨的三次握手、确认连接和四次挥手过程，是不可靠的连接； TCP可以保证服务的可靠，一般用于高可靠服务，UDP不能保证服务是否可靠。 特点 TCP： 稳定可靠，适用于要求较高的场景，需要准确无误的传输给对方，比如文件传输、发送邮件和浏览网页等； UDP： 速度快，性能损耗少、资源占用少，但是可能产生丢包，所以适用于对实时性要求较高，但是对少量丢包，并没有太大的要求的场景，比如域名查询、电话通信和视频直播等。 9. Http底层使用了什么：TCP协议，是基于连接的。 http请求报文 HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据等4个部分组成。 请求行：（get/post 方法，url中的path路径，http版本） 请求头部（header）关键字/值对组成，每行一对，关键字和值用英文冒号 请求数据 (body) http响应报文 HTTP响应报文由四个部分组成： 状态码（Status Code）：描述了响应的状态。可以用来检查是否成功完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse SC OK。 HTTP头部（HTTP Header）：它们包含了更多关于响应的信息。比如：头部可以指定任务响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Servlet中检索HTTP的头部看这里。 空行 主体（Body）：它包含了响应的内容。它可以包含HTML代码、图片等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。 请求过程 客户端连接服务器： 客户端一般为Web浏览器，通过url访问服务端，与服务端建立一个TCP的套接字。 发送HTTP请求： 通过TCP套接字，发送HTTP请求时，客户端向服务端发送了一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据四部分组成。 返回HTTP响应： Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，有客户端读取。一个响应由状态行、响应头部、空行和响应数据四部分组成。 释放TCP连接： 当connection模式为close，主动关闭方为服务端，客户端被动关闭连接，释放TCP连接； 当connection模式为keepalive，则该连接会保持一段时间，在该时间可以继续接收其他请求，长连接复用，与2.0的多路复用目的都是为了重用连接，减少连接开销。 10. 三次挥手说下？三次挥手与四次挥手很像，先说下四次挥手。 四次挥手 由主动关闭方(Client)发起中断连接请求，也就是FIN报文，被动关闭方(Server)接收到FIN报文后，从协议上来说是主动关闭方在等待收到FIN + ACK报文段，被动关闭方由于有数据要方法，第二次挥手只发了ACK确认号，接着主动关闭方进入FIN_WAIT状态，继续等待被动关闭方的FIN报文。 当被动关闭方数据发送完成后，将发送FIN报文给主动关闭方，主动关闭方收到FIN报文后，主动关闭方完成关闭，但被动关闭方并不知道FIN报文是否被接收成功，所以主动关闭方关闭前还需发送ACK给被动关闭方，表示已成功接收被动关闭方的FIN报文，这时被动关闭方就可以断开连接了。 如果没收到将再次发送FIN报文给主动关闭方，最后主动关闭方也不知道被动关闭方是否接收，需要等待2MSL时间，如果没收到重发包即成功了。 三次挥手 三次挥手不同于四次挥手，不同是第二次与第三次挥手合并了，如果服务端没有数据要发送，就可以将第二次与第三次挥手合并，而如果有数据要发，并且客户端允许延迟收到确认，那么服务端可以将结果封装到第二次与第三次合并的报文段中一起发送。 11. 进程和线程的关系？ 定义 进程是资源分配的基本单位，线程是CPU调度和分派的基本单位。 包含关系 线程是进程的一部分，一个线程只能属于一个进行，一个进程可以有多个线程，但至少有一个线程。 内存角度 每个进程分配了不同的内存空间，每个进程都有独立的代码和数据空间，多个进程可以同时运行在内存中，而同一个进程的多个线程（简称同类线程）在其分配的指定内存中运行，需要CPU来调度这一块内存区域。 系统不会为线程分配资源，只能通过CPU来调度和分派资源，也就是说，进程分配内存资源，然后线程需要CPU来过渡使用这块内存。 进程切换开销大，线程切换开销小。 共享角度 同类线程之间可以共享堆空间和方法区和运行时常量池，每个线程都有自己独立的虚拟机栈和程序计数器。 进行共享的方式 线程共享环境：进程代码段、进程公有数据、进程打开的文件描述符、信号处理器、进程当前目录和进程用户ID与进程组ID 进程通信的方式 匿名管道 (PIPE) 半双工，即不能同时在两个方向上传输数据，有的系统可能支持全双工。 速度慢，容量有限，且只能在父子进程间。经典的形式就是管道由父进程创建，进程fork子进程之后，就可以在父子进程之间使用了。 命名管道 (FIFO) 不想关的进程也能够进行数据交换。 消息队列 消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。 信号量 信号量是互斥信号量，能够用来同步通信。 共享内存 通过共享内存机制来实现。 套接字 套接字通过Socket绑定套接字，服务端开启监听被动连接，客户端主动连接，向套接字读写数据实现通信。 信号 一种异步通信方式，可在用户态和内核态中交互，也可以在内核态中通知用户态事件的发生。 12. 了解过CAS嘛？CAS是一种乐观锁的实现，CAS操作包含三个操作数——内存位置（V）、预期原值（A）期待值（B）。 如果内存位置的值与预期值向匹配，那么处理器会自动将该位置值更新为期待值，否则不做任何操作。 缺陷：无法解决ABA问题，在Java中解决该问题使用到了AtomicStampReference和AtomicMarkableReference来解决 数据库中MySQL的锁机制也是通过乐观锁来实现，更具体的实现则是MVCC多版本并发控制。 具体是两个数据结构，一个为undo log日志，一个为readView可读视图。 每张表中都会有隐藏的两列，一列是undo log指针，指向当前行数据操作指向的数据链表结构，另一列为事务版本号id，即每次事务开启后都会获取一个自增长的事务id，这样在ReadView可读视图中实现乐观操作，回到最先定义乐观锁三个操作数，实现方式差不多。 undo log 主要对所有并发修改结果保存了下来，并以链表的形式组织。 ReadView主要处理事务id的可见性，包含当前活跃事务版本Id列表，活跃最小事务id（up_limit_id）即已提交最大事务id + 1，活跃最大事务id（low_limit_id）即最小不可见事务id - 1和creator_trx_id表示当前事务开启的版本号。 活跃事务即为同一时间并发下，所有发生了交叉的事务。 13. 你的RPC项目怎么怎么划分模块的？ 服务发现（从注册中心获取服务及对应地址、使用负载均衡策略选择服务） 服务注册者（注册服务名和对应地址到注册中心、连接注册中心、清除服务） 服务提供者（存放服务实例、获取服务实例） 客户端代理（处理客户端请求、处理超时重试、负责分布式请求id生成） 服务端（启动服务时将服务所有类实例化并存放到服务提供者，将所有服务类对应服务名注册到服务注册者、处理客户端请求方法、处理超时包、处理重发包、处理异常包） 服务端处理器（从服务提供者获取服务实例、读取请求包代理执行服务对应方法） 异步请求池（客户端请求调用后立马返回future结果，由netty客户端正确读取结果后返回给异步请求池） 编码与解码器（对请求包和响应包的封包和拆包） 包检查器（对请求包和响应包的安全检验） 注册中心（暴露服务真实地址和端口号、提供服务注册与发现） 分布式缓存（缓存时间戳与序列号、重试请求号与请求结果、机器码） 服务宕机钩子（中心服务下线与本地服务清除、下线机器码、线程池关闭） 14. 做一套算法题如有升序链表：list1 = [1,2,3]，list2 = [1,4,5]，则合并后的链表：list = [1,1,2,3,4,5] 123456789101112131415161718192021222324252627private List concat(List list1, List list2) &#123; // 头结点存储数据 List p = list1; List q = list2; List newNode = new List(); List head = newNode; while(p.next != null &amp;&amp; q.next != null) &#123; if (p.data &lt; q.data) &#123; newNode.next = p; p = p.next; &#125; else &#123; newNode.next = q; q = q.next; &#125; newNode = newNode.next; &#125; // list2 仍存在节点 if (p.next == null &amp;&amp; q.next != null) &#123; newNode.next = q; &#125; // list1 仍存在节点 if (p.next != null &amp;&amp; q.next == null) &#123; newNode.next = p; &#125; return head.next;&#125;","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"}],"author":"fyupeng"},{"title":"SpringBoot整合rpc-netty-framework","slug":"SpringBoot整合rpc-netty-framework","date":"2022-10-20T09:15:08.000Z","updated":"2022-10-20T09:29:20.128Z","comments":true,"path":"2022/10/20/SpringBoot整合rpc-netty-framework/","link":"","permalink":"http://fyupeng.github.io/2022/10/20/SpringBoot%E6%95%B4%E5%90%88rpc-netty-framework/","excerpt":"","text":"一个分布式微服务RPC框架 | 返回 使用效果： 用户访问客户端：GET http://localhost:8081/user/hello?name=&quot;张三来访&quot; 浏览器访问客户端： 服务端接收情况： 服务端负载注册服务： 上面的实现就好比客户端只拿到服务端的api接口，加上配置中心地址即可调用远程服务！ 1. 创建工程创建两个工程，一个作为服务端SpringBoot、一个作为客户端SpringBoot，同时作为后端接口服务 创建Maven工程的时候推荐使用父子工程依赖，而且要注意子模块之间的相互依赖关系，其中： 父模块（root项目）：负责管理SpringBoot版本、统一版本、JDK版本、日志依赖 1234567891011121314151617181920212223242526272829303132333435&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven-compiler-source&gt;1.8&lt;/maven-compiler-source&gt; &lt;maven-compiler-target&gt;1.8&lt;/maven-compiler-target&gt; &lt;maven-copiler-compilerVersion&gt;1.8&lt;/maven-copiler-compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.1.2.RELEASE&lt;/version&gt;&lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt;&lt;!-- 与 logbakc 整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日志框架 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 主模块（启动类所在模块）应配置maven打包插件，SpringBootStarterWeb，rpc-core和依赖Service/Controller模块，客户端只有Service模块，服务端只有Controller模块 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.fyupeng&lt;/groupId&gt; &lt;artifactId&gt;springboot-rpc-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.fyupeng&lt;/groupId&gt; &lt;artifactId&gt;rpc-core&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; Service/Controller模块：依赖api模块和common模块，客户端请求服务端调用服务，当然没有Service模块，让主模块依赖Controller模块，Controller模块还要与主模块一样依赖SpringBootStarterWeb和rpc-core 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.fyupeng&lt;/groupId&gt; &lt;artifactId&gt;springboot-rpc-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.fyupeng&lt;/groupId&gt; &lt;artifactId&gt;springboot-rpc-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Common模块，依赖rpc-common模块 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.fyupeng&lt;/groupId&gt; &lt;artifactId&gt;rpc-common&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目在准备测试服务端的自动发现服务功能时，要保证cn.fyupeng.@Service注解类能够被扫描，使用cn.fyupeng.util.ReflectUtil类即可。 12345678public class Test &#123; public static void main(String[] args) throws IOException &#123; Set&lt;Class&lt;?&gt;&gt; classes = ReflectUtil.getClasses(&quot;cn.fyupeng&quot;); for (Class&lt;?&gt; aClass : classes) &#123; System.out.println(aClass); &#125; &#125;&#125; 2. 客户端2.1 编写启动器新建cn.fyupeng包，包下新建启动器类 1234567@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;cn.fyupeng&quot;,&quot;org.utils&quot;&#125;)public class SpringBootClientStarter &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootClientStarter.class, args); &#125;&#125; 2.2 编写配置文件123456# 单机模式cn.fyupeng.nacos.register-addr=192.168.10.1:8848# 集群模式cn.fyupeng.nacos.cluster.use=truecn.fyupeng.nacos.cluster.load-balancer=roundcn.fyupeng.nacos.cluster.nodes=192.168.10.1:8847|192.168.10.1:8848;192.168.10.1:8849 2.3 编写自定义配置类2.4 编写api注意与客户端包名完全相同 123456789101112package cn.fyupeng.service;/** * @Auther: fyp * @Date: 2022/10/19 * @Description: HelloWorld接口 * @Package: cn.fyupeng.cn.fyupeng.controller * @Version: 1.0 */public interface HelloService &#123; String sayHello(String name);&#125; 2.5 编写控制器@PostConstruct注解不要与@Autowire公用，因为@Autowire是本地依赖的，而我@PostConstruct会在该变量使用前调用，不过需要自行去实现，我的实现是远程依赖。 而@Reference没有依赖注入的功能，只有在超时重试才需要标记上！ @PostContruct与@Autowire在51cto博客中有所讲解，请自行到我的github主页get 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.fyupeng.controller;import cn.fyupeng.anotion.Reference;import cn.fyupeng.loadbalancer.RandomLoadBalancer;import cn.fyupeng.net.netty.client.NettyClient;import cn.fyupeng.proxy.RpcClientProxy;import cn.fyupeng.serializer.CommonSerializer;import cn.fyupeng.service.HelloService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.utils.JSONResult;import javax.annotation.PostConstruct;/** * @Auther: fyp * @Date: 2022/10/19 * @Description: HelloWorld控制器 * @Package: cn.fyupeng.cn.fyupeng.controller * @Version: 1.0 */@RequestMapping(&quot;/user&quot;)@RestControllerpublic class HelloController &#123; //@Autowired //private HelloService helloService; private static final RandomLoadBalancer randomLoadBalancer = new RandomLoadBalancer(); private static final NettyClient nettyClient = new NettyClient(randomLoadBalancer, CommonSerializer.KRYO_SERIALIZER); private static final RpcClientProxy rpcClientProxy = new RpcClientProxy(nettyClient); @Reference(retries = 5, timeout = 600, asyncTime = 3000) //@Autowired private HelloService helloService; @PostConstruct public void init() &#123; helloService = rpcClientProxy.getProxy(HelloService.class, HelloController.class); &#125; @GetMapping(&quot;/hello&quot;) public JSONResult sayHello(String name) &#123; return JSONResult.ok(helloService.sayHello(name)); &#125;&#125; 3. 服务端3.1 编写配置类新建cn.fyupeng.config包，在包下新建资源配置类，用于注入绑定端口 123456789101112131415@Configuration@ConfigurationProperties(prefix=&quot;cn.fyupeng.config&quot;)//不使用默认配置文件application.properties和application.yml@PropertySource(&quot;classpath:resource.properties&quot;)public class ResourceConfig &#123; private int serverPort; public int getServerPort() &#123; return serverPort; &#125; public void setServerPort(int serverPort) &#123; this.serverPort = serverPort; &#125;&#125; 3.2 编写启动器123456789101112131415161718192021222324252627282930313233343536373839@Slf4j@ServiceScan@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;cn.fyupeng&quot;, &quot;org.utils&quot;&#125;)public class RpcServerStarter implements CommandLineRunner &#123; @Autowired private ResourceConfig resourceConfig; @PostConstruct public void init() &#123; Map&lt;String, String&gt; resourceLoaders = ResourceLoadUtils.load(&quot;resource.properties&quot;); if (resourceLoaders != null) &#123; String serverPort = resourceLoaders.get(&quot;cn.fyupeng.config.serverPort&quot;); resourceConfig.setServerPort(Integer.parseInt(serverPort)); &#125; &#125; public static void main(String[] args) &#123; SpringApplication.run(RpcServerStarter.class,args); &#125; @Override public void run(String... args) throws Exception &#123; //这里也可以添加一些业务处理方法，比如一些初始化参数等 while(true)&#123; NettyServer nettyServer = null; try &#123; nettyServer = new NettyServer(&quot;192.168.2.185&quot;, resourceConfig.getServerPort(), SerializerCode.KRYO.getCode()); &#125; catch (RpcException e) &#123; e.printStackTrace(); &#125; log.info(&quot;Service bind in port with &quot;+ resourceConfig.getServerPort() +&quot; and start successfully!&quot;); nettyServer.start(); log.error(&quot;RegisterAndLoginService is died，Service is restarting....&quot;); &#125; &#125;&#125; 3.3 编写配置文件注意config/resource.properties与资源目录下的resource.properties不能同时公用，前者优先级高于后者 123456789# 用于启动 jar 包端口cn.fyupeng.config.serverPort=8082# 用于配置中心单机cn.fyupeng.nacos.register-addr=192.168.2.185:8848# 用于配置中心集群cn.fyupeng.nacos.cluster.use=truecn.fyupeng.nacos.cluster.load-balancer=roundcn.fyupeng.nacos.cluster.nodes=192.168.2.185:8847|192.168.2.185:8848;192.168.2.185:8849 3.4 编写api注意与客户端包名完全相同 123456789101112package cn.fyupeng.service;/** * @Auther: fyp * @Date: 2022/10/19 * @Description: HelloWorld接口 * @Package: cn.fyupeng.cn.fyupeng.controller * @Version: 1.0 */public interface HelloService &#123; String sayHello(String name);&#125; 3.5 编写业务注意Service注解为cn.fyupeng.service.HelloService 12345678910111213141516171819202122package cn.fyupeng.service.impl;import cn.fyupeng.anotion.Service;import cn.fyupeng.service.HelloService;/** * @Auther: fyp * @Date: 2022/10/19 * @Description: HelloWorld实现类 * @Package: cn.fyupeng.cn.fyupeng.controller.impl * @Version: 1.0 */@Servicepublic class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;hello, my name is &quot; + name; &#125;&#125; 为了使用配置文件注入来启动服务对应的端口","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://fyupeng.github.io/tags/RPC/"}],"author":null},{"title":"小迈科技一面","slug":"小迈科技一面","date":"2022-09-29T08:00:20.000Z","updated":"2022-09-29T08:02:24.370Z","comments":true,"path":"2022/09/29/小迈科技一面/","link":"","permalink":"http://fyupeng.github.io/2022/09/29/%E5%B0%8F%E8%BF%88%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2/","excerpt":"","text":"简单三分钟自我介绍自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目 + 意向岗位 一面1. Java基础1.1 序列化和反序列化首先了解一下序列化和反序列化的概念 序列化：将Java对象以二进制即字节码的形式保存在磁盘文件中，可以说是保存Java对象状态的过程，序列化可以实现对象保存的持久化； 反序列化：将保存在磁盘文件中的Java字节码重新转换为Java对象的过程； 其他特点：一般RPC框架底层协议通信就是通过序列化和反序列化在网络上传输Java对象。 序列化和反序列化的实现主要有两种，准确来说有三种方法： 采用默认的序列化方式，即通过ObjectOutPutStream类的writeObject(OutputStream out)方法来序列化到输出流中 输出流可以选择文件流、也可以选择管道流，甚至是二进制流 文件流是直接写到文件中再读取转成对象，管道流是通过管道缓存数据，然后再通过输入流连接管道读取转成对象 序列化的对象必须实现Seriablized接口，才能完成序列化和反序列化操作 1234class Student implements Serializable &#123; private String name; private Integer age;&#125; 第一种实现（采用默认） 123456789101112131415//FileOutputStream fos = new FileOutputStream(&quot;D:\\\\student.txt&quot;); PipedOutputStream pos = new PipedOutputStream(); PipedInputStream pis = new PipedInputStream(); pis.connect(pos); ObjectOutputStream oos = new ObjectOutputStream(pos); Student student = new Student(); student.setAge(21); student.setName(&quot;zs&quot;); oos.writeObject(student); //FileInputStream fis = new FileInputStream(&quot;D:\\\\student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(pis); Student res = (Student) ois.readObject(); System.out.println(res); 第二种实现（自定义） 12345678910111213141516// 自定义协议 比如我可以将加入对象头 cafe babe private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;自定义反序列化&quot;); int magic = in.readInt(); this.name = (String) in.readObject(); this.age = (Integer) in.readObject(); &#125; // 自定义协议 比如我可以将加入对象头 cafe babe private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println(&quot;自定义序列化&quot;); // 4 字节 魔数 out.writeInt(0xCAFEBABE); out.writeObject(this.name); out.writeObject(this.age); &#125; 第三种（自定义） 实现接口Externalizable并重写方法，其实跟第二种差别不大，只是第二种有默认的私有方法 12345678910111213@Override public void writeExternal(ObjectOutput out) throws IOException &#123; System.out.println(&quot;实现 Externalizable 接口的自定义序列化&quot;); out.writeObject(this.name); out.writeObject(this.age); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;实现 Externalizable 接口的自定义反序列化&quot;); this.name = (String) in.readObject(); this.age = (Integer) in.readObject(); &#125; 解决反序列化破坏单例 在单例模式中，序列化可以破坏单例，这是需要重写readResolve() 方法，将之前的单例实例对象返回即可保证单例。 解决反射破坏单例 反射创建对象根本也是要调用构造方法，而且可以无视构造方法的访问修饰符（public、private） Java规定反射不能破坏枚举类型，采用枚举构造单例 构造方法执行前，单例实例逻辑上不应该创建而且只执行一次，可判断是否已创建来避免反射创建多个实例，前提单例已先于反射 1.2 说一说数据类型有哪些Java有八种基本数据类型 + String 1个位的bit，布尔类型的boolean，2个字节的short，4个字节的int、char，8个字节的long、double、float 其中基本类型中的包装类型常用的有Integer、Long 其中Integer会自动进行拆封装处理，也就是可以直接跟int类型比较数值上的大小 底层在-128-127之间会做缓存，在这之间通过Integer.valueOf(int)创建的对象都是同一个,使用了享元设计模式 123System.out.println(new Integer(1) == 1);System.out.println(Integer.valueOf(1) == Integer.valueOf(1));System.out.println(Integer.valueOf(128) == Integer.valueOf(128)); 结果 123truetruefalse 1.3 数据结构给你你个浏览器，要求设计前进和后退的数据结构，优先考虑性能 那么由于浏览器前进后退访问，是一种FIFO的结构，比如你连续点击前进几个页面，最先进的页面最后返回，即LIFO 那么可以考虑栈的结构设计，栈结构设计要考虑性能，首先我们可以分析到，浏览器页面跳转没有涉及到页面的修改，即用于查询 那么优先考虑数组而不考虑链表 我们可以设计两个栈数组，一个用于入栈已前进的页面，一个用于入栈已后退的页面，取其中一个栈顶元素作为当前页面 2. MySQL2.1 索引在MySQL中，直接影响索引类型的是数据库的存储引擎 使用MyIsam存储引擎，数据文件和索引是分开的，索引会另外存储在另一个文件中 使用InnoDB存储引擎，数据和索引都存储在同一个文件中，而且是以B+数的数据结构存储，非叶子节点存储索引，叶子节点存储索引和索引对应的数据 就MyIsam引擎来说，索引中最主要的是聚簇索引，也就是主键的默认索引 单值索引和多值索引，这里是指组合索引，好的组合索引可以达到覆盖索引，可以做到避免回表，这里是因为叶子节点通过覆盖索引带了数据，因为B+树只有叶子节点带有数据，非叶子节点都是索引 而多个组合索引下，有效索引要做到左匹配，也就是必须从左顺序匹配到右查询，否则索引将失效 2.2 口述 sql给你一张表，有三个字段，id、产品id、备注信息，现在需要你查询相同产品id的记录，然后id值相同的记录数大于等于5的产品id 首先呢，我们可以先定义这张表为S 因为涉及相同字段的记录，可以考虑直接分组，使用聚合函数 123select pro_id from Sgroup by pro_idhaving count(pro_id) &gt;= 5 3. JVM3.1 线程的死锁了解过吗？比如有两个线程t1和t2，t1线程有资源r1，t2有资源r2，t1线程执行代码中需要资源r2，不过这段代码需要t2线程把资源r2释放才能执行，此时t2线程也执行代码中，释放资源前需要获取资源r1，但t2又需要r2，此时处于相互等待的状态，就导致了死锁。 从Java角度来说，资源相当于Java的锁对象，是互斥的，一个线程获取锁对象后，另一个线程只能等待，t1线程获取锁对象r1，也就是占有了锁r1，这时线程t2也是占有了锁对象r2，而线程t1需要获取锁对象r2才能往下执行代码，使得线程t1阻塞，而线程t2处于阻塞等待锁对象r1释放，才能释放锁对象r2，这样就导致死锁。（互相等待） 4. JUC4.1 线程池有了解过吗？线程池主要有核心线程数、救急线程和队列，队列分为阻塞队列和非阻塞队列。 目前线程池主要可以分为几类： 只有核心线程、无救急线程的线程池，此时等待队列中有要执行的任务，而核心线程在轮询地执行等待队列中的任务，如果队列满或者队列是无界队列，可能导致内存溢出问题。 一般这种线程池的做法就是使用了拒绝策略，拒绝策略可分为直接丢弃新任务、异常抛出（主动逻辑处理）、丢弃等待队列头结点、提交任务线程执行。 最后一个是推荐使用的 不会造成数据丢失，也就不会出现业务损失； 提交任务的线程被占用，新的任务不可提交，减缓任务提交的速度，相当于负反馈，能给到线程池一定的缓冲期； 只有救急线程的线程池，这种的话有线程池newCachedThreadPool，它能无限创建救急线程，队列采用SynchronousQueue ，是一个没有容量的队列，只有线程取任务时才能提交任务； 最后是一种核心线程数只有1的线程池，没有救急线程，任务队列无界，一般作为单线程任务，这样就不会有CPU的轮询切换，任务的执行效率最高，不过请求数太多的情况下，也是容易导致内存溢出。 非阻塞队列实现的有CurrentLinkedQueue，它是通过CAS无锁化机制的线程池队列，每个线程通过for(;;)执行，是一个单向且通过GC自动回收出队节点的，利用可达性算法分析，将next指向自己，即可触发延迟回收，利用元素的不可重用性，规避ABA问题 5. Linux给你一个日志文件，要求你查询最近一天内中，匹配到关键字的所有记录数据 一般日志实时查询可以使用该命令，它会实时更新，而且会处于fg模式，tail打印文件末尾记录，也就是最近 1tail -100f catalina.log | grep &quot;关键字&quot; 而使用cat是查询历史，只能打印日志到屏幕 比如按照tail或head来查询关键字为20:的后5条数据并显示行号 1cat -n log.log4j | grep &quot;20:&quot; | tail -n 5 时间段查询 1grep &#x27;2022-08-21 20:1[1-9]&#x27; log.log4j","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"}],"author":null},{"title":"右岸物联面经","slug":"右岸物联面经","date":"2022-09-25T10:28:50.000Z","updated":"2022-09-25T10:30:38.942Z","comments":true,"path":"2022/09/25/右岸物联面经/","link":"","permalink":"http://fyupeng.github.io/2022/09/25/%E5%8F%B3%E5%B2%B8%E7%89%A9%E8%81%94%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"简单三分钟自我介绍自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目 + 意向岗位 技术面1. Java基础篇1.1 Object你知道哪些方法?我就回答了自己常用的 wait、notify、notifyAll 这三个方法，其他自己不怎么使用，就跟技术官说抱歉，其他不怎么使用，就回答不上来，面试官也不停留在这个问题上，直接带到下一个话题。 所以这里总结下，Object其实还有一个 clone()方法，这个回答不上了其实真不应该，当前想不起来，还有一个获取类信息getClass()，可以做映射的东西。 1.2 你了解过哪些list 类型吗嗯，有两种，一种是 数组，一种是链表，即ArrayList和LinkedList 1.3 这两种怎么选择使用？一般的话，如果读操作大于增删改的话，使用数组效率要比链表的好，而如果要频繁修改操作，那么使用链表更好一点 所谓层层递进，就在这里了 1.4 那为什么这么说？呃，因为数组如果你要增加一个元素的话，比如举例，你有十个元素，那么你要在0号下标增加一个元素，那么你得把后面10个元素整体向后挪到一位，这里我还用手势比划了一下，面试官点头，然后示意我继续，我就说链表的话，只需要修改一下指针就可以了，不用对整体移动，其实这里应该回调内存的连续跟分散会更好一点，因为数组是开辟的连续内存空间，而链表不需要，它是零散的，所以链表读要使用指针，自然而然数组读效率更高。 2. Spring 篇2.1 Spring 是干什么用到？Spring可以方便地给我们管理创建、获取和kill对象，不需要我们去额外做这一份工作。 2.2 了解过 IOC吗？IOC是控制反转的意思，在Spring 容器中，创建对象的工作不再由我们来负责，而是交由 Spring 容器去管理各个对象的生命周期。 2.3 说一说 Spring 容器管理对象生命周期有什么用？由于 Spring容器默认使用的是 Single单例创建对象，这样各个线程对同一个对象是共享的，就可以做到多个用户请求访问是拿的是同一个实例，不用总去创建对象，导致频繁的 GC垃圾回收。 2.4 说一说 Spring 中容器它的创建实例的作用域在 Spring容器中，有一个属性 scope，就是一个作用域，它可以指明创建对象是采用单例还是其他方式 单例的话多个线程下是共享实例的，当时只想到 Request，但这个不是线程级别的，没回答上来，没想到 Prototype（原型），技术官帮我解围了，说知道我知道想说什么，就是说不出来哈哈。 Prototype 它是一个原型，在多个线程中的创建的单例是互不干扰的，也就是生命周期的处于线程。 当然还有其他，因为不怎么使用，所以就没有怎么说。 MySQL 篇MySQL 你了解过哪些引擎嗯？这个我了解过两个，INNODB和Myisam 这两个是有什么区别？我就说了第一个默认会使用 行锁，Myisam 使用的是表锁 面试官继续追问，为什么？怎么判断的？这个我真不知道该怎么回答，我就瞎扯了锁升级，就说 INNODB因为默认使用行锁，但是如果因为没有索引优化或者语句优化等问题，可能会出现锁升级现象，这是 Myisam 没有的。 面试官一头雾水，但没有反驳，好，继续下个问题。 事务有了解吗？我说有有，这就来劲了，就说INODB 有事务，但Myisam 没有事务这说法，现在才明白面试官说这两个引擎的区别原来在这里。 面试官没有为难，知道问的差不多了，就开始手撕 SQL 口述SQL给你一个表，这个表有三个字段，一个是学生 id，一个是课程名 cname，一个是课程成绩 cscore 要求：如果有三门课程，要求找出学生的总成绩大于270，并且返回学生id和总成绩 纳尼，第一个想法就是想着连表查询，当时觉得没戏了，就很挣扎 口述：就是通过三张表自然关联，关联三门成绩，然后关联条件是学生id，where 是三门成绩之和大于270 面试官觉得有问题，这种做法不通用，要我再想想其他方法 想了两分钟，没有思绪，给我个提示：可以使用 group by 分组？那就简单了，我就直接口述了，说可以先分组，然后在每个分组里面使用聚合函数sum，将总成绩这个条件满足270的查询出来 当时很紧张，怕错了，面试官一脸微笑的说，是的，思路是对的，你可以用在纸上用笔写下来吗？ 他知道我口述可以，但还是不相信我动手能力，瞧不起了，可能之前用那个关联的SQL 手写SQL，出现了一点问题，但在他提出问题的时候，我立马说我可以修改下sql吗，改了再给他看了下，可能就是因为这个原因，自己不仔细写，给自己埋坑，让面试官对我有了质疑 于是这次我就好好捋了捋思绪，面试官看我迟迟未动笔，说不用紧张，慢慢想，当然我肯定不这么想，当时已经有想法了，只是怕又写错了SQL，因为当时已经有一个月没刷 力扣 SQL题型了，想了两分钟左右，写了出来 1234select sc.sid, sum(sc.score) as sum_scorefrom SC scgroup by sc.sidhaving on sum(sc.score) &gt; 270 就这样，面试官比较满意，就问我为什么当时没想出来，我就说当时他说给三科成绩，很容易就让人想到用联表 到这里 SQL 也没继续写了","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"}],"author":null},{"title":"长城软件面经","slug":"长城软件面经","date":"2022-09-25T10:28:40.000Z","updated":"2022-09-25T15:23:04.149Z","comments":true,"path":"2022/09/25/长城软件面经/","link":"","permalink":"http://fyupeng.github.io/2022/09/25/%E9%95%BF%E5%9F%8E%E8%BD%AF%E4%BB%B6%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"简单三分钟自我介绍自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目 + 意向岗位 技术面1. Java基础篇1.1 说一说数据结构说下链表的属性，指针属性 树结构了解过吗？ 叶子节点怎么存储的？ 2. Spring 篇2.1 Spring MVC 的原理主要有5个组件，前端控制器、映射器、处理器、处理器适配器、视图解析器 前端控制器也就是中央处理器，它主要负责前端用户的请求和对其他组件的转发调用； 前端控制器接收到请求后，会把请求转发给处理器映射器，处理器会根据配置或注解（@Controller）找到最终要执行的Handler； 然后将Handler（自己的业务处理）对象以及其对应的拦截器，封装到HandlerExecutionChain对象中并以它的形式放回； 前端控制器根据获取到的Handler（Controller），去选择一个合适的HandlerAdapter（它还支持Servlet、HttpRequestHandler、ThrowawayController），成功获取到会先去执行拦截器； 这时将开始对提取Request中的模型数据，并且将Handler的入参进行数据填充，以至于我们写控制层方法时，入参是前端传来的值，在填充过程中，根据自己的配置，Spring还可以帮你做一些额外操作： Json/Xml 数据转换成对象 格式化请求数据 校验 Handler执行完成后，返回一个ModelAndView（视图和视图需要填充的模型数据） 前端控制器根据返回的ModelAndView，选择合适的ViewResolver ViewResolver 结合Model和View，来渲染视图 最终前端控制器将渲染结果返回给客户端 3. JVM 篇3.1 说一说你对jvm内存结构的理解jvm 内存模型由程序计数器、方法区、虚拟机栈、本地方法栈、堆和运行常量池组成。 方法区：主要是存储类变量，静态变量，常量以及class描述信息（会在类加载后加载到方法区中） 虚拟机栈：虚拟机栈跟线程是直接挂钩的，它的生命周期跟线程一样，而且虚拟机栈设置的大小（-Xss1024k，1024个字节1M单词缩写Stack Size），当设置过大时，在堆大小固定的情况下，总内存 = 堆内存 + 线程数 * 虚拟机栈大小，可线程数就会相应减少； 本地方法栈：跟虚拟机栈相似，不过不是用Java写的； 程序计数器：线程私有，每个线程在让出CPU会由它来记录当前位置，以便恢复CPU还在原位置执行； 堆：存放Java对象实例，在JDK7版本中，由新生代（Eden区、Survivor区）和 老年代组成，也是GC垃圾收集器处理的主要区域，俗称GC堆，是管理内存中最大的一块； 运行时常量池是放在方法区中的，作为方法区的一部分。 3.2 对象创建和销毁的过程对象创建的过程其实在 jvm 中包括了加载、链接（包含验证（虚拟机的安全性、对象头、父类与子类中final等声明的安全性校验等等）、准备、解析）、初始化； 准备阶段：申请内存空间并完成默认的初始化，比如int类型默认初始化为4个字节的内存空间，并初始化为0； 解析阶段：将常量池中的引用解析为直接引用，也就是将类中的常量池放到了运行时常量池中，这样我们在直接调用方法或者引用类的时候，是需要符号引用的，只不过jvm帮我们自动引用了常量中的符号，就成直接引用。 初始化阶段：用户真正的赋值操作，即调用相应的构造器构造对象，构造对象创建的时候，如果是比较复杂的，由于虚拟机优化机制，会出现指令重排序问题，什么问题？ 在该场景中，构造过程分为几个步骤：申请内存 -&gt; 构造块构造 -&gt; 内存地址返回，这里面的指令为了性能上的提示，而不改变结果，jvm可能会将内存地址也就是构造函数创建的对象指向的内存地址放到构造块过程中返回，而没有等到最后。 引用：编译器可以自由地以优化的名义对指令的顺序进行随意处理。 那么怎么解决？ 当然是保证原子性呀！ 怎么保证？ final声明不仅能保证类不可继承，方法不可重写，变量不可变，还有一个重要的特点就是能保证可见性，媲美volatile 可见性保证就是对象如果已经可见（地址已经返回了，那么保证它构造的完整性，也就是指令不会发生重排）性 文章分享：https://qa.1r1g.com/sf/ask/451997661/ 内存模型官方讲解：http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html 推荐比较好的网站：https://qa.1r1g.com/ 补充 如果类中的成员变量声明为final并且是基本类型，那么赋值阶段会在准备阶段就完成了，这些可实现一些并发安全性应用； 3.2 GC 垃圾回收了解过吗了解过一点点，没了，他就不问了…… 我就是专门去看了gc中的一些原理，比如复制算法、并发标记、并发清除、分代回收，还有Serial、parNew、parallel Scavenge和g1这些，看來不能太低调了。 3.3 JVM 调优了解过吗答案是没有，所以没有下文了，可惜这篇面经比较卑微，味道不够香。 因为就是简单使用过，没有在具体项目场景用到，不敢吹嘘。 3.4 volatile 能保证原子性吗不能，volatile可以保证可见性，它是在jvm优化后，出现指令重排序后才有的，能够防止指令的重排序，也就是说指令重排序可能会先将对象在执行构造函数中，提前把对象所在地址给返回了，这就可能导致成员变量出现为null的情况，有了volatile就不会发生。 volatile一般修饰于变量 当然除了这个，volatile保证可见性还体现在内存与高速缓存之间，如果一个变量通过for循环去执行，那么jvm将进行性能优化，将内存中的变量放到高速缓存中，这样容易出现内存与高速缓存的不一致性问题，volatile可以保证对内存中变量的修改及时同步到高速缓存中。 4. SQL 篇4.1 聊一聊你对SQL中的优化主要分为语句优化和索引优化 语句优化比如避免使用or，可能导致全盘遍历，我是说了join连接和子查询，前一个只需要查询一次，后一个会多次遍历全表，如果数据量大的表将很严重。 索引优化的话，面试官很耐心给我讲了组合索引、失效的问题 4.2 SQL 中的函数的处理SQL中的函数比如时间的yyyy-MM-dd hh-mm-ss,通过这种设置可以来处理相应的时间 可以看看这篇文章：https://blog.csdn.net/chentaocba/article/details/7539409 可以这样自定义去处理拼接时间 5. Redis 篇5.1 聊一聊哨兵模式哨兵模式的应用其实是Redis集群中故障恢复和高可用的应用，在Redis读写分离也就是主从复制中，哨兵节点作为独立节点，不参与选举。 在主节点也就是master节点宕机后，多个哨兵节点一致发现主节点下线，通过投票选举哪一个从节点选举为主节点。 其实就是一种监控主节点是否故障的行为。 5. 分布式3.1 说一说服务降级在请求超时、资源不足、CPU、数据库IO达到瓶颈时，采取的一种补救措施。 服务降级主要有Dubbbo的Mock和Spring Cloud的Hystrix，屏蔽对远程的调用，一般使用SpringBoot比较推荐整合Hystrix来实现服务降级容错。 3.2 聊一聊你的项目分布式中怎么解决出现的问题我做的是一个分布式的博客管理项目，在搭建并部署分布式项目时，调用远程服务的时候，注册中心Nacos很容易出现宕机，当时排查的原因是内存不够，当时使用了阿里的两台服务器、一台腾讯云服务器来搭建分布式项目，阿里一台作为前端和Nginx做反向代理，一台运行着博客的文章、评论、分类标签和用户的五个服务，一台作为代理服务器，处理前端的请求、远程调用腾讯云服务器的服务，但我把注册中心放到了腾讯云上，因为腾讯云上的服务需要进行服务注册，而且注册中心Nacos启动是带有Web后台管理页面的，所以就作为一个内部的服务器使用。 于是解决方案就是将多个服务进行横向拆分，将文章和用户的服务放到代理服务器上运行，解决了在远程调用服务的时候因为请求超时或资源不足导致Nacos注册中心出现宕机的情况。 6. 网络编程6.1 Tomcat 与 Netty 有什么区别Tomcat是一种使用http协议的web容器，是用来启动web应用的，而Netty是一种自定义处理各种字节流数据做相应的编解码，也就是可以自定义通信协议，Netty是一款基于NIO的网络通信框架，而且Tomcat的话其实也支持NIO模式。","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"}],"author":null},{"title":"华资面经","slug":"华资面经","date":"2022-09-25T10:28:30.000Z","updated":"2022-09-25T10:30:09.032Z","comments":true,"path":"2022/09/25/华资面经/","link":"","permalink":"http://fyupeng.github.io/2022/09/25/%E5%8D%8E%E8%B5%84%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"华资一面—— 人力面（挂） 1. Spring1.1 Spring 的生命周期 推荐学习链接：https://blog.csdn.net/shijinjins/article/details/124071095 Spring 生命周期会经历过四个阶段，分别是实例化、属性赋值、初始化、销毁 其他的一些阶段就是通过AOP面向切面扩展来的，能够让你在实例化、初始化和销毁前后做一些逻辑。 初始化阶段，有一个特别重要的接口BeanPostProcessor postProcessorBeforeInitialization(); // 初始化前调用 postProcessorAfterInitialization(); // 初始化后调用 初始化方式有三个 InitializingBean类的afterPropertiesSet方法 @PostConstruct注解标注的方法 // Spring支持javax包中的@PostConstruct，会在属性值注入成功后执行 Spring配置文件applicationContext.xml的标签属性init-method=&quot;initMethod&quot; 这里提醒，@PostConstruct是通过Spring的BeanPostProcessor#postProcessBeforeInitialization(Object, String)来完成调用的 如果是使用到了Spring自动注入来使用创建的Bean，那么如果使用反射的方式创建对象执行构造方法，先后顺序是这样的： 12345flowchart LRA[服务器加载Servlet]--&gt; B[Servlet构造函数]B --&gt; C[&quot;@Autowire&quot;]C --&gt; D[&quot;@PostConstruct&quot;] 反射的方式会在执行构造器后返回，所以你要通过反射使用Bean，可在@PostConstruct注解的方法保存该Bean，再去调用使用。 销毁方式有三个 @PreDestroy注解标注的方法 // // Spring支持javax包中的@preDestroy，会在销毁前执行 DisposableBean接口的destroy方法 Spring配置文件applicationContext.xml的标签属性destroy-method=;&quot;destroyMethod&quot; 这里提醒，@preDestroy执行是通过Spring的DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object, String)来完成调用的 简要步骤 1.当程序加载运行时会根据spring中配置文件找到bean配置的属性和方法，并通过java反射机制创建实例化bean对象。 Bean实现了BeanNameAware接口，执行了setBeanName方法，实现注入对象。 2.实现了BeanFactoryAware工厂接口，执行了setBeanFactory方法。 3.实现了ApplicationContext接口类，执行了setsetApplicationContest方法。 4.实现了BeanPostProcessor接口类，执行postProcessBeforeInitialization方法 5.实现了InitiliazingBean 执行afterPropertiesSet方法，并加载配置文件定义了init-method 则执行对应初始化方法BeanPostProcessor 执行postProcessorfterInitilization方法，完成 Bean的初始化，使得bean可以使用。 6.实现了DisposabileBean接口执行destroy方法，加载配置文件中的destroy-method方法销毁bean对象实例。 1.2 Spring 作用域单例（默认Single）和多例（Prototype） 单例在一个容器里面只存在一个对象，多例的Bean生命周期在容器产生时并不创建，对象使用时才创建，最后由JVM垃圾回收期回收 生命周期出生和销毁还可以自己指定，比如 init-method 对象出生之后立刻执行什么方法 destroy-method对象销毁之前执行什么方法 1.3 Spring 依赖注入方式有三种：属性注入、构造函数注入、工厂方法（通过标签属性配置静态或实例工厂）注入 而基于这三种方式有多种实现：配置文件实现、注解实现、 2. 集合集合的性质: 唯一性、无序性、确定性 唯一性指的是集合元素是不重复的、无序性指的是集合插入元素的顺序性、确定性是指集合中元素是确定的，不是相对性的。 集合类型按类型划分可以划分为可重复集合不可重复集 可重复集合：List实现类 不可重复集合：Set实现类、Map实现类（key） 按照有序性（添加和访问）划分可以划分为有序集和无序集 有序集：List实现类、TreeSet、LinkedHashSet、LinkedHashMap、TreeMap 无序集：HashSet、HashMap、 按照结构划分可以划分为列表List、Set、Map（Stack 和 Queue） List：ArrayList、LinkedList Set：HashSet、LinkedHashSet、TreeSet Map：HashMap、HashTable、TreeMap、LinkedHashMap、CurrentHashMap、 按照存储连续性划分可以划分为连续集和散列集 连续集：ArrayList 散列集：LinkedList、Map实现类、Set实现类 3. 线程安全3.1 线程安全的集合有哪些？HashTable、CurrentHashMap、CurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue HashTable：它的方法都使用了重量级锁synchronized修饰来保证方法执行的线程安全。 CurrentHashMap：有JDK迭代版本； 7使用了分段锁Segment（继承可重入锁ReentrantLock）实现线程安全，是真正意义上实现了并发 8使用了synchronized + CAS，因为在1.6版本之后，synchronized一步步得到优化 包含了偏向锁、轻量级锁、重量级锁 处于偏向锁的对象，是指可以在获得该偏向锁的同一个线程中，多次执行同步代码块时相当于无锁 而如果处于偏向锁的对象被其他线程获取了，偏向锁将不再偏向，就升级为轻量级锁 升级为轻量级锁还是有机会继续偏向锁的，是怎么个原理？ 在对象头前8个字节中，存储了偏向线程id，前提得是该线程未获取锁对象，获取锁对象后设置的是当前线程id 所以想让对象头上的偏向线程id重新偏向为当前线程id，得让该线程重复获取锁对象达到阈值20次才会偏向，不过只能偏向一次 这就是锁降级，如果有第三个线程参与了，同样执行第二个线程的操作，将不再偏向（对象头偏向线程id重置为0） 这是由再次升级为轻量级锁，前面是不发生竞争，如果多个线程发生竞争，竞争失败会自旋CAS再次尝试获取锁，如果还是失败 这时升级为重量级锁，重量级锁将不再通过乐观锁CAS操作，而是会发生阻塞，必须等获得锁的线程释放锁才能让给下一个线程 CurrentLinkedQueue：使用了非阻塞的方式实现了线程安全，是一个无锁化的单向队列，使用到了CAS + for(;;)，而且这种单向队列巧妙利用节点的不可重用 + CAS + next 指向本身 + GC垃圾回收，规避掉了ABA问题 因为节点出队列并不会马上出队列，而是通过next指向自己让GC垃圾回收掉，这样有线程刻意去ABA操作时，发现还有旧值，没法做修改达到ABA的目的，这说专业点就是延迟出队。 LinkedBlockingQueue：与CurrentLinkedQueue非常像，也是一个无界队列，这样如果入队快于出队的情况容易出现栈溢出 ArrayBlockingQueue：是有界队列 4. 谈谈自己的项目略","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"}],"author":null},{"title":"第一场面试","slug":"第一场面试","date":"2022-09-25T10:26:54.000Z","updated":"2022-09-25T10:28:18.019Z","comments":true,"path":"2022/09/25/第一场面试/","link":"","permalink":"http://fyupeng.github.io/2022/09/25/%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9D%A2%E8%AF%95/","excerpt":"","text":"简单三分钟自我介绍自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目 + 意向岗位 技术面1. Spring 原理篇1.1 有使用过Spring吗，说一说它的 SpringMVC 原理主要有5个组件，前端控制器、映射器、处理器、处理器适配器、视图解析器 前端控制器也就是中央处理器，它主要负责前端用户的请求和对其他组件的转发调用； 前端控制器接收到请求后，会把请求转发给处理器映射器，处理器会根据配置或注解（@Controller）找到最终要执行的Handler； 然后将Handler（自己的业务处理）对象以及其对应的拦截器，封装到HandlerExecutionChain对象中并以它的形式放回； 前端控制器根据获取到的Handler（Controller），去选择一个合适的HandlerAdapter（它还支持Servlet、HttpRequestHandler、ThrowawayController），成功获取到会先去执行拦截器； 这时将开始对提取Request中的模型数据，并且将Handler的入参进行数据填充，以至于我们写控制层方法时，入参是前端传来的值，在填充过程中，根据自己的配置，Spring还可以帮你做一些额外操作： Json/Xml 数据转换成对象 格式化请求数据 校验 Handler执行完成后，返回一个ModelAndView（视图和视图需要填充的模型数据） 前端控制器根据返回的ModelAndView，选择合适的ViewResolver ViewResolver 结合Model和View，来渲染视图 最终前端控制器将渲染结果返回给客户端 1.2 springboot 有什么优点springboot 它可以帮我快速、使用最低代码最少时间开发出一个项目，不想 SpringMVC，需要繁琐写很多配置信息，我们只关注写业务代码即可。 通过配置文件解耦代码，在一些可能改动的配置信息，可以不通过修改代码再打包部署，而是让代码去外部读取该配置文件，再去运行。 还有SpringBoot是使用了maven 可以方便对版本的管理，能够让自己不需要考虑版本依赖问题和兼容版本的问题。 Redis 篇有使用过 Redis吗有，它是一个缓存数据库，主要存储的是k-v类型的数据。 那说说它的一个缓存雪崩？嗯？缓存雪崩的话，就是key集中失效，导致 Redis 相当于宕机，大量请求依旧打到mysql数据库上了。 这里总结一下，其实雪崩Redis服务基本不可用了，存储层的调用量会暴增，造成存储层也会挂掉的情况，而且雪崩会出现周期性的峰值，因为就算缓存失效了，请求到了存储层，获取到数据后，是会再做一次缓存的，所以会出现周期性峰值。 致命的原因是存储层在暴增的情况下扛不住调用后，导致数据库直接挂掉了。 有什么解决措施？嗯？我们可以对那个 key 的缓存时间设置更长一些，缓存雪崩导致的原因是因为太过于集中失效，导致暴增，那么如果我们均摊一下时间，就能避免出现该情况，所以我们可以对缓存时效设置的更随机性一些，且对一些热点数据缓存时间设置永久性。","categories":[{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"}],"author":null},{"title":"ConCurrentHashMap底层原理透析","slug":"ConCurrentHashMap底层原理透析","date":"2022-08-06T05:56:54.000Z","updated":"2023-01-04T03:15:58.326Z","comments":true,"path":"2022/08/06/ConCurrentHashMap底层原理透析/","link":"","permalink":"http://fyupeng.github.io/2022/08/06/ConCurrentHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E9%80%8F%E6%9E%90/","excerpt":"","text":"创作宗旨：化繁为简，绝不冗余，点到为止 ConcurrentHashMap&lt;K,V&gt; 继承了AbstractMap&lt;K,V&gt;，实现了ConcurrentMap&lt;K,V&gt;和Serializable。说明：AbstractMap&lt;K,V&gt;实现了基本的Map操作ConcurrentMap&lt;K,V&gt;规范了对k-v的并发操作的方法 一、介绍 ConCurrentHashMap是如何做到线程安全的？通俗来讲，ConcurrentHashMap&lt;K,V&gt;已经迭代了几个版本，我们先从JDK7说起,起初为了实现了对HashMap真正意义上的并发，在ConcurrentHashMap&lt;K,V&gt;引入了一个静态内部类Segment(段)，而且ConcurrentHashMap&lt;K,V&gt;也聚合了一个Segment的成员变量数组来维护，每一个Segment数组的下标元素相当于一个HashMap，也就是一个HashEntry数组 + 每位下标元素构成一个HashEntry链的头结点（依旧保存值），每次存在线程安全的操作都会去使用该数组的其中一个下标，并锁住该下标（其他线程无法访问），而不同[下标之间的操作是不会相互影响的，也就不存在冲突的情况。Segment继承了ReentrantLock（可重入锁），用法其实用到加锁和解锁，保证每一个线程使用前加锁，使用完成后释放锁。ConcurrentHashMap中Segment与Entries的示意图更专业来讲，ConcurrentHashMap使用了分段锁Segment来解决线程安全。2. JDK7 的 get 和 put 以及扩容 getget 操作没有任何加锁，所以在ConCurrent是非常高效的。123456static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next;&#125; 就算获取key之前value被改变了，由于volatile修饰了value变量，所以对内容是及时更新的，新增和删除操作亦是如此。1234567891011121314151617181920212223public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // Concurrent 初始化时会初始 Segment数组和 第 0 位下标即Segment[0]（包括 HashEntry数组 的初始化） // 如果 segment 对应的 HashEntry 数组不为空，则往下遍历 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; // 遍历 HashEntry 数组 哈希命中的下标元素（链表） for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; // 如果找到了 key就返回对应的value，否则往下继续遍历链表 // 这里前面匹配的是 基本数据类型， //如果是 复杂对象，则使用的是先 hash筛选桶下标，相等再去 比较 “值” if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; post在ConcurrentHashMap中post操作是不允许设置value为null。Concurrent初始化时会初始Segment数组和 第0位下标即Segment[0]（其中包括HashEntry数组的初始化），所以这里会出现命中到另外15个未初始化的Segment锁段，即当前Segment为null的情况1234567891011121314public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; // 不允许对 value 设置为 null if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // 没有找到，即说明未初始化 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment // 初始化当前 Segment 对应的 HashEntry 数组 s = ensureSegment(j); return s.put(key, hash, value, false);&#125; post细节12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 尝试加锁 HashEntry&lt;K,V&gt; node = tryLock() ? null : // 如果不成功, 进入 scanAndLockForPut 流程 // 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程 // 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来 scanAndLockForPut(key, hash, value); // 执行到这里 segment 已经被成功加锁, 可以安全执行 V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; // 更新 K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; // 新增 // 1) 之前等待锁时, node 已经被创建, next 指向链表头 if (node != null) node.setNext(first); else // 2) 创建新 node node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 3) 扩容 // 必须 是 达到阈值 并且 HashEntry 数组还没被扩容，也就是长度依旧是旧值 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else // tab已更新，即扩容已经完毕，将 node 作为链表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 扩容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void rehash(HashEntry&lt;K,V&gt; node) &#123; // 每个 Segment 对应的一个 HashEntry&lt;K,V&gt;数组 HashEntry&lt;K,V&gt;[] oldTable = table; // 扩容前 HashEntry&lt;K,V&gt;数组的长度 int oldCapacity = oldTable.length; // 扩容后 HashEntry&lt;K,V&gt;数组的长度 = 扩容前 HashEntry&lt;K,V&gt;数组的长度 * 2 int newCapacity = oldCapacity &lt;&lt; 1; // 扩容阈值的元素数量，HashEntry&lt;K,V&gt;数组 中元素的个数到 某个数量（低于最大数）时的数量 threshold = (int)(newCapacity * loadFactor); // 初始化一个新的 HashEntry 数组，每个下标表示的 HashEntry 都为 null，后面会用到这个 null 做头插法 put 元素 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; // hash 命中 &amp; 操作要用的掩码（计算hash结果的长度） int sizeMask = newCapacity - 1; // 遍历 扩容前 HashEntry&lt;K,V&gt;数组 for (int i = 0; i &lt; oldCapacity ; i++) &#123; HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) &#123; HashEntry&lt;K,V&gt; next = e.next; int idx = e.hash &amp; sizeMask; // 当前 HashEntry&lt;K,V&gt;数组 下标只有一个元素，则直接赋值给 新数组对应下标 // 这里对应的新的下标跟 原下标已经不一样了，因为是按照 扩容后 的长度来计算得到的 if (next == null) // Single node on list newTable[idx] = e; // 如果链表长度 大于等于两个元素以上 else &#123; // Reuse consecutive sequence at same slot HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; // 重用 链表最后面 新命中值 相同的 for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123; int k = last.hash &amp; sizeMask; if (k != lastIdx) &#123; lastIdx = k; lastRun = last; &#125; &#125; // 将重用的链表头结点 转移到 新的 数组中 newTable[lastIdx] = lastRun; // Clone remaining nodes // 链表剩下的 部分，挨个按照头插法 命中到 新的数组中 for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123; V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); &#125; &#125; &#125; &#125; // 最后再 把要 put 的值 头插法 加入到 新的数组中 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; // 这里通过 暂时 数组操作完毕再 赋值，能够避免操作中途 被其他 线程再次重复操作 // 在这之前 其他 线程无法进入 // 一赋值 其他线程 就算判断 达到阈值，但newTable 的大小改变 // tab.length &lt; MAXIMUM_CAPACITY 也会让 其他线程直接去 新的数组 put 操作 table = newTable;&#125; JDK8抛弃了Segment分段锁，转而使用CAS+synchronized来保证并发安全性。并且，不再单纯使用链表，JDK8在HashEntry数组中的链表长度大于8的时候会去转化为红黑树结构。在这里，链表长度大于8时，才会去进一步判断阈值是否达到。与JDK7扩容的区别在上一篇 深入浅出~HashMap的底层原理透析 详细讲过了，其实与ConCurrentHashMap大同小异，也就是多做了CAS的操作、链表转化红黑树和等待的put会帮忙扩容。二、附语 谢谢大家，我会继续努力，只为力争创作高质量的文章，分享给各位有需要的读者。你们的阅读和评论是对作者最大的支持！我的技术专栏：https://github.com/fyupeng 专注品质，热爱生活。交流技术，寻求同志。","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java原理","slug":"Java原理","permalink":"http://fyupeng.github.io/tags/Java%E5%8E%9F%E7%90%86/"}],"author":"fyupeng"},{"title":"贪心算法","slug":"贪心算法","date":"2022-08-06T03:57:51.000Z","updated":"2022-08-06T04:00:08.680Z","comments":true,"path":"2022/08/06/贪心算法/","link":"","permalink":"http://fyupeng.github.io/2022/08/06/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"贪心算法1. 455. 分发饼干问题假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 代码123456789101112131415161718class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); int index = 0; int result = 0; for(int i = 0; i &lt; g.length &amp;&amp; index &lt; s.length; i++)&#123; if(g[i] &lt;= s[index]) &#123; // 吃掉 result++; &#125; else &#123; i--; &#125; index++; &#125; return result; &#125;&#125; 2. 376. 摆动序列问题如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 示例 1： 123输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2： 1234输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3： 12输入：nums = [1,2,3,4,5,6,7,8,9]输出：2 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 代码 贪心法 12345678910111213141516class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int curDiff = 0; int preDiff = 0; int result = 1; // 考虑 右 边界值 特殊情况 for(int i = 0; i &lt; nums.length - 1; i++) &#123; // 考虑了 左边界值 特殊情况 curDiff = nums[i] - nums[i + 1]; if(curDiff &lt; 0 &amp;&amp; preDiff &gt;= 0 || curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) &#123; result++; preDiff = curDiff; &#125; &#125; return result; &#125;&#125; 动态规划 1234567891011121314151617class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if(n &lt; 2) return n; int up = 1; int down = 1; for(int i = 1; i &lt; n; i++) &#123; if(nums[i] &lt; nums[i - 1]) &#123; down = up + 1; &#125; if(nums[i] &gt; nums[i - 1]) &#123; up = down + 1; &#125; &#125; return Math.max(up, down); &#125;&#125; 3. 53. 最大子数组和问题给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 1234输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 代码12345678910111213141516class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = - 10000; int sum = 0; for(int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if(sum &gt; res) &#123; res = sum; &#125; if(sum &lt; 0) &#123; sum = 0; &#125; &#125; return res; &#125;&#125; 4. 122. 买卖股票的最佳时机 II问题给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 代码 直接写法 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length &lt; 2) &#123; return 0; &#125; int res = 0; for(int i = 0; i &lt; prices.length - 1; i++) &#123; int pricesDiff = prices[i + 1] - prices[i]; if(pricesDiff &gt; 0) &#123; res += pricesDiff; &#125; &#125; return res; &#125;&#125; 贪心写法 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length &lt; 2) &#123; return 0; &#125; int res = 0; for(int i = 0; i &lt; prices.length - 1; i++) &#123; res += Math.max(prices[i + 1] - prices[i], 0); &#125; return res; &#125;&#125; 动态规划 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int n = prices.length; if(n &lt; 2) &#123; return 0; &#125; int[][] dp = new int[n][2]; // 表示 买进第 0 天的股 dp[0][0] -= prices[0]; //默认初始：dp[0][1] = 0; 表示初始收益为 0 for(int i = 1; i &lt; n; i++) &#123; // 股票下跌，买进 dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 股票上涨，卖出 dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); &#125; return Math.max(dp[n - 1][0], dp[n - 1][1]); &#125;&#125; 5. 55. 跳跃游戏问题给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 123输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 104 0 &lt;= nums[i] &lt;= 105 代码123456789101112class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length == 1) return true; // 可到达的 最长下标 int cover = 0; for(int i = 0; i &lt;= cover; i++) &#123; cover = Math.max(cover, i + nums[i]); if(cover &gt;= nums.length - 1) return true; &#125; return false; &#125;&#125; 6. 45. 跳跃游戏 II问题给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 示例 1: 1234输入: nums = [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 12输入: nums = [2,3,0,1,4]输出: 2 提示: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 1000 代码 版本一 1234567891011121314151617181920212223242526class Solution &#123; public int jump(int[] nums) &#123; if(nums.length == 1) &#123; return 0; &#125; int curDistance = nums[0]; int nextDistance = 0; int ans = 0;; int n = nums.length; for(int i = 0; i &lt; n; i++) &#123; nextDistance = Math.max(nextDistance, nums[i] + i); // 如果当前 最远步长 已经达到终点下标了， if(curDistance &gt;= n - 1) &#123; ans++; break; &#125; //否则 看是否已经 满足 当前下标是 最远步长 // 主要是为了更新 nextDistance 为 在当前下标到 最远步长中 找到 下一个最远步长下标最远的 if(i == curDistance) &#123; ans++; curDistance = nextDistance; &#125; &#125; return ans; &#125;&#125; 版本二 123456789101112131415161718192021class Solution &#123; public int jump(int[] nums) &#123; if(nums.length == 1) &#123; return 0; &#125; int curDistance = 0; int nextDistance = 0; int ans = 0;; int n = nums.length; for(int i = 0; i &lt; n - 1; i++) &#123; nextDistance = Math.max(nextDistance, nums[i] + i); //否则 看是否已经 满足 当前下标是 最远步长 // 主要是为了更新 nextDistance 为 在当前下标到 最远步长中 找到 下一个最远步长下标最远的 if(i == curDistance) &#123; ans++; curDistance = nextDistance; &#125; &#125; return ans; &#125;&#125; 7. 1005. K 次取反后最大化的数组和问题给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例 1： 1234输入：nums = [4,2,3], k = 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3] 。 示例 2： 123输入：nums = [3,-1,0,2], k = 3输出：6解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 示例 3： 123输入：nums = [2,-3,-1,5,-4], k = 2输出：13解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示： 1 &lt;= nums.length &lt;= 104 -100 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 104 代码 绝对值排序 123456789101112131415class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; nums = IntStream.of(nums).boxed().sorted((t1, t2) -&gt; Math.abs(t2) - Math.abs(t1)).mapToInt(Integer::intValue).toArray(); for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &lt; 0 &amp;&amp; k &gt; 0) &#123; nums[i] = - nums[i]; k--; &#125; &#125; if(k % 2 == 1) &#123; nums[nums.length - 1] = - nums[nums.length - 1]; &#125; return Arrays.stream(nums).sum(); &#125;&#125; 从小到大排序 12345678910111213141516171819202122class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; int n = nums.length; if(n == 1) return k % 2 == 0 ? nums[0] : -nums[0]; int sum = 0; int index = 0; Arrays.sort(nums); for(int i = 0; i &lt; k; i++) &#123; if(i &lt; nums.length - 1 &amp;&amp; nums[i] &lt; 0) &#123; nums[i] = -nums[i]; if(nums[i] &gt;= Math.abs(nums[i + 1])) index++; continue; &#125; nums[index] = -nums[index]; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; return sum; &#125;&#125; 8. 134. 加油站问题在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 123456789输入: gas = [2,3,4], cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 提示: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 代码 暴力法 1234567891011121314151617class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curGas = 0; for(int i = 0; i &lt; gas.length; i++) &#123; curGas = gas[i] - cost[i]; int index = (i + 1) % gas.length; while(curGas &gt;= 0 &amp;&amp; index != i) &#123; curGas += gas[index] - cost[index]; index = (index + 1) % gas.length; &#125; if(curGas &gt;= 0) &#123; return i; &#125; &#125; return -1; &#125;&#125; 贪心算法1 123456789101112131415161718192021class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int min = Integer.MAX_VALUE; for(int i = 0; i &lt; gas.length; i++) &#123; int res = gas[i] - cost[i]; curSum += res; if(curSum &lt; min) &#123; min = curSum; &#125; &#125; if(curSum &lt; 0) return -1; if(min &gt;= 0) return 0; for(int i = gas.length - 1; i &gt;= 0; i--) &#123; int res = gas[i] - cost[i]; min += res; if(min &gt;= 0) return i; &#125; return -1; &#125;&#125; 贪心算法2 12345678910111213141516171819class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int totalSum = 0; int startIndex = 0; for(int i = 0; i &lt; gas.length; i++) &#123; int res = gas[i] - cost[i]; curSum += res; totalSum += res; if(curSum &lt; 0) &#123; startIndex = i + 1; curSum = 0; &#125; &#125; if(totalSum &lt; 0) return -1; return startIndex; &#125;&#125; 9. 135. 分发糖果问题n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 123输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2： 1234输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示： n == ratings.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= ratings[i] &lt;= 2 * 104 代码1234567891011121314151617181920212223class Solution &#123; public int candy(int[] ratings) &#123; if(ratings.length == 1) &#123; return 1; &#125; int n = ratings.length; int[] candyArg = new int[n]; for(int i = 0; i &lt; n; i++) &#123; candyArg[i] = 1; &#125; for(int i = 0; i &lt; n - 1; i++) &#123; if(ratings[i + 1] &gt; ratings[i]) candyArg[i + 1] = candyArg[i] + 1; &#125; for(int i = n - 2; i &gt;= 0; i--) &#123; if(ratings[i] &gt; ratings[i + 1]) candyArg[i] = Math.max(candyArg[i], candyArg[i + 1] + 1); &#125; int sum = 0; for(int i = 0; i &lt; n; i++) &#123; sum += candyArg[i]; &#125; return sum; &#125;&#125; 10. 860. 柠檬水找零问题在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例1： 1234567输入：bills = [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例2： 1234567输入：bills = [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 1 &lt;= bills.length &lt;= 105 bills[i] 不是 5 就是 10 或是 20 代码12345678910111213141516171819202122232425262728class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; int five = 0, ten = 0, twenty = 0; for(int i = 0; i &lt; bills.length; i++) &#123; if(bills[i] == 5) &#123; five++; &#125; if(bills[i] == 10) &#123; if(five &lt;= 0) return false; ten++; five--; &#125; if(bills[i] == 20) &#123; if(five &gt; 0 &amp;&amp; ten &gt; 0) &#123; five--; ten--; twenty++; &#125; else if(five &gt;= 3) &#123; five -= 3; twenty++; &#125; else &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 11. 406. 根据身高重建队列问题假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 12345678910输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 12输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= hi &lt;= 106 0 &lt;= ki &lt; people.length 题目数据确保队列可以被重建 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; int length = people.length; Arrays.sort(people, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] people1, int[] people2) &#123; // 从大到小 排序 if(people2[0] == people1[0]) &#123; return people1[1] - people2[1]; &#125;else &#123; return people2[0] - people1[0]; &#125; &#125; &#125;); for(int i = 0; i &lt; length; i++) &#123; inset(people, i, people[i][1]); &#125; return people; &#125; private void inset(int[][] people, int sourceIndex, int destIndex) &#123; int[] temp = people[sourceIndex]; if(sourceIndex &lt;= destIndex) &#123; for(int i = sourceIndex; i &lt; destIndex; i++) &#123; people[i] = people[i + 1]; &#125; people[destIndex] = temp; &#125; else &#123; for(int i = sourceIndex; i &gt; destIndex; i--) &#123; people[i] = people[i - 1]; &#125; people[destIndex] = temp; &#125; &#125;&#125; 12. 452. 用最少数量的箭引爆气球问题有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 示例 1： 12345输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用2支箭来爆破:-在x = 6处射出箭，击破气球[2,8]和[1,6]。-在x = 11处发射箭，击破气球[10,16]和[7,12]。 示例 2： 123输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4解释：每个气球需要射出一支箭，总共需要4支箭。 示例 3： 12345输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2解释：气球可以用2支箭来爆破:- 在x = 2处发射箭，击破气球[1,2]和[2,3]。- 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示: 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 代码12345678910111213141516171819class Solution &#123; public int findMinArrowShots(int[][] points) &#123; Arrays.sort(points, (a,b) -&gt; &#123; if(a[0] != b[0]) &#123; return (long)a[0] - (long)b[0] &gt; 0 ? 1 : -1; &#125; return (long)a[0] - (long)b[0] &gt; 0 ? 1 : -1; &#125;); int count = 0; for(int i = 1; i &lt; points.length; i++) &#123; if(points[i][0] &gt; points[i - 1][1]) &#123; count++; &#125; else &#123; points[i][1] = Math.min(points[i][1], points[i - 1][1]); &#125; &#125; return count + 1; &#125;&#125; 先排序（按元素0号下标升序）后贪左边，因为排完后，前面的肯定包含后面的元素，再去贪右边边界，贪最小边界。 13. 435. 无重叠区间问题给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例 1: 123输入: intervals = [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 123输入: intervals = [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 123输入: intervals = [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示: 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 代码12345678910111213141516171819class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; // 对右区间升序， Arrays.sort(intervals, (a,b) -&gt; &#123; return a[1] - b[1]; &#125;); int removeCount = 0; for(int i = 1; i &lt; intervals.length; i++) &#123; if(intervals[i][0] &lt; intervals[i - 1][1]) &#123; removeCount++; // 更新当前状态下不重叠右区间上限 // 不用理会两个区间中间可能留下的空白区域，因为已经排序 // 所以后面的区间不会重叠中间那块空白区域 intervals[i][1] = intervals[i - 1][1]; &#125; &#125; return removeCount; &#125;&#125; 14. 714. 买卖股票的最佳时机含手续费问题给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 12345678输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 12输入：prices = [1,3,7,5,10,3], fee = 3输出：6 提示： 1 &lt;= prices.length &lt;= 5 * 104 1 &lt;= prices[i] &lt; 5 * 104 0 &lt;= fee &lt; 5 * 104 代码123456789101112131415161718192021class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; // 买入是先 算手续费，buy 是买入+手续费 int buy = prices[0] + fee; int result = 0; for(int i = 1; i &lt; prices.length; i++) &#123; // buy 已经更新为能否继续收益的更高水准 // 如果不能继续收益了，也就是跌股了，那就卖掉上一股，重新买入新股 // 因为相比 同一股 会有更大的收益 if(prices[i] + fee &lt; buy) &#123; buy = prices[i] + fee; &#125; if(prices[i] &gt; buy) &#123; result += prices[i] - buy; // 连续涨股就持股 buy = prices[i]; &#125; &#125; return result; &#125;&#125; 15. 968. 监控二叉树问题给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 示例 1： 123输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。 示例 2： 123输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 代码12345678910111213141516171819202122232425262728293031class Solution &#123; int res = 0; public int minCameraCover(TreeNode root) &#123; if(traversal(root) == 0) return ++res; return res; &#125; // 0 - 无覆盖 1 - 有摄像头 2 - 有覆盖 private int traversal(TreeNode node) &#123; // 终止条件 if(node == null) return 2; // 后序递归遍历 int left = traversal(node.left); int right = traversal(node.right); // 设置叶子节点为 未覆盖，或者是 两个子节点均已覆盖。那么设置该节点为未覆盖 if(left == 2 &amp;&amp; right == 2) &#123; return 0; &#125; // 存在子节点还未覆盖，该节点设置摄像头 if(left == 0 || right == 0) &#123; res++; return 1; &#125; // 子节点有摄像头，该节点设置为覆盖 if(left == 1 || right == 1) &#123; return 2; &#125; // 因为逻辑返回需要，虽然不会到这一步但还是要写 return -1; &#125;&#125;","categories":[{"name":"leetCode算法","slug":"leetCode算法","permalink":"http://fyupeng.github.io/categories/leetCode%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"http://fyupeng.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}],"author":"fyupeng"},{"title":"HashMap底层原理透析","slug":"HashMap底层原理透析","date":"2022-07-31T05:50:18.000Z","updated":"2023-01-04T03:07:14.958Z","comments":true,"path":"2022/07/31/HashMap底层原理透析/","link":"","permalink":"http://fyupeng.github.io/2022/07/31/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E9%80%8F%E6%9E%90/","excerpt":"","text":"创作宗旨：化繁为简，绝不冗余，点到为止 直接开门见山，就事论事！ 什么是 HashMap? HashMap类继承了父类AbstractMap&lt;K,V&gt;，实现了接口Map&lt;K,V&gt;, Cloneable, Serializable,AbstractMap&lt;K,V&gt;实现了对Map的基本操作，Serializable是序列化接口，可实现序列化，Map&lt;K,V&gt;接口规范了k-v对操作的抽象方法，Cloneable规范了继承了Object后去使用clone()方法前必须得实现Cloneable接口，否则抛出CloneNotSupportedException错误。 一、介绍1. HashMap 的线程不安全的场景 死锁 扩容产生死锁的原因关键有两点：第一点：链表的头插法转移结点，JDK8版本就改成了尾插法；第二点：多线程环境下，CPU的让出使得头结点的指针指向发生变化，但原线程重新占有CPU时仍然采取原先的做法；解读：JDK8下使用尾插法，就算头结点已经转移了，但还是在头结点位置，也就是转移前后链表顺序不改变，只是多了一次重复的操作，结果不影响。我不会用篇幅很长而做这么点事情，没必要，很简单的事 5 幅图就可以啦。由于HashMap是数组+链表的数据结构，旧桶是指数组下标所在位置。线程 1 扩容操作 线程 1 转移结点A线程1结点转移完毕线程2开始转移结点A因为是线程2首先要扩容的，不过CPU时间却让给了线程2,线程2也发觉需要扩容，等扩容完毕后再把CPU还给线程1 线程2转移结点A结束，环形链产生，也就是产生死锁。 所以原因的头插法得以佐证，CPU的轮询切换也演绎的很到位。线程不安全讲完，下面就将原理，去潜移默化它。 2. HashMap 实现哈希命中均匀哈希也就是k的hashcode计算后得到的下标，而hashcode是一个32位的int类型，要让分布均匀，即让不同的k不能出现有相同的效果，也就是得有唯一性，就要完全去利用高16位和低16位，而如果直接用32位去取模运算，高16就可能会用不到，导致hashcode高16位不同的k依旧命中同一个桶位。所以JDK8采取的做法是对高16位与低16位进行异或运算，这样就变相保留了高位和低位的所有特征了。哈希均匀，JDK8之后 1return (key == null) ? h = key.hashCode() ^ (h &gt;&gt;&gt; 16); 取模运算，JDK7之前 1h &amp; (length - 1) 3. HashMap 参数以及扩容机制初始容量16，达到阈值扩容，阈值等于最大容量 * 负载因子，扩容每次2倍，总是2的n次方。 扩容机制使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组元素拷贝到新的Entry数组里，Java1.7重新计算每个元素在数组中的位置。而Java1.8它不需要重新计算每个元素，它会先比较元素的hashcode &amp; 原来数组的大小的结果，如果为0，就以元素的原下标加入到新数组中，如果为1，就在原下标加上原数组的大小加入到新数组中，这样这两种情况就命中到新数组的前一半和后一半了，也就是将原本全在原数组大小的所有元素又均匀分布一些元素到扩容未使用的下标中。那么就解释一下，假设加入的元素是随机的，也就是所有情况的hash值是均等出现的，而&amp;原数组大小可以这样比如，有64个元素均等的从0到63，那么0到15分配给了扩容后数组大小为32的左半部分，16-31分配给了右半部分，32-48分配给了左半部分，48-63分配给了右半部分，就比较均匀分散在了两侧，而且机会均等，很巧妙！ 12345678910111213141516171819// 分布到左侧if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e;&#125;// 分布到右侧else &#123; if (hiTail == null) // 初始化 hiHead = e; else // 尾插法 hiTail.next = e; // 自增，下次尾插法必要的变量 hiTail = e;&#125; 4. HashMap 的 get 和 put 操作 get 让我们见识下此时无图胜有图的效果吧！ get由源码解读是先获取key的hashCode，然后定位到对应的数组位置，再去遍历该元素处的链表在这里才讲equals我觉得是最合适的，可以区分它与hashCode的区别，如果hashCode相同的两个元素在同一个数组下标，equals就开始发挥作用了，不得不说，当然别说我是话痨，我觉得HashMap加入这两个的初衷是如果在一个庞大的Map中，要去get某一个key的value，有一种最直接的做法，就是直接整个Map去equals比较，这没错，而且还是有用的，但加入hashCode之后，hashCode能够给equals先筛选一番，因为不同的key，它的hash值一般是不同的，理解这里的一般，所以hash值不同的equals肯定就不同，就没必要再去对不同下标元素来equals比较了，好理解吧！由于HashMap中新加入了红黑树，就多了一种get到key的方法，是一种二分法，对于大量数据的链表是不推荐的，所以采用红黑树（总是平衡的二叉树）更加地高效！ put put的实现主要针对两种key，一种是不存在的key，一种是已存在的key局部源码 1234public V put(K key, V value) &#123; //采用hash(key)来计算key的hashCode值。 return putVal(hash(key), key, value, false, true);&#125; 12345static final int hash(Object key) &#123; int h; //当key等于null的时候，不走hashCode()方法 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 如果为前者，而且key值为null，就在数组下标为0的链表中去寻找key为null的值，当然找不到，就创建key为null的结点。如果为前者，而且key值不为null，就调用该元素hash计算具体的下标，在该下标的链表中寻找，当然也寻找不到，就尾插法加入该k-v结点。如果为后者，即找到了，直接赋值就可以了，不需要考虑是否为null。 这里要分开来put是因为，在HashTable上，是不允许有key为null的情况出现，因为当key为null时，key.hashCode()会报空指针异常。所以在HashMap做了特别的处理，对key为null做了单独处理，这样就解决了key为null的情况。还有一点，HashMap的value如果设置为null，虽然你put了，但再去取key的时候，依旧是不存在！ 二、附语不足之处请大佬予以佐证，不希望哪个地方出现的错误误导同行，结果闹出笑话来，总之你们的阅读和评论是对作者最大的支持！谢谢大家，我会继续努力，只为力争创作高质量的文章，分享给各位有需要的读者。我的技术专栏：https://github.com/fyupeng 专注品质，热爱生活。交流技术，寻求同志。","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java原理","slug":"Java原理","permalink":"http://fyupeng.github.io/tags/Java%E5%8E%9F%E7%90%86/"}],"author":"fyupeng"},{"title":"SpringMVC","slug":"SpringMVC","date":"2022-07-11T06:36:59.000Z","updated":"2022-07-22T01:27:21.891Z","comments":true,"path":"2022/07/11/SpringMVC/","link":"","permalink":"http://fyupeng.github.io/2022/07/11/SpringMVC/","excerpt":"","text":"1. 声明和配置1.1 自定义容器配置文件 在web.xml配置文件的的web-app下 12345678910111213141516&lt;!-- 声明，注册springmvc的核心对象DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 自定义springmvc配置文件读取的位置 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;!-- springmvc配置文件位置的属性 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 指定自定义文件的位置 --&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; springmvc默认位置： 12&lt;!--如果不写自定义路径--&gt;&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; 则会找默认路径：WebContent/WEB-INF/lib/ 要求： 声明类org.springframework.web.servlet.DispatcherServlet的servlet-name时，其对应的配置文件名称也应为servlet-name的值 + &quot;-servlet&quot;.xml pom.xml中加入两个依赖包： 1234567891011121314&lt;!-- servlet依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- springmvc依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 步骤： 由于tomcat服务器每次启动会重新加载web.xml配置文件，从而在里面配置启动springmvc.xml，使它自动初始化 由index.jsp通过链接发起，再用MyController处理转发给show.jsp 注意： ​ MyController通过注解实现控制器，需要在springmvc.xml配置文件中配置扫描器 srpingmvc.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;org.zhkucst.controller&quot;/&gt;&lt;/beans&gt; 1.2 过滤器编码服务器启动时自动初始化过滤器在web.xml中加入 123456789101112131415161718192021222324&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 1.3 DispatcherServlet执行源码springmvc执行过程源代码分析 tomcat启动，创建容器的过程 ​ 通过load-on-start标签指定的1，创建DispatcherServlet对象， ​ DispatcherServlet的父类是继承HttpServlet的，它是一个servlet，在被创建是，会执行init()方法 ​ 在init()方法中 1234//创建容器，读取配置文件getServletContext().getAttribute(key, ctx);//把容器对象放入到ServletContext()getServletContext().setAttribute(key, ctx); 上面创建容器作用：创建@controller注解所在的类的对象，创建MyController对象， 这个对象放入到springmvc的容器，容器时map，类似map.put(&quot;myController&quot;, MyController对象) 请求的处理过程 执行servlet的service() 12345protected void service(HttpServletRequest request, HttpServletResponse response) protected void doService(HttpServletRequest request, HttpServletResponse response) DispatcherServlet.doDispatch(request, response)&#123; //调用MyController的.doSome()方法&#125; 2. 注解式开发2.1 文件上传和Servlet方式的本质一样，都是通过导入两个jar包（commons-io.jar和commons-fileupload.jar） 具体步骤：（直接使用CommonsMultipartResolver实现上传） jar包 commons-fileupload.jar、commons-io.jar 配置CommonsMultipartResolver 将其加入SpringMVC容器中 1234567&lt;!-- springMVC容器初始化时，会自动寻找一个Id=&quot;multipartResolver&quot;的bean，并将其加入MVC容器 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt; &lt;!-- 上传单个文件最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;102400&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 控制器： 12345678910111213141516171819202122232425262728@RequestMapping(value = &quot;testUpload&quot;)public String testUpload(String desc, MultipartFile file) &#123; System.out.println(&quot;文件描述信息：&quot; + desc); try &#123; InputStream input = file.getInputStream(); String fileName = file.getOriginalFilename(); OutputStream out = new FileOutputStream(&quot;d:\\\\&quot; + fileName); byte[] bs = new byte[1024]; int len = -1; // 循环从 输入流 input 中读取1024个字节给 bs while((len = input.read(bs)) != -1)&#123; // 每次读取到的数据 bs 写入到输入流 out.write(bs, 0, len); &#125; out.close(); input.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //将file上传到服务器中的某一个硬盘中 System.out.println(&quot;上传成功&quot;); return &quot;success&quot;;&#125; 表单： 12345&lt;form action=&quot;handler/testUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br/&gt; &lt;input name=&quot;desc&quot; type=&quot;text&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;br/&gt;&lt;/form&gt; 2.2 配置视图解析器在springmvc.xml中增加bean来实例并自动配置jsp文件的前缀和后缀 框架会使用视图解析器的前缀 + 逻辑名称（文件名） + 后缀 组成完成路径 视图路径配置 123456&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--前缀 视图文件的路径--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt; &lt;!-- 后缀 视图文件的扩展名 --&gt; &lt;property name=&quot;Suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 控制器实现转发视图 1234567891011@RequestMapping(value = &quot;/some.do&quot;)public ModelAndView doSome()&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;欢迎使用springmvc做web开发&quot;); mv.addObject(&quot;fun&quot;, &quot;执行的是doSome方法&quot;); mv.setViewName(&quot;show&quot;); return mv;&#125; 控制器不变，跟之前的写法一样 控制器可以实现多方法，多请求 1234567891011121314151617181920212223@RequestMapping(value = &#123;&quot;/some.do&quot;, &quot;first.do&quot;&#125;)public ModelAndView doSome()&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;欢迎使用springmvc做web开发&quot;); mv.addObject(&quot;fun&quot;, &quot;执行的是doSome方法&quot;); mv.setViewName(&quot;show&quot;); return mv;&#125;@RequestMapping(value = &#123;&quot;/other.do&quot;, &quot;second.do&quot;&#125;)public ModelAndView doOther()&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;欢迎使用springmvc做web开发&quot;); mv.addObject(&quot;fun&quot;, &quot;执行的是doOther方法&quot;); mv.setViewName(&quot;other&quot;); return mv;&#125; 类也可以注解公共路径 123@Controller@RequestMapping(&quot;/test&quot;)public class MyController &#123; 常见视图解析器 InternalResourceView、InternalResourceViewResolver 123//springMVC解析jsp时，会默认使用InternalResourceView, 如果发现JSP中包含了jstl语言，则自动转为JstlViewpublic class JstlView exteds InternalResourceView &#123;&#125; JstlViw 可以解析jstl 从而实现国际化操作 2.3 国际化国际化：针对不同地区、不同国家，进行不同的显示 中国：（大陆、香港） 欢迎 美国：welcome 具体实现国际化的步骤： 创建资源文件 基名_语言_地区.properties 基名_语言.properties 配置springmvc.xml文件 123&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;i18n&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 通过jstl使用国际化 需要两个依赖包：jstl.jar和 standar.jar 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt; index.jsp 1&lt;a href=&quot;handler/testI18n&quot;&gt;test i18n&lt;/a&gt; success.jsp 12&lt;fmt:message key=&quot;resource.welcome&quot;&gt;&lt;/fmt:message&gt;&lt;fmt:message key=&quot;resource.exist&quot;&gt;&lt;/fmt:message&gt; 处理器： 1234@RequestMapping(value = &quot;testI18n&quot;)public String testModelAttribute() &#123; return &quot;success&quot;;&#125; 不能直接访问success来国际化，必须通过服务器响应才能实现 i18n_en_US.propeities 12resource.welcome=WELCOMEresource.exist=EXIST i18n_zh_CN.properties 12resource.welcome=\\u4F60\\u597Dresource.exist=\\u9000\\u51FA i18n.properties 一般上面的找不到会自动找父类 2.4 处理器接收参数 对象接收参数 1234567891011121314@RequestMapping(value = &quot;receiveobject.do&quot;)public ModelAndView receiveParam(Student myStudent)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, myStudent.getName()); mv.addObject(&quot;myage&quot;, myStudent.getAge()); mv.addObject(&quot;mystudent&quot;, myStudent); System.out.println(myStudent); mv.setViewName(&quot;show&quot;); return mv;&#125; 形参请求 请求中所携带的请求参数 get方式–通过url拼接，比如localhost:8080/MyProject?name=zs 或者通过form标签输入input然后传回 注意： 请求参数必须要与处理器中的形参一致 12345&lt;form action=&quot;receiveparam.do&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;other的post请求&quot;&gt;&lt;/form&gt; 123@RequestMapping(value = &quot;receiveparam.do&quot;)public ModelAndView doSome(String name, int age)&#123;&#125; 额外： get方法的编码默认是utf-8，如用get出现中文乱码，则使用的tomcat可能是tomcat7，使用8即以上，默认是utf-8，也可以到apache-tomcat-8.5.63\\conf中的server.xml的 12&lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;增加属性：URIEncoding=&quot;UTF-8&quot; 2.5 静态处理2.5.1 第一种静态处理交由 tomcat 本身的默认处理 在路径下：apache-tomcat-9.0.43\\conf 1234&lt;!-- The default servlet for all web applications, that serves static --&gt; &lt;!-- resources. It processes all requests that are not mapped to other --&gt; &lt;!-- servlets with servlet mappings (defined either here or in your own --&gt; &lt;!-- web.xml file).--&gt; 1.访问静态资源 2.访问没有被请求映射的servlet 满足以上任意一点的，访问会默认交由default的servlet处理 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 接着在web.xml使用servlet-name来指定默认的处理器和对要默认处理的路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.5.2 第二种静态处理如果将所有页面交由中央调度器处理，即，web.xml中加入 1234567891011121314151617181920&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- springmvc配置文件位置的属性 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 指定自定义文件的位置 --&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 自定义springmvc配置文件读取的位置 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--表示默认资源全给DispatcherServlet处理了，而DispatcherServlet本身是没有对静态资源的处理能力--&gt; 会由于中央调度器没有对静态页面的默认处理器 springMvc可以处理没有被请求映射的处理器 导致页面转发异常，出现404，资源访问不了或不存在 需要在springmvc.xml（dispatcherServlet.xml）中添加以下配置 1&lt;mvc:default-servlet-handler/&gt; 等同于在web.xml中配置： 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注意： 对于web.xml、spring.xml配置文件的修改，需要对服务器进行热部署，即redeloy或者restart 这种方式会导致只能处理静态资源，而中央调度器本身是没有处理静态资源的能力，上面其实是转发给了tomcat处理的，所以第三种处理静态资源出现了 2.5.3 第三种静态处理1&lt;mvc:default-servlet-handler/&gt; 如果没有加上 1&lt;mvc:annotation-driven/&gt; 就只能处理静态资源，其他动态资源无法访问了，为了协调两者需要加入以上两个注解 上面第二种是转发给tomcat处理的，处理的还是tomcat，下面第二种处理静态资源是 spring专门用于处理静态资源访问请求的处理器ResourceHttpRequestHandler 好处是不用再交给tomcat处理了，完全交给spring 需要spring3.0以上 改写成 12345678&lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;mvc:resources mapping=&quot;/html/**&quot; location=&quot;/html/&quot;/&gt;&lt;!-- location 表示静态资源所在的目录, 目录不要使用/WEB-INF/及其子目录 mapping 表示对该资源的请求 （mapping=&quot;/images/**&quot;表示对 以/img/开始的请求，如/img/beauty.jpg、/img/car.png）--&gt; 再改进： 1&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt; 2.6 类型转换器 Spring自带一些常见的类型转换器 public String testDelete(@PathVariable(&quot;id&quot;) String id) ,即可以接受int 类型数据id也可以接受String 类型数据id 自定义类型转换器 编写 自定义类型转换器的类（实现Converter） 1234567891011public class MyConverter implements Converter&lt;String, Object&gt;&#123; @Override public Object convert(String source) &#123;//source:2-zs String[] studentStrArr = source.split(&quot;-&quot;); Student student = new Student(); student.setId(Integer.parseInt(studentStrArr[0])); student.setName(studentStrArr[1]); return student; &#125;&#125; 控制器： 123456@RequestMapping(value = &quot;testConverter&quot;)public String testConverter(@RequestParam(value = &quot;studentInfo&quot;) Student student) &#123; System.out.println(student.getId() + &quot;,&quot; + student.getName()); return &quot;success&quot;;&#125; 其中@RequestParam(value = &quot;studentInfo&quot;) 是触发转换器的桥梁 @RequestParam(value = &quot;studentInfo&quot;)接收的数据 是前端传过来的：2-zs,但是需要将该数据复制给 修饰的 目的对象Student 因此SpringMVC可以发现接收的数据和 目标数据的不一致，并且这两种数据分别是String,Student,正好符合转化器 1public Student convert(String source) &#123;//source:2-zs 从而触发 配置：将MyConverter加入到springmvc中 123456789101112131415&lt;!-- 自定义转换器 纳入SpringIOC容器 --&gt;&lt;bean id=&quot;myConverter&quot; class=&quot;org.zhkucst.converty.MyConverter&quot;&gt;&lt;/bean&gt;&lt;!-- 将myConverter再纳入SpringMVC提供的转换器Bean --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 将conversionService 注册到annotation-driven中 --&gt;&lt;!-- 此配置是SpringMVC的基础配置，很多功能都需要通过该注解来协调 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 2.7 数据格式化1SimpleDateFormat sdf = new SimpleDateFormat (&quot;yyyy-MM hh:mm:ss&quot;); SpringMVC提供了很多注解，方便我们数据格式化 实现步骤： 配置 1234&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 配置数据格式化所依赖的bean --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;/bean&gt; 通过注解使用 1234567public class Student &#123; @NumberFormat(pattern = &quot;###,#&quot;)//格式化数字 private int id; private String name; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)//格式化日期 private Date birthday; 处理器： 12345678910111213@RequestMapping(value = &quot;testDateFormat&quot;)public String testDateFormat(Student student, BindingResult result) &#123; System.out.println(student.getId() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getBirthday()); if(result.getErrorCount() &gt; 0) &#123; for(FieldError error : result.getFieldErrors()) &#123; System.out.println(error.getDefaultMessage()); &#125; &#125; return &quot;success&quot;;&#125; BindingResult result传的参数相当于捕获异常，try&#123;&#125; catch()&#123;&#125;,因此不会抛异常了 包中，数据格式化的bean类FormattingConversionServiceFactoryBean包含了转换器的bean类ConversionServiceFactoryBean 123&lt;!--既可以实现转换、也可以实现数据格式--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; 123&lt;!--只能实现转换--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;&lt;/bean&gt; 2.7.1 错误信息1public String testDateTimeFormat（Student student, BindingResult result, Map&lt;String,Object&gt; map） 需要验证的数据是 Student中的birthday, SpringMVC要求 如果校验失败 则将错误信息 自动放入 该对象之后 的参数中， 即Student student, BindingResult result之间 不能有其他参数 如果要将控制台的错误信息传到jsp中显示，则可以将 错误信息对象放入request域中然后在jsp中 从 request取出 2.7.2数据校验JSR-303 是JAVA EE6 中的一项子规范，叫做Bean Validation，Hibernate Validator 是 Bean Validation 的参考实现，提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。 数据校验 ​ 1.JSR303 ​ 2.Hibernate Validator 使用Hibernate Validator步骤： 导包 classmate-1.5.1.jar hibernate-validator-5.4.1.Final.jar hibernate-validator-annotation-processor-5.4.1.Final.jar jboss-logging-3.3.0.Final.jar validation-api-1.1.0.Final.jar 配置 此时mvc:annotation-driven的作用，要实现Hibernate Validator/JSR303校验(或者其他各种校验) 必须实现SpringMVC提供的一个接口： ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类 &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean 所以配置只需要配置 1&lt;mvc:annotation-driven/&gt; 直接使用注解 1234567891011public class Student &#123; @NumberFormat(pattern = &quot;###,#&quot;) private int id; private String name; @Past @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birthday; @Email private String email; 要求：在属性上使用注解后，需要在控制器中的参数Student前使用注解@Valid，标明上是要有合法性的参数 12@RequestMapping(value = &quot;testDateFormat&quot;)public String testDateFormat(@Valid Student student, BindingResult result) &#123; 2.8 路径2.8.1 绝对路径和相对路径jsp请求路径： 12345&lt;form action=&quot;some.do&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;other的post请求&quot;&gt;&lt;/form&gt; 不以 “/“ 开头 参考的地址为 http://localhost:8888/ch06-path/ 即 http://localhost:8888/ch06-path/ + some.do 隐患： 由于多次请求导致路径发生变化，从而请求不到资源，原因：使用了相对路径 常见例子： index.jsp访问 user/some.do http://localhost:8080/project/user/some.do 中返回到index.jsp http://localhost:8080/project/user/some.do (是因为是由处理器发起了转发，因而地址没有改变) 再次访问some.do就会出现 http://localhost:8080/project/user/user/some.do 解决方法： 使用base标签 1&lt;base href=&quot;http://localhost:8888/$&#123;pageContext.request.ContextPath&#125;/&quot;&gt; 则form表单或a标签每次请求的基地址都是以http://localhost:8888/$&#123;pageContext.request.ContextPath&#125;/开头 + some.do 更加动态、灵活的方式 1234567&lt;%String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; 以 “/”开头 参考的地址为 http://localhost:8888/ 即 http://localhost:8888/ + some.do 处理方法： 12345&lt;form action=&quot;/ch06-path/some.do&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;other的post请求&quot;&gt;&lt;/form&gt; 不够灵活： 解决方法： 加上$&#123;pageContext.request.ContextPath&#125; $&#123;pageContext.request.ContextPath&#125;表示项目根 即http://localhost:8888/ + ch06_path 即 12345&lt;form action=&quot;$&#123;pageContext.request.ContextPath&#125;/some.do&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;other的post请求&quot;&gt;&lt;/form&gt; 扩展： ant风格的请求路径： ？：单字符 * ：任意字符（0或多个） **：任意目录 2.8.2 路径访问问题web项目中，WEB-INF是受保护的，通过url路径访问会出现404,不允许访问 WEB-INF目录中的文件只能通过转发来实现 2.9 RequestMapping2.9.1 @RequestParam注解如果表单的传值和控制器中的形参变量不一致，则需要通过在变量名前加上注RequestParam 表单提交： 12345&lt;form action=&quot;receiveparam.do&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;rname&quot;&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;rage&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;other的post请求&quot;&gt;&lt;/form&gt; 控制器： 添加注解：@RequestParam(value = &quot;rname&quot;) ​ @RequestParam(value = &quot;rage&quot;) 表示请求中的参数，例如url：localhost:8080/MyProject?rname=&amp;rage= value值与表单的传值一致 1234567891011@RequestMapping(value = &quot;receiveparam.do&quot;)public ModelAndView receiveParam(@RequestParam(value = &quot;rname&quot;) String name, @RequestParam(value = &quot;rage&quot;) Integer age)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;show&quot;); return mv;&#125; 注意： 不能直接访问servlet地址，必须先通过表单传参或地址栏传参 出错400 所以，需要在方法前再加另外一个注解表明是否表示请求中必须包含此参数 12@RequestParam(value = &quot;rname&quot;, required = false) String name,@RequestParam(value = &quot;rage&quot;, required = false) Integer age) 默认require为true，即包含的参数是必须的 localhost:8080/MyProject?rname=&amp;rage= false则非必须，可以有，也可以没有 2.9.2 @RequestMapping属性 传参数 12@RequestMapping(value=&quot;welcome&quot;,method=&quot;RequestMethod.Post&quot;, params=&#123;&quot;name=zs&quot;,&quot;age!=23&quot;,&quot;!height&quot;&#125;) 说明： age可以为空，不传值 height不能传值 请求头信息 设置请求头信息： 12@RequestMapping(value=&quot;welcome&quot;,method=&quot;RequestMethod.Post&quot;, headers =&#123;&quot;Accept=text/html,application/xhtml....&quot;,&quot;....&quot;&#125; 获取请求头信息： 1234@RequestMapping(value = &quot;testRest/&#123;id&#125;&quot;, method = RequestMethod.GET)public String welcome4(@PathVariable(&quot;id&quot;) Integer id, @RequestHeader(&quot;Accept-Language&quot;) String al) &#123;&#125; 说明：需要支持或兼容该请求头的浏览器 路径请求参数 表单： 1&lt;a href=&quot;&quot;handler/welcome/zs&quot;&gt;路径传参&lt;/a&gt; 后台接收： 123@RequestMapping(value=&quot;welcome/&#123;name&#125;&quot;,method=&quot;RequestMethod.Post&quot;, public String welcome(@PathVariable(&quot;name&quot;) String name) &#123; &#125; Cookie信息 通过mvc获取cookie值（JESSIONID） @CookieValue (前置知识：服务端在接受客户端第一次请求时，会给客户端分配一个session(该session包含一个sessionId)) 小结： SpringMVC处理各种参数的流程、逻辑： 请求：前端发请求a-&gt;@RequestMapping(&quot;a&quot;); 处理请求中的参数： ​ @RequestMapping(&quot;a&quot;) ​ public String aa(&quot;@Xxx注解(xyz)&quot; xyz) 2.9.3 指定请求方式Method属性在方法名上标明注解 123@RequestMapping(value = &#123;&quot;/some.do&quot;, &quot;/first.do&quot;&#125;, method = RequestMethod.GET)public ModelAndView doSome()&#123;//如果不指定请求方式，则没有限制 form标签指定get方法，控制器不能指定post方法 否则会出现405错误 123&lt;form action=&quot;test/some.do&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;other的post请求&quot;&gt;&lt;/form&gt; 2.10 处理模型数据 数据模型：ModelAndView、Model、ModelMap、Map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@RequestMapping(value = &quot;testMap&quot;)public String testMap(Map&lt;String,Object&gt; map) &#123; Student student = new Student(); student.setId(3); student.setName(&quot;zs&quot;); map.put(&quot;student&quot;, student); return &quot;success&quot;;&#125;@RequestMapping(value = &quot;testModelMap&quot;)public String testModelMap(ModelMap modelMap) &#123; Student student = new Student(); student.setId(3); student.setName(&quot;zs&quot;); modelMap.put(&quot;student&quot;, student); return &quot;success&quot;;&#125;@RequestMapping(value = &quot;testModel&quot;)public String testModel(Model model) &#123; Student student = new Student(); student.setId(3); student.setName(&quot;zs&quot;); model.addAttribute(&quot;student&quot;, student); return &quot;success&quot;;&#125;@RequestMapping(value = &quot;testModelAndView&quot;)public ModelAndView testModelAndView() &#123; ModelAndView modelAndView = new ModelAndView(); Student student = new Student(); student.setId(3); student.setName(&quot;zs&quot;); modelAndView.addObject(&quot;student&quot;, student); modelAndView.setViewName(&quot;success&quot;); return modelAndView;&#125; 将数据放入request后，也放入session 类名上添加 @SessionAttributes(&quot;student4&quot;) : 静态写法 参数名与requesst域的key值相同，表示指定哪一个k-v对 @SessionAttributes(types = Student.class) ： 动态代理写法 具体是以调用哪个方法中的student来动态同步到session @ModelAttribute 有该注解的方法在会在每次请求前先执行 并且该方法的参数map.put()可以将对象 放入即将查询的参数中 必须满足的约定： map.put(k,v)其中的k必须是即将查询方法参数的 首字母小写testModelAtribute(Student xxx) , 即student; 如果不一致,需要通过@ModelAttribute声明。 ​ map.put(&quot;stu&quot;,student) testModelAtribute( @ModelAttribute(&quot;stu&quot;） Student student ) 示例： 1234&lt;form action=&quot;handler/testModelAttribute&quot;&gt; name:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;testModelAttribute&quot;&gt;&lt;/form&gt; 12345678910111213141516171819202122232425262728293031323334353637383940/*先执行该方法*/ @ModelAttributepublic void queryStudents(Map&lt;String, Object&gt; map) &#123; Student student = new Student(); student.setId(5); student.setName(&quot;ww&quot;); System.out.println(student.getId()+&quot;,&quot; + student.getName()); map.put(&quot;student&quot;, student);&#125;/*执行完后，该注解会被标记为通知，会执行框架中的另外的方法（method,map,student,handler） 目的：把map中包含的student传给请求的方法体参数中,并通过前端的传值，覆盖student 原理：面向切面，即AOP method: public String testModelAttribute(Student student) map: map.put(&quot;student&quot;, student); student: Student student = new Student(); student.setId(5); student.setName(&quot;ww&quot;); handler: @Controller@RequestMapping(value = &quot;handler&quot;)public class SpringMVCHandler &#123; *//*前端请求处理的方法，先调用有注解@ModelAttribute的方法*/@RequestMapping(value = &quot;testModelAttribute&quot;)public String testModelAttribute(Student student) &#123; System.out.println(student.getId()+&quot;,&quot; + student.getName()); return &quot;success&quot;;&#125; 2.11 返回值2.11.1 返回 ModelAndView、String ModeAndView 前面已经演示过：返回数据 + 视图 String，返回String（视图） 可分为逻辑视图和完整视图 ​ （1）逻辑视图需要配置视图解析器 1234567@RequestMapping(value = &quot;returnString-view.do&quot;)public String doReturnView(HttpServletRequest request, String name, int age)&#123; request.setAttribute(&quot;myname&quot;, name); request.setAttribute(&quot;myage&quot;, age); return &quot;show&quot;;&#125; ​ （2）完整视图不能配置视图解析器，根目录是WebContent或者webapp 12345678//处理器方法返回String, 表示完整路径，不能配置视图解析器@RequestMapping(value = &quot;returnString-view2.do&quot;)public String doReturnView2(HttpServletRequest request, String name, int age)&#123; request.setAttribute(&quot;myname&quot;, name); request.setAttribute(&quot;myage&quot;, age); return &quot;/WEB-INF/view/show.jsp&quot;;&#125; 2.11.2 返回 void、Object void 用于处理ajax 需要使用ajax，导入jquery-3.5.1.js 以及 pom中加入依赖包（jackson-databind 和jackson-core） 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 前端： 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function button_data()&#123; $.ajax(&#123; url:&quot;returnVoidAjax.do&quot;, data:&#123; name:&quot;张三&quot;, age:&quot;21&quot; &#125;, type:&quot;post&quot;, dataType:&quot;json&quot;, success:function(msg)&#123; alert(msg.name + &quot;,&quot; + msg.age); &#125; &#125;);&#125;;&lt;/script&gt; 1dataType:&quot;json&quot;,//是指定控制返回的类型，如果没有它，jquery默认也是当成json处理 但处理器中response没有设置响应头，则数据无法传到前端 1&lt;button id=&quot;btn&quot; onclick=&quot;button_data()&quot;&gt;发起ajax请求&lt;/button&gt; 控制器： 123456789101112131415161718@RequestMapping(value = &quot;returnVoidAjax.do&quot;)public void returnVoidAjax(HttpServletResponse response, String name, Integer age) throws IOException &#123; Student student = new Student(); student.setName(name); student.setAge(age); String json = &quot;&quot;; ObjectMapper om = new ObjectMapper(); json = om.writeValueAsString(student); //设置响应头，设备响应编码，不设置会乱码 response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter pw = response.getWriter(); pw.print(json); pw.close();&#125; 响应头：增加 12//设置响应头，设备响应编码，不设置会乱码response.setContentType(&quot;application/json;charset=utf-8&quot;); 后显示： json格式字符串转成json对象 没有增加显示： 导致的乱码： 虽然前端显示出的数据正常，但F12控制台中response的json格式的字符串和preview的json对象 response从服务器返回的是json格式的字符串{name:”张三”, age: 21} 因为jquery可以把json格式字符串转换成json对象,并赋值给success中的形参msg 但是request的请求头是默认有的： Object 例如String, Integer, Map, List, Student等等都是对象 对象有属性， 属性就是数据，所以返回Object表示数据，和视图无关 可以使用对象表示的数据，响应ajax请求。 12&lt;!--加入&lt;mvc:annotation-driven&gt; 注解驱动--&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 123456789@RequestMapping(value = &quot;returnObjectAjax.do&quot;)@ResponseBodypublic Student returnStudentAjax(String name, Integer age)&#123; Student student = new Student(); student.setName(name); student.setAge(age); return student;&#125; 1234567891011121314function button_data()&#123; $.ajax(&#123; url:&quot;returnObjectAjax.do&quot;, data:&#123; name:&quot;张三同学&quot;, age:&quot;21&quot; &#125;, type:&quot;post&quot;, dataType:&quot;json&quot;, success:function(resp)&#123; alert(msg.name + &quot;,&quot; + msg.age); &#125; &#125;);&#125;; 2.11.3 返回 List&lt;Object&gt;与Object类似 控制器： 12345678910111213141516171819202122@RequestMapping(value = &quot;returnObjectArrayAjax.do&quot;)@ResponseBodypublic List&lt;Student&gt; returnStudentArrayAjax(String name, Integer age)&#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); Student student = new Student(); student.setName(&quot;张三&quot;); student.setAge(21); list.add(student); student = new Student(); student.setName(&quot;李四&quot;); student.setAge(24); list.add(student); return list;&#125; 前端： 123456789101112131415161718function button_data()&#123; $.ajax(&#123; url:&quot;returnObjectArrayAjax.do&quot;, data:&#123; name:&quot;张三同学&quot;, age:&quot;21&quot; &#125;, type:&quot;post&quot;, dataType:&quot;json&quot;, success:function(resp)&#123; $.each(resp,function (i, n)&#123; alert(n.name + &quot; , &quot; + n.age + &quot;/&quot; ) &#125;) &#125; &#125;);&#125;; 2.11.4 返回 String 文本数据123public String returnString(HttpServletResponse response)&#123; return &quot;返回String类型&quot;;&#125; 1234567891011121314151617181920$.ajax(&#123; //url:&quot;returnVoidAjax.do&quot;, // url:&quot;returnObjectAjax.do&quot;, //url:&quot;returnObjectArrayAjax.do&quot;, url:&quot;returnString.do&quot;, data:&#123; name:&quot;张三同学&quot;, age:&quot;21&quot; &#125;, type:&quot;post&quot;, /** * 这里不能用上json了，因为文本数据转换不了json对象 * 如果文本数据是 &quot;&#123;name:&quot;zs&quot;,age:&quot;21&quot;&#125;&quot; * 则可以转换 */ dataType:&quot;text&quot;, success:function(resp)&#123; alert(resp); &#125;&#125;); 2.11.5 json 数据手动处理需要jackson-core的两个包 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516@RequestMapping(value = &quot;returnVoidAjax.do&quot;)public void returnVoidAjax(HttpServletResponse response, String name, Integer age) throws IOException &#123; Student student = new Student(); student.setName(name); student.setAge(age); String json = &quot;&quot;; ObjectMapper om = new ObjectMapper(); json = om.writeValueAsString(student); response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter pw = response.getWriter(); pw.print(json); pw.close();&#125; 2.11.6 @ResponseBody的 json 数据处理原理 实现步骤 加入处理json的工具库的依赖 springmvc默认使用的jackson 在springmvc配置文件之间加入&lt;mvc:annotation-driven&gt; 注解驱动 1json = om.writeValueAsString(student); 在处理器的方法的上面加入@ResponseBody注解 123response.setContexType(&quot;application/json;charset=utf-8&quot;);PrintWriter pw = response.getWriter();pw.println(json); springmvc处理器方法的返回Object,可以转为json输出到浏览器，响应ajax的内部原理 1.&lt;mvc:annotation-driven&gt;注解驱动 注解驱动实现的功能是完成java对象到json、xml、text、二进制等数据格式的转换的7个实现类对象，包括MappingJackson2HttpMessageConvertor(使用jackson工具库中的ObjectMapper实现java对象转为json对象 ) HttpMessageConveter接口：消息转换器 功能：定义了java转为json，xml等数据格式的方法。这个接口有很多实现类。 这些实现类完成java对象到json、java对象到xml、java对象到二进制数据的转换 下面有两个方法是控制器类把结果输出给浏览器时使用的： 12boolean canWrite(Class&lt;?&gt; var1, @Nullable MediaType var2);void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3) 123456789//例如处理器方法@RequestMapping(value = &quot;returnObject.do&quot;)public Student returnVoidAjax(HttpServletResponse response, String name, Integer age) throws IOException &#123; Student student = new Student(); student.setName(name); student.setAge(age); return student;&#125; 123451)canWrite:作用检查处理器方法的返回值，能不能转为var2表示的数据格式。检查student(name, age)能不能转为var2表示的数据格式，如果检查能转成json，返回trueMediaType：表示数据格式的，例如json、xml等等StringHttpMessageConverterMappingJackson2HttpMessageConverter 122)write: 把处理器方法的返回值对象，调用jackson中的ObjectMapper转为json字符串json = om.writeValueAsString(student); 未加入注解驱动时的状态： 12&lt;!--加入&lt;mvc:annotation-driven&gt; 注解驱动--&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 自动实例化MessageConverter4个实现类 12org.springframework.http.converter.ByteArrayHttpMessageConverter, org.springframework.http.converter.StringHttpMessageConverter, org.springframework.http.converter.xml.SourceHttpMessageConverter, org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter 加入注解驱动时的状态： 自动实例化MessageConverter7个实现类 123org.springframework.http.converter.ByteArrayHttpMessageConverter, org.springframework.http.converter.StringHttpMessageConverter, **org.springframework.http.converter.ResourceHttpMessageConverter,** **org.springframework.http.converter.ResourceRegionHttpMessageConverter,** org.springframework.http.converter.xml.SourceHttpMessageConverter, org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter, **org.springframework.http.converter.json.MappingJackson2HttpMessageConverter** 2.11.7 乱码问题通过请求过来mapping设置响应头 1@RequestMapping(value = &quot;returnString.do&quot;, produces = &quot;text/plain;charset=utf-8&quot;) 设置前（默认） 设置后： 2.12 RESTFul 风格REST风格：软件编程风格 Springmvc: GET : 查 POST: 增 DELETE : 删 PUT : 改 普通浏览器 只支持get / post 方式请求， 其他请求方式 如 delete / put 需借助过滤器 过滤器的约定： 过滤的是input标签； 标签中类型为隐藏域，而且name必须为”_method“ 请求方式为post 根据其value的值来判断 如果value为delete 则将请求改为delete，如果为put，改为put 不指定方法请求方式，默认为get 使用restful风格时，不建议使用其他方式传参，比如”?id=1“，不建议混合使用restful和一般方式，即使可以使用 ant风格的请求路径： ？：单字符 *： 任意字符（0或多个） **： 任意目录 2.12.1 Get123&lt;form action=&quot;handler/testRest/1234&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;get&quot;&gt;&lt;/form&gt; 123456@RequestMapping(value = &quot;testRest/&#123;id&#125;&quot;, method = RequestMethod.GET)public String welcome4(@PathVariable(&quot;id&quot;) Integer id) &#123; System.out.println(&quot;get: 改&quot; + id); return &quot;success&quot;;&#125; 2.12.2 Post1234&lt;form action=&quot;handler/testPost/1234&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;POST&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post&quot;&gt;&lt;/form&gt; 123456@RequestMapping(value = &quot;testRest/&#123;id&#125;&quot;, method = RequestMethod.POST)public String welcome1(@PathVariable(&quot;id&quot;) Integer id) &#123; System.out.println(&quot;post: 增&quot; + id); return &quot;success&quot;;&#125; 2.12.3 Delete1234&lt;form action=&quot;handler/testDelete/1234&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post&quot;&gt;&lt;/form&gt; 123456@RequestMapping(value = &quot;testRest/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String welcome2(@PathVariable(&quot;id&quot;) Integer id) &#123; System.out.println(&quot;delete: 删&quot; + id); return &quot;success&quot;;&#125; 2.12.4 Put1234&lt;form action=&quot;handler/testPut/1234&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post&quot;&gt;&lt;/form&gt; 123456@RequestMapping(value = &quot;testRest/&#123;id&#125;&quot;, method = RequestMethod.PUT)public String welcome3(@PathVariable(&quot;id&quot;) Integer id) &#123; System.out.println(&quot;put: 改&quot; + id); return &quot;success&quot;;&#125; 2.12.5 声明隐藏域过滤器12345678&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 版本： 1.tomcat7版本及以下，tomcat默认不支持RESTful风格的DELETE和PUT, 配置过滤器后tomcat就可以访问了 2.tomcat8版本即以上，配置过滤器后，执行表单后会跳转到405页面，说明高版本的tomcat是不支持RESTful风格 方法：在跳转成功的jsp页面，添加错误页面参数isErrorPage=“true” 不配置过滤器默认是支持RESTful风格，也就是不用自己配置过滤器 3. SSM 整合开发3.1 Spring 容器和SpringMVC 容器依赖包： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1-b03&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt; 另加：用于注解@Resource 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; 123456789101112&lt;!--build中添加以下，把java下的xml文件配置一起打包到target中--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 如果xml文件写在与dao同包名下的java资源中，则需要以上build指定xml到打包到target，否则将报错--Request processing failed; nested exception is org.apache.ibatis.binding.BindingException:mybatis和mapper绑定失败 如果xml文件写在resources中，则只需新建同包名的xml即可 3.2 整合内置 tomcat为什么要整合内置tomcat? 内置tomcat可以在别人部署项目时不用纠结到使用tomcat版本的问题 即可以在没有tomcat环境下使用 步骤： 1.导入依赖 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;path&gt;/&lt;/path&gt; &lt;useBodyEncodingForURI&gt;true&lt;/useBodyEncodingForURI&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 手动配置maven启动内置tomcat 最后直接运行即可 3.3 xml 配置1.dispatcherServlet.xml : 中央调度器 （1）声明注解@controller所在包的扫描器； （2）内部资源视图解析器； （3）声明mvc注解驱动； 2.applicationContext.xml : springIOC容器 （1）声明db.properties所在位置； （2）声明数据源； （3）声明SqlSessionFactoryBean,创建SqlSessionFactory； （4）声明mapper所在包扫描器，自动创建dao对象； （5）声明注解@Service所在包的扫描器 3.mybatiis.xml : mybatis容器 （1）声明别名 （2）挂载所有mapper配置文件，配置文件的路径默认在resources下（pom没有声明java中对xml文件的打包） 4.mapper.xml : mapper容器 （1）配置namespace,用于绑定Dao接口的，即面向接口编程 （2）增删查改标签 3.4 Ajax 请求123456789101112131415161718192021222324252627282930313233343536&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; loadStudentData(); $(&quot;#btnLoader&quot;).click(function ()&#123; loadStudentData(); &#125;)&#125;)function loadStudentData()&#123; $.ajax(&#123; url:&quot;student/queryStudents.do&quot;, type:&quot;post&quot;, dataType:&quot;json&quot;, success:function (data)&#123; $(&quot;#info&quot;).html(&quot;&quot;); $.each(data, function(i,n)&#123; $(&quot;#info&quot;).append(&quot;&lt;tr&gt;&quot;) .append(&quot;&lt;td&gt;&quot; + n.id + &quot;&lt;/td&gt;&quot;) .append(&quot;&lt;td&gt;&quot; + n.name + &quot;&lt;/td&gt;&quot;) .append(&quot;&lt;td&gt;&quot; + n.age + &quot;&lt;/td&gt;&quot;) .append(&quot;&lt;/tr&gt;&quot;) &#125;); &#125; &#125;);&#125;&lt;/script&gt; 3.5 三层整合3.5.1 Controller12345678910111213141516171819202122232425262728293031323334353637@Controller@RequestMapping(value = &quot;/student&quot;)public class StudentController &#123; @Resource private IStudentService studentService; //注册学生 @RequestMapping(value = &quot;/addStudent.do&quot;) public ModelAndView addStudent(Student student)&#123; ModelAndView mv = new ModelAndView(); String tips = &quot;注册失败&quot;; int nums = studentService.addStudent(student); if(nums &gt; 0)&#123; //注册成功 tips = &quot;学生【&quot; + student.getName() + &quot;】注册成功&quot;; &#125; //添加数据 mv.addObject(&quot;tips&quot;, tips); //指定结果页面 mv.setViewName(&quot;result&quot;); return mv; &#125; @RequestMapping(value = &quot;/queryStudents.do&quot;) @ResponseBody public List&lt;Student&gt; queryStudents()&#123; List&lt;Student&gt; students = studentService.findStudents(); System.out.println(students); return students; &#125;&#125; 3.5.2 Service12345678910111213141516171819202122232425262728293031323334353637@Controller@RequestMapping(value = &quot;/student&quot;)public class StudentController &#123; @Resource private IStudentService studentService; //注册学生 @RequestMapping(value = &quot;/addStudent.do&quot;) public ModelAndView addStudent(Student student)&#123; ModelAndView mv = new ModelAndView(); String tips = &quot;注册失败&quot;; int nums = studentService.addStudent(student); if(nums &gt; 0)&#123; //注册成功 tips = &quot;学生【&quot; + student.getName() + &quot;】注册成功&quot;; &#125; //添加数据 mv.addObject(&quot;tips&quot;, tips); //指定结果页面 mv.setViewName(&quot;result&quot;); return mv; &#125; @RequestMapping(value = &quot;/queryStudents.do&quot;) @ResponseBody public List&lt;Student&gt; queryStudents()&#123; List&lt;Student&gt; students = studentService.findStudents(); System.out.println(students); return students; &#125;&#125; 3.5.3 Dao1234567public interface StudentDao &#123; int insertStudent(Student student); List&lt;Student&gt; selectStudents();&#125; 3.5.4 xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace :该mapper.xml的 唯一标识用于绑定Dao接口的，即面向接口编程--&gt;&lt;mapper namespace=&quot;org.zhkucst.dao.StudentDao&quot;&gt; &lt;!-- 后续通过 namespace.id --&gt; &lt;!-- parameterType:输入参数的类型 resultType:查询返回值的类型，返回类型 --&gt; &lt;select id=&quot;selectStudents&quot; resultType=&quot;student&quot;&gt; select id, name, age from student &lt;/select&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into student(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3.5.5前端index.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;/&quot;&gt; &lt;title&gt;功能入口&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot;&gt; &lt;p&gt;SSM整合&lt;/p&gt; &lt;img src=&quot;imges/ssm.jpg&quot;/&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=&quot;addStudent.jsp&quot;&gt;注册学生&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=&quot;listStudent.jsp&quot;&gt;浏览学生&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; addStudent.jsp 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;/&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot;&gt; &lt;form action=&quot;student/addStudent.do&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; listStudent.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;/&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; loadStudentData(); $(&quot;#btnLoader&quot;).click(function ()&#123; loadStudentData(); &#125;) &#125;) function loadStudentData()&#123; $.ajax(&#123; url:&quot;student/queryStudents.do&quot;, type:&quot;post&quot;, dataType:&quot;json&quot;, success:function (data)&#123; $(&quot;#info&quot;).html(&quot;&quot;); $.each(data, function(i,n)&#123; $(&quot;#info&quot;).append(&quot;&lt;tr&gt;&quot;) .append(&quot;&lt;td&gt;&quot; + n.id + &quot;&lt;/td&gt;&quot;) .append(&quot;&lt;td&gt;&quot; + n.name + &quot;&lt;/td&gt;&quot;) .append(&quot;&lt;td&gt;&quot; + n.age + &quot;&lt;/td&gt;&quot;) .append(&quot;&lt;/tr&gt;&quot;) &#125;); &#125; &#125;); &#125; &lt;/script&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot;&gt; &lt;table style=&quot;border:1px solid&quot;&gt; &lt;thead style=&quot;border:1px solid&quot;&gt; &lt;tr&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;info&quot; style=&quot;border:1px solid&quot;&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;input id=&quot;btnLoader&quot; type=&quot;button&quot; value=&quot;查询数据&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result.jsp 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; result.jps 结果页面 注册结果：$&#123;tips&#125;&lt;/body&gt;&lt;/html&gt; 4. 转发和重定向4.1 转发转发和重定向是不受视图解析器影响的，就当没有视图解析器 controller 1234567891011@RequestMapping(value = &quot;doForward.do&quot;)public ModelAndView doForward()&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;欢迎使用springmvcweb开发&quot;); mv.addObject(&quot;fun&quot;, &quot;执行的是dodoForward方法&quot;); mv.setViewName(&quot;forward:/WEB-INF/view/show.jsp&quot;); return mv;&#125; 总结： 1.转发可以访问/WEB-INF/目录下的视图以及其他文件 2.转发如果携带了数据（请求是实例化在服务器中，数据保存在该request中） 可以在其他视图中视图EL表达式$&#123;requestScope.name&#125;获取属性值为“name”的值 3.也可以通过request.getAttribute(&quot;name&quot;)获取，两者等价 4.2 重定向controller 1234567891011@RequestMapping(value = &quot;doRedirect.do&quot;)public ModelAndView doRedirect(String name, Integer age)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;redirect:/hello.jsp&quot;); return mv;&#125; 2.视图： 123456&lt;body&gt; &lt;h3&gt;hello.jsp&lt;/h3&gt; &lt;h3&gt;myname数据1：$&#123;param.myname&#125;&lt;/h3&gt; &lt;h3&gt;myage数据2：$&#123;param.myage&#125;&lt;/h3&gt; &lt;h3&gt;myage数据2：&lt;%=request.getParameter(&quot;myname&quot;)%&gt;&lt;/h3&gt;&lt;/body&gt; 总结： 1.重定向是第二次请求转发，请求的数据会丢失，不会保留在服务器的request中，是拿了一个新的请求 2.重定向如果携带了数据，携带的数据不是保存在服务器中，而是在新的请求的形参中，例如：http://locahost:8080/MyProject?name=zs 3.重定向到新的视图中，可以通过$&#123;param.name&#125;获取形参中的变量值，注意，只能获取4个基本类型+String， 其他类型会以地址@***显示 4.也可以通过request.getParameter(“name”)获取属性值为“name”的值 5.注意，通过视图传到控制器，再重定向的，视图中的参数值是获取不到的，两个请求不一样，第一个请求 结束后已经自动销毁 4.3 e额外知识1234$&#123;param.name&#125; == request.getParameter(&quot;name&quot;)$&#123;requestScope.name&#125; == request.getAttribute(&quot;name&quot;)$&#123;sessionScope.name&#125; == session.getAttribute(&quot;name&quot;)$&#123;applicationScope.name&#125; == application.getAttribute(&quot;name&quot;) session和applicaton如果要在同一个请求中，可以通过request.getSession()和 request.getSession().getServletContext()获取得到 如果在同一视图，直接appliction.setAttribute()、session.setAttribute()就可以了 5. 集中统一处理异常5.1 理论异常处理： 通过注解实现异常统一处理：@ExceptionHandler springmvc框架采用的是统一、全局的异常处理。 把controller中的所有异常处理都集中到一个地方。采用的是aop的思想，把业务逻辑和异常处理代码分开，解耦合。 使用两个注解 @ExceptionHandler @ControllerAdvice 123456789101112异常处理步骤：1.新建maven web项目2.加入依赖3.新建一个自定义异常类 MyUserException , 再定义它的子类NameException, AgeException4.在controller抛出NameException , AgeException5.创建一个普通类，作用全局异常处理类 1)在类的上面加入@controllerAdvice 2)在类中定义方法，方法的上面加入@ExceptionHandle6.创建springmvc的配置文件 1)组件扫描器，扫描@Controller注解 2)组件扫描器，扫描@ControllerAdvice所在的包名 3)声明注解驱动 结果图： 原理： 自定义普通类，通过继承Exception使它成为异常类，然后再用注解让springmvc对它管理： 发生异常，有springmvc来抛异常，不交给jvm虚拟机 总结： 如果有方法抛出一个异常，对该异常的处理有两种方法，则优先级：最短优先 如果一个方法用于处理异常，并且只处理当前类中的异常：@ExceptionHandler 如果一个方法用于处理异常，并且处理所有类中的异常，类前加@ControllerAdvice, 处理异常的方法前加@ExceptionHandler 优先级： 使用@ExceptionHandler处理本Controller内部异常优先级最高； 使用@ExceptionHandler+@ControllerAdvice处理外部Controller异常优先级第二； 自定义实现HandlerExceptionResolver接口的类优先级第三； spring-context.xml中配置SimpleMappingExceptionResolver优先级第四； web.xml配置error-page优先级第五； 不做任何处理，会跳转到tomcat默认的异常页面； 自定义异常显示页面：@ResponseStatus ResponseStatusExceptionResolver:自定义异常显示页面 @ResponseStatus 自定义异常显示页面：@ResponseStatus(value=HttpStatus.FORBIDDEN, reason=&quot;数组越界222&quot;) 123@public class MyArrayIndexOutofBoundsException extends Exception&#123;//自定义异常类&#125; @ResponseStatus也可以标注在方法前： 自定义异常类： 1234@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = &quot;数组越界222&quot;)public class MyArrayIndexOutofBoundException extends Exception&#123; &#125; 异常处理的实现类：DefaultHandleExceptionResolver DefaultHandleExceptionResolver:SpringMVC一些常见异常的基础上（300,500,405），新增一些异常，例如： 1234567891011121314* @since 3.0* @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler* @see #handleNoSuchRequestHandlingMethod* @see #handleHttpRequestMethodNotSupported ： 如果请求限制为post，实际请求为get，则会触发此异常* @see #handleHttpMediaTypeNotSupported* @see #handleMissingServletRequestParameter* @see #handleServletRequestBindingException* @see #handleTypeMismatch* @see #handleHttpMessageNotReadable* @see #handleHttpMessageNotWritable* @see #handleMethodArgumentNotValidException* @see #handleMissingServletRequestParameter* @see #handleMissingServletRequestPartException* @see #handleBindException 这些实现了框架已经实现了，只要出现该异常就会触发 通过配置实现异常处理：SimpleMappingExceptionResolver 配置： 1234567891011&lt;!-- SimpleMappingExceptionResolver:以配置的方式处理异常 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 可以省略，默认值为exception --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- 相当于catch(ArithmeticException ex)&#123;跳转:error&#125; --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 控制器： 12345@RequestMapping(value = &quot;testSimpleMappingException&quot;)public String testSimpleMappingException() &#123; System.out.println(1/0);//ArithmeticException return &quot;success&quot;;&#125; 两种方式异常总结： 1.通过继承+注解@ExceptionHandler统一处理异常 2.通过配置实现异常处理，与1无异 3.1和2同时实现，同种异常只由1捕获，即1优先级高于2 5.2 全局异常处理类全局异常处理类相当于一个控制器，只是之前的控制器是控制用户输入数据处理， 而全局异常处理类是控制用户操作出错处理的控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package org.zhkucst.handle;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;import org.zhkucst.exception.AgeException;import org.zhkucst.exception.NameException;/** * ControllerAdvice:控制器增强（给控制器诶增强功能，异常处理功能） * 定义：在类的上面 * 特点：必须让框架指定这个注解所在的包名，需要在springmvc配置文件声明组件扫描器 * 指定@ControllerAdvice所在的包名 * */@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = NameException.class) public ModelAndView doNameException(Exception exception)&#123; //处理NameException异常 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;姓名必须是zs，其他用户不能访问&quot;); mv.addObject(&quot;ex&quot;,exception); mv.setViewName(&quot;nameError&quot;); return mv; &#125; @ExceptionHandler(value = AgeException.class) public ModelAndView doAgeException(Exception exception)&#123; //处理NameException异常 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;你的年龄不能大雨80&quot;); mv.addObject(&quot;ex&quot;,exception); mv.setViewName(&quot;ageError&quot;); return mv; &#125; @ExceptionHandler public ModelAndView doOtherException(Exception exception)&#123; //处理NameException异常 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;其他错误!!&quot;); mv.addObject(&quot;ex&quot;,exception); mv.setViewName(&quot;defaultError&quot;); return mv; &#125;&#125; 5.3 自定义具体处理类步骤： 写一个自定义父类，继承Exception 再分别写具体的异常类 1.MyUserException 123456789package org.zhkucst.exception;public class MyUserExcepton extends Exception&#123; public MyUserExcepton()&#123; super(); &#125; public MyUserExcepton(String message)&#123; super(message); &#125;&#125; 2.NameException 123456789package org.zhkucst.exception;public class NameException extends MyUserExcepton&#123; public NameException()&#123; super(); &#125; public NameException(String message)&#123; super(message); &#125;&#125; 3.AgeException 12345678package org.zhkucst.exception;public class AgeException extends MyUserExcepton&#123; public AgeException()&#123; &#125; public AgeException(String message)&#123; super(message); &#125;&#125; 5.4 前端1.nameError 12345&lt;body&gt; &lt;h3&gt;nameError.jsp&lt;/h3&gt; &lt;h3&gt;msg数据：$&#123;msg&#125;&lt;/h3&gt; &lt;h3&gt;message数据：$&#123;ex.message&#125;&lt;/h3&gt;&lt;/body&gt; 2.ageError 12345&lt;body&gt; &lt;h3&gt;ageError.jsp&lt;/h3&gt; &lt;h3&gt;msg数据：$&#123;msg&#125;&lt;/h3&gt; &lt;h3&gt;message数据：$&#123;ex.message&#125;&lt;/h3&gt;&lt;/body&gt; 3.defaultError 123456&lt;/head&gt;&lt;body&gt; &lt;h3&gt;defaultError.jsp&lt;/h3&gt; &lt;h3&gt;msg数据：$&#123;msg&#125;&lt;/h3&gt; &lt;h3&gt;message数据：$&#123;ex.message&#125;&lt;/h3&gt;&lt;/body&gt; 5.5 处理器12345678910111213141516171819@RequestMapping(value = &quot;some.do&quot;)public ModelAndView doSome(String name, Integer age) throws MyUserExcepton &#123; ModelAndView mv = new ModelAndView(); if(!&quot;zs&quot;.equals(name))&#123; throw new NameException(&quot;姓名不正确！！&quot;); &#125; if(age == null || age &gt; 80)&#123; throw new AgeException(&quot;年龄比较大！！&quot;); &#125; mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;show&quot;); return mv;&#125; 6. 拦截器6.1 *.do 和 *.action 的请求调度规则不仅仅只有*.do和*.action，自定义也可以 12345678910111213141516&lt;!-- springmvc的前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;tony-video-admin-mng&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+&quot;-servlet.xml&quot; --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;tony-video-admin-mng&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 请求方可以是视图也可以是控制器 1.请求方为视图： 2.请求方为控制器： 通过&lt;jsp:forward page=&quot;$&#123;base&#125;/center.action&quot;&gt;&lt;/jsp:forward&gt; 或通过form表单请求，请求的表单action可以不写.action，但浏览器直接请求需要写后缀.action，base取当前页面所在的路径，经过中央调度器处理后，即上面在web.xml配置*.action的所有请求给中央调度器，解析完后如果控制器上有配置requestMapping会捕捉给控制器，控制器上的requestMapping的value属性可以不写.action后缀，这是中央调度器的解析协议。没有就会转给视图，最后才会报404 6.2 拦截器的介绍 拦截器是springmvc中的一种，需要实现HandlerInterceptor接口 拦截器和过滤器类似，功能方向侧重点不同 过滤器是用来过滤请求超时，设置编码字符集等工作； 拦截器是拦截用户的请求，对请求做判断处理的。 拦截器是全局的，可以对多个Controller做拦截 一个项目中可以有0个或多个拦截器，他们在一起拦截用户的请求; 拦截器常用在：用户登录处理，权限检查，记录日志。 拦截器的使用步骤 定义类实现HandlerInterceptor接口 在springmvc配置文件中，声明拦截器，让框架指定拦截器的存在 拦截器的执行时间 在请求处理之前，也就是controller类中的方法执行之前先被拦截； 在控制器方法执行之后也会执行拦截器 在请求处理完成之后也会执行拦截器 拦截器：看做是多个Controller中公用的功能，集中到拦截器统一处理，使用的是aop的思想 6.3 拦截器三个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package org.zhkucst.handle;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Date;public class MyInterceptor implements HandlerInterceptor &#123; private long btime; /** * preHandle叫做预处理方法 * 参数： * Object handle：被拦截的控制对象 * 返回值boolean * true: * false: * * 特点： * 1.方法在控制方法（MyController的doSome）之前先执行的 * 用户的请求首先到达此方法 * 2.在这个 方法中可以获取请求的信息，验证请求是否符合要求 * 可以验证用户是否登录，验证用户是否有权限访问某个连接地址（url） * 如果验证失败，可以戳断请求，请求不能被处理 * 如果验证成功，可以放行请求，此时控制器方法才能执行。 * */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; btime = System.currentTimeMillis(); System.out.println(&quot;拦截器的MyInterceptor的preHandle()&quot;); return true; &#125; /** * postHandle:后处理器方法 * 参数： * Object handler:被拦截的处理器对象MyController * ModeAndView mv:处理器方法的返回值 * * 特点： * 1.在处理器方法之后执行的（MyController.doSome()） * 2.能够获取处理器方法的返回值ModeAndView,可以修改ModeAndView中的 * 数据和视图，可以影响到最后的执行结果 * 3.主要是对原来的执行结果做第二次修正 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;拦截器的MyInterceptor的postHandle()&quot;); if(modelAndView != null)&#123; System.out.println(11); modelAndView.addObject(&quot;mydata&quot;, new Date()); modelAndView.setViewName(&quot;other&quot;); &#125; &#125; /** * +afterCompletion:最后执行的方法 * 参+数： * Ob+ject handle:被拦截的处理器对象 * Exception ex：程序中发生的异常 * 特点： * 1.在请求处理完成后执行的，框架中规定是当你的视图处理完成后，对视图执行了forward,就认为请求处理完成 * 2.一般做资源回收工作，程序请求过程中创建了一些对象，在这里可以 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; long etime = System.currentTimeMillis(); System.out.println(&quot;拦截器的MyInterceptor的afterCompletion()&quot;); System.out.println(&quot;计算机从preHandle到请求处理完成的时间:&quot; + (etime - btime)); &#125;&#125; 6. 4 拦截器的声明web.xml 123456789101112&lt;!--声明拦截器：拦截器可以有0或多个--&gt;&lt;mvc:interceptors&gt; &lt;!--声明第一个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--指定拦截的路径--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--指定不拦截的路径--&gt; &lt;mvc:execlude-mapping path=&quot;/handler/testUpload&quot;/&gt; &lt;!--声明拦截器对象--&gt; &lt;bean class=&quot;org.zhkucst.handle.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 6.5 处理步骤1234567891011拦截处理步骤：1.新建maven web项目2.加入依赖3.创建Controller类4.创建一个普通类，作为拦截器使用 1)实现HandlerInterceptor接口 2)实现接口中的三个方法5.创建show.jsp6.创建springmvc的配置文件 1)组件扫描器，扫描@Controller注解 2)声明拦截器，并指定拦截的请求uri地址 6.6 多拦截器多拦截器的初始化和执行顺序按照声明顺序，声明在前的先初始化 拦截器的初始化是存放在一个ArrayList数组中，数组的顺序跟先后添加是一致的 先初始化的拦截器先拦截，后初始化的后拦截 第一个拦截器preHandle：true ；第二个拦截器preHandle：false 执行结果： 1拦截器的MyInterceptor的preHandle() 2拦截器的MyInterceptor的preHandle() 1拦截器的MyInterceptor的afterCompletion() 原因：1.第二个拦截器没有放行，被拦截下来的处理器方法没有执行，postHandle()不会执行 ​ 2.第一个放行，故而会执行afterCompletion() 第一个拦截器preHandle：true ；第二个拦截器preHandle：true 执行结果： 1拦截器的MyInterceptor的preHandle() 2拦截器的MyInterceptor的preHandle() ===执行doSome=== 2拦截器的MyInterceptor的postHandle() 1拦截器的MyInterceptor的postHandle() 2拦截器的MyInterceptor的afterCompletion() 1拦截器的MyInterceptor的afterCompletion() 第一个拦截器preHandle：false ；第二个拦截器preHandle：true | false 执行结果： 1拦截器的MyInterceptor的preHandle() 原因：第一个拦截器不放行，自然第二个拦截器也不会执行，处理器方法不会执行，后面的postHandle、afterCompletion都不会执行 6.7 拦截器和过滤器的区别1.过滤器是servlet中的对象，拦截器是框架中的对象 2.过滤器实现Filter接口的对象，拦截器是实现HandleInterceptor接口 3.过滤器是用来设置request,response的参数，属性的，侧重对数据过滤的拦截器是用来验证请求的，能截断请求 4.过滤器是在拦截器之前先执行的 5.过滤器是tomcat服务器创建的对象，拦截器是springmvc容器中创建的对象 6.过滤器是一个执行时间点，拦截器有三个执行时间点 7.过滤器可以处理jsp,js,,html等等，拦截器是侧重拦截对Controller的对象，如果你的请求不能被DispatcherServlet接收，这个请求不会执行拦截器内容 8.拦截器拦截普通类方法执行，过滤器过滤servlet请求响应 7. 其他处理器12ApplicationContext ctx = new ClassPathXmlApplication(&quot;beans.xml&quot;);StudentService service = (StudentService) ctx.getBean(&quot;service&quot;); springmvc内部请求的处理流程：也就是springmvc接收请求，到处理完成的过程 1.用户发起请求some.do 2.DispatcherSerrvlet接收请求some.do,把请求转发给处理器映射 处理器映射器：springmvc框架中的一种对象，框架把实现了HandlerMapping接口的类都叫做映射器（多个） 处理器映射器作用：根据请求，从springmvc容器对象中获取处理器对象 1MyController controller = ctx.getBean(&quot;some.do&quot;) 框架把找到的处理器对象放到一个叫做处理器执行链（HandleExecutionChain）的类中保存 HandlerExecutionChain：类中保存着： (1) 处理器对象（MyController）; (2) 项目中的所有的拦截器List&lt;HandlerInterceptor&gt; interceptorList 1HandlerExecutionChain mapperHandler = getHandler(processedRequest) 3.DispatcherServlet把2中的HandlerExecutionChain中的处理器对象交给了处理器适配器对象（多个） 处理器适配器：springmvc框架中的对象，需要实现HandlerAdapter接口 处理器适配器作用：执行处理器方法（调用MyController.doSome() 得到返回值ModeAndView） 中央调度器调用适配器： 1HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHndler()) 执行处理器方法： 1mv = ha.handle(processedRequest, response, mapperHadler.getHandler())* 4.DispatherServlet把3中获取的ModeAndView交给了视图解析器对象 ​ 视图解析器：springmvc中的对象，需要实现ViewResolver接口（可以有多个） ​ 视图解析器作用：组成视图完整路径，在框架中jsp, html不是string表示，而是使用View和他的实现类表示视图 ​ InternalResourceView：视图类， 表示jsp文件，视图解析器会创建InternalResourceView类对象 5.DispatcherServlet把4步骤中创建的View对象获取到，调用View类自己的方法，把Model数据放入到requesst作用域 图解： ​ 8. 表单标签表单标签： ​ 自定义标签：el、jstl ​ Spring EL： 1.支持各种类型的请求方式（查询doGet, 增加doPost, 删除doDelete，修改doPut） （1）编写method=&quot;put|delete&quot; (2) 过滤器：为了让 浏览器能够支持put和delete请求 get post put delete -&gt;过滤器 HiddenHttpMethodFilter HiddenHttpMethodFilter会将全部请求 名为 “_method“ 的隐藏域 进行 put | delete 处理 如果使用的是SpringMVC标签： method=&quot;put | delete&quot; 如果不是SpringMVC标签：是传统的html标签： method=&quot;post&quot; 1&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put | delete&quot;&gt; 123456789101112131415161718&lt;form:form action=&quot;controller/testMethod&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查看&quot;&gt;&lt;/form:form&gt;&lt;form:form action=&quot;controller/testMethod&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;增加&quot;&gt;&lt;/form:form&gt;&lt;form:form action=&quot;controller/testMethod&quot; method=&quot;delete&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;删除&quot;&gt;&lt;/form:form&gt;&lt;form:form action=&quot;controller/testMethod&quot; method=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;&lt;/form:form&gt; 优点：省略步骤：隐藏域 可参考原生态的RESTful风格 2.可以将对象和 表单绑定起来 SpringMVC项目： 1231. 环境搭建：2. 引入标签库：&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;3. 使用 input： 12345&lt;form:form&gt; 姓名：&lt;form:input path=&quot;stuName&quot;/&gt;&lt;br/&gt; 年龄：&lt;form:input path=&quot;stuAge&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form:form&gt; 1.默认实例化bean标签的id值为command，map.put的k值必须为command 2.自定义，modelAttribute=&quot;person&quot;，通过form中该属性可以指定map.put的k值 3.path：绑定中对象的属性值 控制器： 123456789101112131415161718192021@Controller@RequestMapping(value = &quot;/controller&quot;)public class MyController &#123; @Resource(name = &quot;studentServiceImpl&quot;) IStudentService studentService; public IStudentService getStudentService() &#123; return studentService; &#125; @RequestMapping(value = &quot;/testFormTag&quot;) public String testFormTag(Map&lt;String, Object&gt; map)&#123; Student student = studentService.queryStudentByStuNo(1); map.put(&quot;command&quot;,student); return &quot;success&quot;; &#125;&#125; mapper: 123&lt;select id=&quot;selectStudents&quot; resultType=&quot;student&quot;&gt; select stuno,stuname,stuage from student&lt;/select&gt; entity： 1234public class Student &#123; private Integer stuNo; private String stuName; private Integer stuAge; checkbox和checkboxes： checkbox： ​ 自动绑定request域中的值 ​ a.通过boolean值绑定 1234&lt;form:form modelAttribute=&quot;stu&quot;&gt; &lt;form:checkbox path=&quot;stuSex&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form:form&gt; 123456789@RequestMapping(value = &quot;testCheckBox&quot;)public String testCheckBox(Map&lt;String,Object&gt; map)&#123; Student student = new Student(); student.setStuSex(true); map.put(&quot;stu&quot;,student); return &quot;success&quot;;&#125; b.绑定 集合（List、Set）、数组的中枢 checkboxes：多个checkbox的组合 path：选中的选项 items：所有的选项 123456&lt;form:form modelAttribute=&quot;stu&quot;&gt; &lt;form:checkbox path=&quot;hobbies&quot; value=&quot;basketball&quot;/&gt; &lt;form:checkbox path=&quot;hobbies&quot; value=&quot;football&quot;/&gt; &lt;form:checkbox path=&quot;hobbies&quot; value=&quot;pingpong&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form:form&gt; 12345678910111213@RequestMapping(value = &quot;testCheckBoxes&quot;)public String testCheckBoxes(Map&lt;String, Object&gt; map)&#123; Student student = new Student(); List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;football&quot;); hobbies.add(&quot;basketball&quot;); student.setHobbies(hobbies); map.put(&quot;stu&quot;,student); return &quot;success&quot;;&#125; 等价于： 1234&lt;form:form modelAttribute=&quot;stu&quot;&gt; &lt;form:checkboxes path=&quot;hobbies&quot; items=&quot;$&#123;allHobbies&#125;&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form:form&gt; 12345678910111213141516171819202122232425262728@RequestMapping(value = &quot;testCheckBoxes&quot;)public String testCheckBoxes(Map&lt;String, Object&gt; map)&#123; Student student = new Student(); //选中选项 List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;football&quot;); hobbies.add(&quot;basketball&quot;); hobbies.add(&quot;pingpong&quot;); //全部选项 /* List&lt;String&gt; allHobbies = new ArrayList&lt;&gt;(); allHobbies.add(&quot;football&quot;); allHobbies.add(&quot;basketball&quot;); allHobbies.add(&quot;pingpong&quot;); allHobbies.add(&quot;d&quot;);*/ Map&lt;String, String&gt; allHobbies = new HashMap&lt;&gt;(); allHobbies.put(&quot;football&quot;,&quot;足球&quot;); allHobbies.put(&quot;basketball&quot;,&quot;篮球&quot;); allHobbies.put(&quot;pingpong&quot;,&quot;乒乓球&quot;); allHobbies.put(&quot;d&quot;,&quot;其他&quot;); student.setHobbies(hobbies); map.put(&quot;stu&quot;,student); map.put(&quot;allHobbies&quot;,allHobbies); return &quot;success&quot;;&#125; radiobuttons： 同理 select: 方式一： 1&lt;form select path=&quot;默认的值&quot; items=&quot;所有的可选项&quot;&gt; 方式二： 12345&lt;form:select path=&quot;默认的值&quot;&gt; &lt;form:option value=&quot;football&quot; 足球&gt;&lt;/form:option&gt; &lt;form:option value=&quot;basketball&quot;&gt;&lt;/form:option&gt; &lt;form:option value=&quot;pingpong&quot;&gt;&lt;/form:option&gt;&lt;/form:select&gt; 方式三： 123&lt;form:select path=&quot;默认的值&quot;&gt; &lt;form:options items=&quot;$&#123;allBallMap&#125;&quot;&gt;&lt;/form:options&gt;&lt;/form:select&gt; 总结： 如果方式二、方式三同时存在，则使用方式二 如果方式一、方式二同时存在，则使用方式一 原生态优先级高于框架，而且最原生态的&lt;option&gt;没有绑定的功能 c.（了解）嵌套对象的toString()的返回值 12345678public class Student &#123; private Integer stuNo; private String stuName; private Integer stuAge; private boolean stuSex; private Other other;&#125; 123456public class Other &#123; @Override public String toString()&#123; return &quot;pingpong&quot;; &#125;&#125; 123456&lt;form:form modelAttribute=&quot;stu&quot;&gt; &lt;%--&lt;form:checkbox path=&quot;other&quot; value=&quot;basketball&quot;/&gt; &lt;form:checkbox path=&quot;other&quot; value=&quot;football&quot;/&gt; &lt;form:checkbox path=&quot;other&quot; value=&quot;pingpong&quot;/&gt;--%&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form:form&gt; 12345678910@RequestMapping(value = &quot;testCheckBoxes&quot;)public String testCheckBoxes(Map&lt;String, Object&gt; map)&#123; Student student = new Student(); Other other = new Other(); student.setOther(other); map.put(&quot;stu&quot;,student); return &quot;success&quot;;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://fyupeng.github.io/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://fyupeng.github.io/tags/Spring/"},{"name":"MVC","slug":"MVC","permalink":"http://fyupeng.github.io/tags/MVC/"}],"author":"fyupeng"},{"title":"Spring","slug":"Spring","date":"2022-07-01T12:13:06.000Z","updated":"2022-07-01T12:16:24.056Z","comments":true,"path":"2022/07/01/Spring/","link":"","permalink":"http://fyupeng.github.io/2022/07/01/Spring/","excerpt":"","text":"1. 解耦合发展史、控制反转、依赖注入1.1 开发Spring程序（IOC）123ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;) //执行从springIOC容器中获取一个 id 为student的对象 Student student = （Student）context.getBean(&quot;student&quot;); 可以发现，springioc容器 帮我们 new 了对象，并且给对象赋了值 1.2 SpringIOC发展史1.2.1 new对象12Student student = new Student();student.setXxx(); 1.2.2 简单工厂12MyFactory myFactory = new MyFactory();myFactory.learn(String name); 123456789101112public class CourseFactory &#123; public static ICourse getCourse(String name) &#123; //获取ioc容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); if(name.equals(&quot;java&quot;)) &#123; return (ICourse) context.getBean(&quot;javaCourse&quot;); &#125;else &#123; return (ICourse) context.getBean(&quot;HtmlCourse&quot;); &#125; &#125;&#125; 1.2.3 ioc（超级工厂） 先配置applicationContext.xnl文件中的&lt;bean&gt;标签中的student、javaCourse、`htmlCourse`` ``student`类中添加方法： 123456public void learn(String name) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ICourse course = (ICourse) context.getBean(name); course.learn();&#125; test测试类中添加方法后调用： 12345678public static void learnCourseWithIoc() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); student.learn(&quot;javaCourse&quot;);&#125;public static void main(String[] args) &#123; learnCourseWithIoc(); &#125; 1.3 IOC也可以称为DI(依赖注入)控制反转：将 创建对象、属性值 的方式 进行了 翻转，从new、setXxx() 翻转为了 从springIOC容器 getBean()依赖注入：将属性值注入给了属性，将属性注入给了bean,将bean注入给了ioc容器; 总结：ioc/di, 无论要什么对象， 都可以去springioc容器中获取， 而不需要自己操作（new/setXxx()） 2. 三种方式的依赖注入IOC容器赋值： 简单类型：8个基本+String value：如果是对象类型 ref：“需要引用的id值” 因此实现了 对象与对象之间的 依赖关系 1context.getBean(需要获取的bean的id值) 2.1.1 .set注入：通过setXxx()赋值赋值，默认使用的是set()方法； 依赖注入底层是通过反射实现对的。 2.2.2 构造器注入：通过构造方法赋值1&lt;constructor-arg value=&quot;ls&quot; type=&quot;String&quot; name=&quot;name&quot; &gt;&lt;/constructor-arg&gt; 需要注意：如果&lt;constructor-arg&gt; 的顺序 与构造方法参数的顺序不一致，则需要通过type或者index或name指定 2.2.3 p命名空间的注入引入命名空间 123&lt;beans xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&gt;&lt;/beans&gt; 简单类型：p:属性名=“属性值” 引用类型（除了String外)：p：属性名-ref=”引用的id” 注意多个 p 赋值的时候 要有空格。 注意：无论是String还是in/short/long, 在赋值时都是 value=&quot;值&quot; 因此建议此种情况 需要配合name\\type进行区分 3. 集合和特殊类型注入3.1 集合类型注入示例： ​ 注入各种数据类型：List、Set、map、properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;bean id=&quot;collectionDemo&quot; class=&quot;org.student.entity.AllCollectionType&quot;&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;array&quot;&gt; &lt;!-- &lt;array&gt; &lt;value&gt;足球1&lt;/value&gt; &lt;value&gt;篮球1&lt;/value&gt; &lt;value&gt;乒乓球1&lt;/value&gt; &lt;/array&gt; --&gt; &lt;list&gt; &lt;value&gt;足球1&lt;/value&gt; &lt;value&gt;篮球1&lt;/value&gt; &lt;value&gt;乒乓球1&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot;&gt; &lt;!-- &lt;set&gt; &lt;value&gt;足球2&lt;/value&gt; &lt;value&gt;篮球2&lt;/value&gt; &lt;value&gt;乒乓球2&lt;/value&gt; &lt;/set&gt; --&gt; &lt;list&gt; &lt;value&gt;足球2&lt;/value&gt; &lt;value&gt;篮球2&lt;/value&gt; &lt;value&gt;乒乓球2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;foot3&lt;/value&gt; &lt;/key&gt; &lt;value&gt;足球3&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;basket3&lt;/value&gt; &lt;/key&gt; &lt;value&gt;篮球3&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;pp3&lt;/value&gt; &lt;/key&gt; &lt;value&gt;乒乓球3&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;props&quot;&gt; &lt;props&gt; &lt;prop key=&quot;foot4&quot;&gt;足球4&lt;/prop&gt; &lt;prop key=&quot;basket4&quot;&gt;篮球4&lt;/prop&gt; &lt;prop key=&quot;pp4&quot;&gt;乒乓球4&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 被注入的对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.student.entity;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class AllCollectionType &#123; private List&lt;String&gt; list; private String[] array; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties props; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public String[] getArray() &#123; return array; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; public Set&lt;String&gt; getSet() &#123; return set; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public Map&lt;String, String&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public Properties getProps() &#123; return props; &#125; public void setProps(Properties props) &#123; this.props = props; &#125; @Override public String toString() &#123; String strContent = &quot;&quot;; for(String str : array) &#123; strContent += str + &quot;,&quot;; &#125; return &quot;list:&quot; + this.list + &quot;set:&quot; + this.set + &quot;map:&quot; + this.map + &quot;pros:&quot; + this.props + &quot;array:&quot; + strContent; &#125;&#125; 3.2 特殊值的注入 给对象类型赋值 null 123&lt;property name=&quot;name&quot;&gt; &lt;null/&gt; &lt;!-- 注意没有&lt;value&gt; --&gt;&lt;/property&gt; 赋空值 “” 123&lt;property name=&quot;name&quot;&gt; &lt;value&gt;&lt;/value&gt;&lt;/property&gt; 注意： 在ioc中定义bean的前提：该bean的 类 必须提供了 无参构造 4. 自动装配只适用于 ref类型，约定由于配置 自动配置： 123456789101112131415&lt;bean id=&quot;course&quot; class=&quot;org.student.entity.Course&quot; autowire=&quot;constructor&quot;&gt; &lt;!-- &lt;bean id=&quot;course&quot; class=&quot;org.student.entity.Course&quot; p:courseName=&quot;hadoop&quot; p:courseHour=&quot;300&quot; p:teacher-ref=&quot;teacher&quot;&gt; --&gt; &lt;!-- 通过set方式赋值 --&gt; &lt;property name=&quot;courseName&quot; value=&quot;java&quot;&gt;&lt;/property&gt; &lt;property name=&quot;courseHour&quot; value=&quot;200&quot;&gt;&lt;/property&gt; &lt;!-- &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;&gt;&lt;/property&gt; --&gt;&lt;/bean&gt;&lt;bean id=&quot;teacher&quot; class=&quot;org.student.entity.Teacher&quot;&gt; &lt;!-- 通过set方式赋值 --&gt; &lt;property name=&quot;name&quot; value=&quot;zs&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;&lt;/bean&gt; byName：自动寻找其他bean的id值 = 该Course类的属性名 byName本质是byId 1&lt;bean class=&quot;org.student.entity.Course&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt; byType：其他bean的类型class是否与该Course类的ref属性类型一致 注意：此种方法必须满足当前IOC容器中， 只能有一个bean满足条件 constructor：其他bena的类型（class）是否与 该course类的构造方法参数的类型一致，此种方式的本质就是byType 可以在头文件中一次性将ioc容器中的所有bean统一设置成自动装配： 123&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; default-autowire=&quot;default&quot; &gt;&lt;/beans&gt; 自动装配虽然可以减少代码量，但是会降低程序的可读性，使用时需要谨慎。 5. 使用注解声明式事务使用注解定义bean：通过注解的形式将bean以及相应的属性值放入ioc容器 12&lt;context:component-scan base-package=&quot;org.student.dao&quot;&gt;&lt;/context:component-scan&gt; spring在启动的时候，会根据base-package在 该包中扫描所有类，查找这些类是否有标明注解，有注解就将它注入ioc容器中 头文件： 123&lt;beans xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt; @Componment细化： dao层注解：@Respository service层注解：@Service 控制器层注解：@Controller 使用注解实现事务（声明是事务） 目标：通过事务使以下方法 要么全成功，要么全失败 12345public void addStudent() &#123; //增加班级 //增加学 //crud&#125; 5.1 jar包123456spring-tx-4.3.9.RELEASE.jarojdbc.jarcommons-dbcp.jar # 连接池使用的数据源commons-pool.jar # 连接池spring-jdbc-4.3.9.RELEASE.jaraopalliance.jar 5.2 配置jdbc\\mybatis\\spring 增加事务命名空间 123&lt;beans xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt; 增加对事务的支持：依赖&lt;bean id=&quot;txManager&quot;/&gt; 12&lt;!-- 增加对事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; 配置事务管理器txManager依赖的jar包：spring-jdbc-4.3.9.RELEASE.jar 依赖&lt;bean id=&quot;dataSource&quot;/&gt; 1234&lt;!-- 配置事务管理器txManager --&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 配置数据库相关事务：依赖jar包（commons-dbcp.jar 连接池使用的数据源） 123456789&lt;!-- 配置数据库相关事务 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.OracleDriver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin@127.0.0.1:1521:ORCL&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;scott&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;tiger&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;6&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 5.3 使用将需要成为事务的方法前增加注解 1@Transactional(readOnly = false, propagation = Propagation.REQUIRED) 6. AOP 面向切面编程一个普通的类 -&gt; 有特定功能的类 继承 实现 注解 配置 12public class MyFilter extends/implements Xx &#123;&#125; 6.1 前置通知需要头文件 123&lt;beans xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; jar 包 12aopaliance.jaraspectjweaver.jar 配置 配置addStudent()方法和前置通知类的bean 123456789&lt;!-- addStudent()所在方法 --&gt;&lt;bean id=&quot;studentService&quot; class=&quot;org.student.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- “前置通知”类 --&gt;&lt;!-- ========连接线的一方======== --&gt;&lt;bean id=&quot;logBefore&quot; class=&quot;org.student.aop.LogBefore&quot;&gt;&lt;/bean&gt; 将addStudent()方法和前置通知类关联 1234567&lt;!-- 将addStudent()和 通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点 （在哪里执行通知） --&gt; &lt;!-- ========连接线的另一方======== --&gt; &lt;aop:pointcut expression=&quot;execution(public void org.student.service.impl.StudentServiceImpl.deleteStudent(int)) or execution(public void org.student.service.impl.StudentServiceImpl.addStudent(org.student.entity.Student))&quot; id=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logBefore&quot; pointcut-ref=&quot;pointcut&quot;/&gt;&lt;/aop:config&gt; 编写 aop：每当执行add()之前自动执行一个方法log() add()：业务方法 log()：自动执行的通知，即aop前置通知 12345public class Xxx&#123; //@Test //a()&#123;&#125;&#125; 如果出现异常：类似java.lang.NoClassDefFoundError：org/apach....则说明缺少jar类 6.2 后置通知 通知类：普通实现接口 业务类、业务方法：StudentServiceImpl中的addStudent() 配置： 将业务类、通知 纳入springIOC容器 定义切入点（一端）、定义通知类（另一端），通过pointcut-ref将两端连接起来 配置addStudent()方法和 后置通知类的bean 1234567&lt;!-- addStudent()所在方法 --&gt;&lt;bean id=&quot;studentService&quot; class=&quot;org.student.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;bean id=&quot;logAfter&quot; class=&quot;org.student.aop.LogAfter&quot;&gt;&lt;/bean&gt; 将addStudent（）方法和 前置通知类关联 1234567&lt;!-- 将addStudent()和 通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 切入点（连接线的一端）：业务类的具体方法 --&gt; &lt;aop:pointcut expression=&quot;execution(public * org.student.service.impl.StudentServiceImpl.addStudent(..))&quot; id=&quot;pointcut2&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logAfter&quot; pointcut-ref=&quot;pointcut2&quot;/&gt;&lt;/aop:config&gt; 6.3 异常通知根据异常通知接口的定义可以发现，异常通知的实现类必须编写以下方法： 12void afterThrowing(Mehthod, args, target, ThrowableSubclass)void afterThrowing(ThrowableSubclass) 配置addStudent()方法和后置通知类的bean 123456&lt;!-- addStudent()所在方法 --&gt;&lt;bean id=&quot;studentService&quot; class=&quot;org.student.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;bean id=&quot;logException&quot; class=&quot;org.student.aop.LogException&quot;&gt;&lt;/bean&gt; 将addStudent()方法和后置通知类关联 123456&lt;!-- 将addStudent()和 通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 切入点（连接线的一端）：业务类的具体方法 --&gt; &lt;aop:pointcut expression=&quot;execution(public * org.student.service.impl.StudentServiceImpl.addStudent(..))&quot; id=&quot;pointcut3&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logException&quot; pointcut-ref=&quot;pointcut3&quot;/&gt;&lt;/aop:config&gt; 6.4 环绕通知在目标方法的前后、异常发生时、最终等各个地方都可以进行的通知，最强大的一个通知； 可以获取目标方法的全部控制权（目标方法是否执行、执行之前、执行之后、参数、返回值等） 在使用环绕通知时，目标方法的一切信息都可以通过invocation参数获取的 配置addStudent()方法和后置通知类的bean 123456&lt;!-- addStudent()所在方法 --&gt;&lt;bean id=&quot;studentService&quot; class=&quot;org.student.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;bean id=&quot;logAround&quot; class=&quot;org.student.aop.LogAround&quot;&gt;&lt;/bean&gt; 将2.将addStudent()方法和前置通知类关联 123456&lt;!-- 将addStudent()和 通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 切入点（连接线的一端）：业务类的具体方法 --&gt; &lt;aop:pointcut expression=&quot;execution(public * org.student.service.impl.StudentServiceImpl.addStudent(..))&quot; id=&quot;pointcut4&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logAround&quot; pointcut-ref=&quot;pointcut4&quot;/&gt;&lt;/aop:config&gt; 7. 基于注解形式的AOP实现使用注解实现通知aop jar包 与实现接口 的方式相同 配置 将业务类、通知纳入springIOC容器 开启注解AOP的支持 1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 业务类addStudent – 通知 编写 123@Aspect //声明该类 是一个 通知public class LogBeforeAnnotation &#123;&#125; 注意：通过注解形式将对象增加到ioc容器时，需要设置扫描器 1&lt;context:component-scan base-package=&quot;org.student.aop&quot;&gt;&lt;/context:component-scan&gt; 扫描器会将指定的包中的@Componet、@Service、@Responsitory、@Controller修饰的类产生的对象增加到 ioc 容器中 @Aspect 不需要加入扫描器，只需要开启即可： 1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 通过注解形式 实现的aop，如果想获取目标对象的一些参数，则需要使用一个对象：JoinPoint 声明返回值的参数名：参数名变量不能随便写，要写成 returningValue 注解形式实现aop时，通知的方法的参数不能多、少 7.1 前置通知12345//前置通知@Before(&quot;execution(public * addStudent(..))&quot;)public void myBefore(JoinPoint jp) &#123; System.out.println(&quot;《注解形式：前置通知》:目标对象：&quot; + jp.getTarget() + &quot;,方法名：&quot; + jp.getSignature() + &quot;,参数列表：&quot; + Arrays.toString(jp.getArgs()));&#125; 7.2 后置通知12345//后置通知@AfterReturning( pointcut = &quot;execution(public * addStudent(..))&quot;, returning = &quot;returningValue&quot; )public void myAfter(JoinPoint jp, Object returningValue) &#123; System.out.println(&quot;《注解形式：后置通知》:目标对象：&quot; + jp.getTarget() + &quot;,方法名：&quot; + jp.getSignature() + &quot;,参数列表：&quot; + Arrays.toString(jp.getArgs()) + &quot;,返回值:&quot; + returningValue);&#125; 7.3 环绕通知123456789101112131415161718//环绕通知@Around(&quot;execution(public * addStudent(..))&quot;)public void myAround(ProceedingJoinPoint jp) &#123; //方法执行之前 System.out.println(&quot;《注解形式：环绕通知：方法执行之前》&quot;); try &#123; //方法执行时 System.out.println(&quot;《注解形式：环绕通知：方法执行时》&quot;); jp.proceed(); //方法执行之后 System.out.println(&quot;《注解形式：环绕通知：方法执行之后》&quot;); &#125;catch(Throwable e) &#123; //发生异常时 System.out.println(&quot;《注解形式：环绕通知：发生异常时》&quot;); &#125;finally &#123; //最终通知 &#125;&#125; 7.4 异常通知12345//异常通知:如果只捕获特定类型的异常@AfterThrowing( pointcut = &quot;execution(public * addStudent(..))&quot;, throwing = &quot;e&quot; )public void myException(NullPointerException e) &#123; System.out.println(&quot;&amp;&amp;&amp;&amp;&amp;《注解形式：异常通知：》异常信息：&quot; + e.getMessage());&#125; 7.5 最终通知12345//最终通知@After(&quot;execution(public * addStudent(..))&quot;)public void myAfter(JoinPoint jp) &#123; System.out.println(&quot;《注解形式：最终通知：》&quot;);&#125; 8. 基于 Schema 形式的 AOP通过配置将 类 → 通知 基于Schema配置类似于实现接口的方式 接口方式通知：public class LogAfter implements AfterReturningAdvice Schema方式通知： 编写一个普通类public class LogAfter&#123;&#125; 将该类通过配置，转为一个”通知“ 如果要获取目标对象信息： 注解、schema：JoinPoint 接口：Method method, Object[] args, Object target 8.1 前置通知schema形式和注解形式相似，不同之处：注解形式使用了注册@After， schemal形式进行了多余配置 123public void before(JoinPoint jp) &#123; System.out.println(&quot;《Sechema形式：前置通知》:目标对象：&quot; + jp.getTarget() + &quot;,方法名：&quot; + jp.getSignature() + &quot;,参数个数：&quot; + jp.getArgs().length);&#125; 8.2 后置通知123public void afterReturning(JoinPoint jp, Object returnValue) throws Throwable &#123; System.out.println(&quot;《Sechema形式：后置通知》:目标对象：&quot; + jp.getTarget() + &quot;,方法名：&quot; + jp.getSignature() + &quot;,参数个数：&quot; + jp.getArgs().length + &quot;,返回值：&quot; + returnValue);&#125; 8.3 环绕通知1234567891011121314public Object around(ProceedingJoinPoint jp) &#123; Object result = null; try &#123; System.out.println(&quot;《Sechema形式：环绕通知》：前置通知&quot;); result = jp.proceed(); System.out.println(&quot;《Sechema形式：环绕通知》：后置通知&quot;); &#125;catch(Throwable e) &#123; System.out.println(&quot;《Sechema形式：环绕通知》：异常通知&quot;); &#125;finally &#123; System.out.println(&quot;《Sechema形式：环绕通知》：最终通知&quot;); &#125; return result;&#125; 8.4 异常通知123public void whenException(JoinPoint jp, NullPointerException e) &#123; System.out.println(&quot;《Sechema形式：异常通知》:目标对象：&quot; + jp.getTarget() + &quot;,方法名：&quot; + jp.getSignature() + &quot;,参数个数：&quot; + jp.getArgs().length +&quot;,异常信息：&quot; + e.getMessage());&#125; 8.5 最终通知123public void after(JoinPoint jp) &#123; System.out.println(&quot;《Sechema形式：最终通知》:目标对象：&quot; + jp.getTarget() + &quot;,方法名：&quot; + jp.getSignature() + &quot;,参数个数：&quot; + jp.getArgs().length);&#125; 8.6 配置对 5 种通知的统一配置 1234567891011&lt;bean id=&quot;logSchema&quot; class=&quot;org.student.aop.LogSchema&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(public * org.student.service.impl.StudentServiceImpl.addStudent(..))&quot; id=&quot;pcSchema&quot;/&gt; &lt;aop:aspect ref=&quot;logSchema&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pcSchema&quot;/&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; returning=&quot;returnValue&quot; pointcut-ref=&quot;pcSchema&quot;/&gt; &lt;aop:after-throwing method=&quot;whenException&quot; pointcut-ref=&quot;pcSchema&quot; throwing=&quot;e&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pcSchema&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 9. Spring 开发 Web 项目Spring开发Web项目及拆分Spring配置文件 Web项目如何初始化SpringIOC容器：思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次 因此用spring开发web项目 至少需要7个jar：spring-java的6个jar + spring-web.jar， 注意： web项目的jar包 是存在WEB-INF/lib中 配置 web.xml 文件 核心代码： 12345678910111213&lt;!-- 容器默认约束时，不用配置位置--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化IOC容器， 初始化IOC容器（applicationContext.xml）,必须告诉监听器 此容器的位置。通过context-param 默认约束的位置：WEB-INF/applicationContext.xml --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 完整 web.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;SpringWebProject&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化IOC容器，初始化IOC容器（applicationContext.xml）,必须告诉监听器 此容器的位置。通过context-param--&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 10. 拆分Spring 配置文件10.1 java项目 applicationContext1.xml applicationContext2.xml applicationContext3.xml 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 10.2 Web项目根据什么拆分？ i.三层结构 UI(html/css/jsp、Servlet) applicationController.xml Service：applicationService.xml Dao：applicationDao.xml 公共 数据库：applicationDB.xml ii.功能结构 学生相关配置：applicationContextStudent.xml &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt; 班级相关配置：applicationContextClass.xml 合并：如何将多个配置文件加载 在web中配置 三种方法： 12345678910&lt;!--第一种：--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml &lt;/param-value&gt;&lt;/context-param&gt; 12345678&lt;!--第二种：--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml &lt;/param-value&gt;&lt;/context-param&gt; 1234567&lt;!--第三种：--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt; 123456&lt;!--在第一个文件中配置--&gt;&lt;beans&gt; &lt;import resource=&quot;applicationContext-Dao.xml&quot;/&gt; &lt;import resource=&quot;applicationContext-Service.xml&quot;/&gt; &lt;import resource=&quot;applicationContext-Controller.xml&quot;/&gt;&lt;/beans&gt; 10.3 结构 11. Servlet 容器与 IOC 容器核心代码： 1234/*通过servlet获取ioc容器*/ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); /*获取studentService的bean*/studentService = (IStudentService) context.getBean(&quot;studentService&quot;); servlet的init()函数在触发链接或访问servlet时才执行，执行完才执行method函数（doGet或doPost） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package org.student.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.WebApplicationContextUtils;import org.student.service.IStudentService;import org.student.service.impl.StudentServiceImpl;/** * Servlet implementation class queryStudentByIdServlet */@WebServlet(&quot;/queryStudentByIdServlet&quot;)public class queryStudentByIdServlet extends HttpServlet &#123; IStudentService studentService; public void setStudentService(IStudentService studentService) &#123; this.studentService = studentService; &#125; @Override public void init() throws ServletException &#123; //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-Service.xml&quot;); ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); studentService = (IStudentService) context.getBean(&quot;studentService&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = studentService.queryStudentById(); // ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); request.setAttribute(&quot;name&quot;, name); request.getRequestDispatcher(&quot;result.jsp&quot;).forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 12. 注解形式的依赖注入12.1 service123456//&lt;bean id=&quot;studentService&quot; class=&quot;org.student.service.impl.StudentServiceImpl&quot;&gt;@Service(&quot;studentService&quot;)public class StudentServiceImpl implements IStudentService &#123; @Autowired //自动装配，byType @Qualifier(&quot;stuDao&quot;) //byName(根据名字，两个都加) private IStudentDao studentDao; 12345678910@Service(&quot;studentService&quot;)public class StudentServiceImpl implements IStudentService &#123; &lt;!--使用resource能对名字和类型进行匹配 要求： 1.必须有tomcat的支持（一般web才使用）, 或者使用pom导入依赖javax.annotation 2.不需要写set方法来反射（xml配置的需要） --&gt; @Resource(name = &quot;stuDao&quot;) private IStudentDao studentDao; 12.2 dao123//&lt;bean id=&quot;studentDao&quot; class=&quot;org.student.dao.impl.StudentDaoImpl&quot;/&gt;@Repository(&quot;studentDao&quot;)public class StudentDaoImpl implements IStudentDao&#123; 12.3 servlet1234//&lt;bean id=&quot;studentServlet&quot; class=&quot;org.student.servlet.queryStudentByIdServlet&quot;/&gt;@Controller(&quot;studentServlet&quot;)@WebServlet(&quot;/queryStudentByIdServlet&quot;)public class queryStudentByIdServlet extends HttpServlet &#123; 13. Spring 整合 MyBatis 以及 SqlSessionDaoSupport 整合方式Spring - MyBatis 13.1 思路SqlSessionFactory → SqlSession → StudentMapper → CRUD 可以发现， MyBatis 最终是通过SqlSessionFactory来操作数据库， Spring整合MyBatis其实就是 将 MyBatis的SqlSessionFactory交给Spring SM整合步骤： jar包 mybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jar spring-context-support.jar spring-core.jar spring-context.jar spring-beanss.jar spring-aop.jar spring-web.jar commons-logging.jar commons.dbcp.jar ojdbc.jar mybatis.jar log4.jar commons-pool.jar 类-表 MyBatis配置文件conf.xml 通过mapper.xml将 类、表建立映射关系 之前使用MyBatis.xml → SqlSessionFactory 现在整合的时候，需要通过Spring管理SqlSessionFactory，因此 产生SqlSessionFactory所需要的的数据库 信息不再放入conf.xml，而需要放入spring配置文件中 配置spring配置文件（applicationContext.xml） 使用Spring-MyBatis整合产物开发程序 13.2 目标通过spring产生mybatis最终操作需要的 动态mapper对象（Student） 需要先配置applicationContext依赖注入bean dao不需要session的commit和close操作，自动提交 123456@Overridepublic void addStudent(Student student) &#123; SqlSession session = super.getSqlSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudent(student);&#125; service1234@Overridepublic void addStudent(Student student) &#123; studentMapper.addStudent(student);&#125; test1234567891011public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); IStudentService studentService = (IStudentService) context.getBean(&quot;studentService&quot;); Student student = new Student(); student.setStuNo(3); student.setStuName(&quot;zds&quot;); student.setStuAge(33); studentService.addStudent(student);&#125; 13.3 图解 13.4 spring 配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;config&quot; class=&quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 上述方法现在提倡使用下面的写法 1.要求：mapper文件名和 dao接口名必须完全一样，包括大小写 2.mapper和接口必须在同一目录 --&gt; &lt;bean id=&quot;studentService&quot; class=&quot;org.student.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentMapper&quot; ref=&quot;studentMapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;studentMapper&quot; class=&quot;org.student.dao.impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 加载mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf.xml&quot;&gt;&lt;/property&gt; &lt;!-- 加载mapper.xml路径 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;org/student/mapper/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 13.5 Spring产生 动态mapper对象 有3种方法第一种方法 - SqlSessionDaoSupportDao层实现类 继承 SqlSessionDaoSupport类 sqlSessionDaoSupport类提供了一个属性 SqlSession 1234&lt;!-- 第一种方式生成mapper对象 --&gt;&lt;bean id=&quot;studentMapper&quot; class=&quot;org.student.dao.impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt; sqlSession工厂bean 12345&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 加载mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 数据源bean 12345678&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第二种方式 - MapperFactoryBean省略掉 第一种方式的 实现类 直接使用MyBatis提供的 Mapper实现类：org.mybatis.spring.mapper.MapperFactoryBean 缺点：每一个mapper都需要一个 12345&lt;!-- 第二种方式生成mapper对象 --&gt;&lt;bean id=&quot;studentMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;org.student.mapper.StudentMapper&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt; sqlSession工厂bean 123456&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 加载mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 数据源bean 12345678&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第三种方式 - MapperScannerConfigured批量配置实现类 12345&lt;!-- 第三种方式生成mapper对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.student.mapper&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt; sqlSession工厂bean 123456&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 加载mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 数据源bean 12345678&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 注意： 第二种和第三种方式中： 第二种的sqlSession工厂sqlSessionFactory为对象类型，属性值用引用ref 第三种的sqlSession工厂sqlSessionFactoryBeanName是String类型，属性值用value web 配置文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;SpringWebProject&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- classpath:applicationContext.xml,--&gt; classpath:applicationContext-*.xml &lt;!-- classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml--&gt; &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化IOC容器， 初始化IOC容器（applicationContext.xml）,必须告诉监听器 此容器的位置。通过context-param --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; ​ ​","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://fyupeng.github.io/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://fyupeng.github.io/tags/Spring/"}],"author":"fyupeng"},{"title":"MongoDB","slug":"MongoDB","date":"2022-06-25T07:50:51.000Z","updated":"2022-06-25T07:54:19.810Z","comments":true,"path":"2022/06/25/MongoDB/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/MongoDB/","excerpt":"","text":"一、简介简介：MongoDB是一种NOSQL（Not Only Sql）数据库 数据表 -&gt;JDBC读取-&gt;POJO（VO、PO）-&gt;控制层转化为JSON数据-&gt;客户端 No 关系型数据库 非关系型数据库 1 数据库 数据库（类似于MySQL） 2 表 集合 3 行 文档 4 列 成员 5 主键 Object ID（自动维护） 在整个行业之中，MongoDB数据库是发展最好的一个NoSQL数据库，因为它与Node.JS捆绑在一起了，也就是如果你要从事Node.JS开发，那么一定要使用MongDB，而Node.JS（基于javaScript）在国内最成功的应用 –taobao MongoDB之所以能够更好的发展也取决于：面向集合的存储过程、模式自由（无模式）、方便的进行数据的存储扩充、 支持索引、支持短暂数据保留、具有完整的数据状态监控、基于BSON应用 业务应用场景：High performace - 对数据库并发读写的需求 Huge Storage - 对海量数据的高效率存储和访问的需求 High Scalablity &amp;&amp; High Avaliablity - 对数据库的高扩展性和高可用性的需求 二、安装与配置下载 windows进入bin目录打开cmd配置db： 先创建data/db目录存放数据，再手动命令行配置： 1monogd --dbpath ..\\data\\db 或 b编写/config/mongod.conf 12#The directoy where the mongod instance stores its data.Default Value is &quot;\\data\\db&quot; on windows.dbpath=D:\\study\\software\\MongoDB\\MongoDB-4.2.15\\data\\db 第一种： 1mongod -f ../config/mongd.conf 第二种： 1mongod --config ../config/mongod.conf Linux创建data和log目录，配置指定该db目录和log日志文件路径 配置/usr/local/mongodb/single/mongod.conf 12345678910111213141516171819systemLog: destination: file path: &quot;/usr/local/mongodb-4.2.15/single/log/mongod.log&quot; logAppend: truestorage: dbPath: &quot;/usr/local/mongodb-4.2.15/single/data/db&quot; journal: enabled: trueprocessManagement: fork: truenet: bindIp: localhost,172.30.77.41 port: 27017 配置完成后启动： 1mongodb-4.2.15]# bin/mongod -f ./single/mongod.conf 提示： 12forked process: 208809child process started successfully, parent exiting 登录数据库 1/bin/mongo 三、数据库的创建与删除创建： 1use articledb 删除： 1db.dropDatabase() 查看当前数据库 1db 四、集合操作查看集合 1show collections 五、文档操作插入：插入单个文档 1db.comment.insert(&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;status&quot;:null&#125;) 插入多条文档 1234567db.comment.insertMany([&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;status&quot;:null&#125;,]) 还可以使用 1234567891011try&#123;db.comment.insertMany([&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;status&quot;:null&#125;,&#123;&quot;article&quot;:&quot;10000&quot;,&quot;content&quot;:&quot;今天天气真好&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;status&quot;:null&#125;,]);&#125;catch(e)&#123; print(e);&#125; 查询：1db.comment.find() 代参查询满足条件，可能不止一条 带一个参数 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;) 带多个参数 1db.comment.find(&#123;article:&quot;10000&quot;&#125;,&#123;userid:&quot;1003&quot;&#125;) 查询一条 1db.comment.findOne(&#123;userid:&quot;1002&quot;&#125;) 更新：覆盖更新，json对象会更新覆盖（会失去没有修改过的json对象） 1db.comment.update(&#123;_id:ObjectId(&quot;61221f645f7003e989379e40&quot;)&#125;, &#123;status:&quot;1&quot;&#125;) 比如： 1&#123; &quot;_id&quot; : ObjectId(&quot;61221f645f7003e989379e40&quot;), &quot;article&quot; : &quot;10000&quot;, &quot;content&quot; : &quot;今天天气真好&quot;, &quot;userid&quot; : &quot;1001&quot;, &quot;status&quot; : null &#125; 结果： 1&#123; &quot;_id&quot; : ObjectId(&quot;61221f645f7003e989379e40&quot;), &quot;status&quot; : &quot;1&quot; &#125; 非覆盖更新（原json对象保持不变） 1db.comment.update(&#123;_id:ObjectId(&quot;61221f645f7003e989379e41&quot;)&#125;, &#123;$set:&#123;status:&quot;1&quot;&#125;&#125;) 比如： 1&#123; &quot;_id&quot; : ObjectId(&quot;61221f645f7003e989379e41&quot;), &quot;article&quot; : &quot;10000&quot;, &quot;content&quot; : &quot;今天天气真好&quot;, &quot;userid&quot; : &quot;1002&quot;, &quot;status&quot; : null &#125; 结果： 1&#123; &quot;_id&quot; : ObjectId(&quot;61221f645f7003e989379e41&quot;), &quot;article&quot; : &quot;10000&quot;, &quot;content&quot; : &quot;今天天气真好&quot;, &quot;userid&quot; : &quot;1002&quot;, &quot;status&quot; : &quot;1&quot; &#125; 如果查询结果有多个，想把它们都修改了，参数后面跟上一个json对象 {multi: true} ，表明全部修改，默认只修改第一条 根据id自增字段 1db.comment.update(&#123;_id:&quot;612376cde9acd86e0584f8cd&quot;&#125;,&#123;$inc:&#123;likenum:NumberInt(1)&#125;&#125;) 删除：查询到满足条件的都删除 1db.comment.remove(&#123;userid:&quot;1002&quot;&#125;) 六、文档分页查询统计查询：返回查询的条数 1db.comment.count() 分页列表查询：返回查询的前三条数据 1db.comment.find().limit(3) 跳过前两条数据，返回查询的三条数据 1db.comment.find().limit(3).skip(2) 排序查询：对某一成员进行排序 1.升序：{userid:1} 2.降序：{userid:-1} 单个排序 1db.comment.find().sort(&#123;userid:1&#125;) 多个排序 1db.comment.find().sort(&#123;userid:1&#125;,status:&quot;-1&quot;) 七、文档的更多查询模糊查询/正则表达式复杂查询：db,collection.find(field:/正则表达式/) 1db.comment.find(&#123;content:/天气/&#125;) 比较查询：db.集合名称.find({“field”:{$gt: value }}) //大于 db.集合名称.find({“field”:{$lt: value }}) //大于 db.集合名称.find({“field”:{$gte: value }}) //大于等于 db.集合名称.find({“field”:{$lte: value }}) //小于等于 db.集合名称.find({“field”:{$ne: value }}) //不等于 包含： db.集合名称.find({userid:{$in:[“1003”,”1004”]}}) 不包含 db.集合名称.find({userid:{$nin:[“1003”,”1004”]}}) 条件查询：and：和 12345db.集合名称.find(&#123;$and: [ &#123;likenum:&#123;$lt:NumberInt(700)&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt(2000)&#125;&#125; ] &#125;) or：或 12345db.集合名称.find(&#123;$or: [ &#123;likenum:&#123;$lt:NumberInt(700)&#125;&#125;,&#123;likenum:&#123;$gt:NumberInt(2000)&#125;&#125; ] &#125;) 八、索引管理操作创建索引:单字段： 1db.comment.createIndex(&#123;userid:1&#125;) 多字段索引： 1db.comment.createIndex(&#123;userid:1,content:-1&#125;) 获取索引：1db.comment.getIndexes() 移除索引：按照规则： 1db.comment.dropIndex(&#123;userid:1&#125;) 按照name: 1db.comment.dropIndex(&quot;userid_1_content_-1&quot;) 移除所有索引，除了默认索引 1db.comment.dropIndexes() 九、索引的使用执行计划：1db.comment.find(&#123;userid:&quot;1003&quot;&#125;).explain() 没有使用索引：集合扫描 12&quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;COLLSCAN&quot;, 使用索引：索引扫描、再从集合抓取 1234&quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;FETCH&quot;, &quot;inputStage&quot; : &#123; &quot;stage&quot; : &quot;IXSCAN&quot;, 涵盖的查询：不去集合查询，而直接查询索引返回，数据从索引拿到 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,_id:0&#125;) 十、findBy属性字段分页查询继承接口findBy属性方法，从而调用框架方法查询分页 dao接口：123public interface CommentRepository extends MongoRepository&lt;Comment, String&gt; &#123; Page&lt;Comment&gt; findByParentid(String parentid, Pageable pageable);&#125; service实现：1234@Override public Page&lt;Comment&gt; findCommentByParentid(String parentid, int page, int size) &#123; return commentRepository.findByParentid(parentid, PageRequest.of(page, size)); &#125; page的索引从0开始，size是页面大小123456@Testpublic void testFindCommentByParentid()&#123; Page&lt;Comment&gt; page = commentService.findCommentByParentid(&quot;3&quot;, 0, 3); System.out.println(page.getTotalElements()); System.out.println(page.getContent());&#125; 十一、mongoTemplate实现点赞123456789101112131415@Overridepublic void updateCommentLikenum(String id) &#123; //查询条件 Query query = Query.query(Criteria.where(&quot;_id&quot;).is(id)); System.out.println(query); //更新条件 Update update = new Update(); update.inc(&quot;likenum&quot;); UpdateResult updateResult = mongoTemplate.updateFirst(query, update, Comment.class); System.out.println(updateResult);&#125; 1234@Testpublic void testUbpdateCommentLikenum()&#123; commentService.updateCommentLikenum(&quot;612376cde9acd86e0584f8cd&quot;);&#125; 十二、副本集副本集三个角色：主要成员（Primary）：主要接收所有写操作，就是主节点。 副本成员（Replicate）：从主节点通过复制操作以维护相同的数据集，即备份数据，不可写操作，但可以读操作（需要配置），是默认的一种从节点类型。 仲裁者（Arbiter）：不保留任何数据的副本，只具有投票选举作用，当然也可以将仲裁服务器维护为副本集的一部分，即副本成员同时也可以是仲裁者，也是一种从节点类型。 副本集的创建：副本集架构目标：一主一副本一仲裁 （1）首先先做安全认证 12345openssl rand -base64 90 -out /etc/mongodb/mongodb-keyfilegroupadd mongodbuseradd -g mongodb monngodb chown -R mongodb.mongodb /etc/mongodb/mongodb-keyfile #禁止访问安全证书chmod 600 /etc/mongodb/mongodb-keyfile #只允许root用户读写，本地和其他用户无权限 主节点：12mkdir -p /usr/local/mongodb-4.2.15/replica_sets/myrs_27017/log \\ &amp;mkdir -p /usr/local/mongodb-4.2.15/replica_sets/myrs_27017/data/db 27017（mongod.conf）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#SystemLog OptionssystemLog:#MongoDB发送所有日志输出的目标指定为文件 destination: file #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径 path: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27017/log/mongod.log&quot; #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾 logAppend: true#storage Optionsstorage: #mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。 dbPath: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27017/data/db&quot; journal: #启用或禁用持久性日志以确保数据文件保持有效和可恢复。 enabled: true#processManagement OptionsprocessManagement: #启用在后台运行mongos或mongod进程的守护进程模式。 fork: true #指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID pidFilePath: &quot;/mongodb/replica_sets/myrs_27017/log/mongod.pid&quot;#net Optionsnet: #服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip #bindIpAll: true #服务实例绑定的IP bindIp: localhost,172.30.77.41 #bindIp #绑定的端口 port: 27017#安全认证security: authorization: enabled keyFile: &quot;/etc/mongodb/mongodb-keyfile&quot;#replication Optionsreplication: #副本集的名称 replSetName: myrs 启动： 1/usr/local/mongodb-4.2.15/bin/mongod -f /usr/local/mongodb-4.2.15/replica_sets/myrs_27017/mongod.conf 副本节点：12mkdir -p /usr/local/mongodb-4.2.15/replica_sets/myrs_27018/log \\ &amp;mkdir -p /usr/local/mongodb-4.2.15/replica_sets/myrs_27018/data/db 27018（mongod.conf）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#SystemLog OptionssystemLog:#MongoDB发送所有日志输出的目标指定为文件 destination: file #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径 path: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27018/log/mongod.log&quot; #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾 logAppend: true#storage Optionsstorage: #mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。 dbPath: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27018/data/db&quot; journal: #启用或禁用持久性日志以确保数据文件保持有效和可恢复。 enabled: true#processManagement OptionsprocessManagement: #启用在后台运行mongos或mongod进程的守护进程模式。 fork: true #指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID pidFilePath: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27018/log/mongod.pid&quot;#net Optionsnet: #服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip #bindIpAll: true #服务实例绑定的IP bindIp: localhost,172.30.77.41 #bindIp #绑定的端口 port: 27018#安全认证security: authorization: enabled keyFile: &quot;/etc/mongodb/mongodb-keyfile&quot;#replication Optionsreplication: #副本集的名称 replSetName: myrs 启动： 1/usr/local/mongob-4.2.15/bin/mongod -f /usr/local/mongodb-4.2.15/replica_sets/myrs_27018/mongod.conf 仲裁节点：12mkdir -p /usr/local/mongodb-4.2.15/replica_sets/myrs_27019/log \\ &amp;mkdir -p /usr/local/mongodb-4.2.15/replica_sets/myrs_27019/data/db 27019（mongod.conf）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#SystemLog OptionssystemLog:#MongoDB发送所有日志输出的目标指定为文件 destination: file #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径 path: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27019/log/mongod.log&quot; #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾 logAppend: true#storage Optionsstorage: #mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。 dbPath: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27019/data/db&quot; journal: #启用或禁用持久性日志以确保数据文件保持有效和可恢复。 enabled: true#processManagement OptionsprocessManagement: #启用在后台运行mongos或mongod进程的守护进程模式。 fork: true #指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID pidFilePath: &quot;/usr/local/mongodb-4.2.15/replica_sets/myrs_27019/log/mongod.pid&quot;#net Optionsnet: #服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip #bindIpAll: true #服务实例绑定的IP bindIp: localhost,172.30.77.41 #bindIp #绑定的端口 port: 27019#安全认证security: authorization: enabled keyFile: &quot;/etc/mongodb/mongodb-keyfile&quot;#replication Optionsreplication: #副本集的名称 replSetName: myrs 启动： 1/usr/local/mongodb-4.2.15/bin/mongod -f /usr/local/mongodb-4.2.15/replica_sets/myrs_27019/mongod.conf 初始化副本集：客户端登录： 1./mongo --host=172.30.77.41 --port=27017 1&gt; rs.initiate() 切记，其他节点不要初始化，或者 12345678910config=&#123; _id:&#x27;mongo_rep&#x27;,members:[ &#123;_id:0, host:&#x27;192.168.163.125:27017&#x27;&#125;, &#123;_id:1, host:&#x27;192.168.163.126:27017&#x27;&#125;, &#123;_id:2, host:&#x27;192.168.163.127:27017&#x27;&#125;, &#123;_id:3, host:&#x27;192.168.163.128:27017&#x27;&#125; ]&#125;rs.initiate(config) 1rs.conf() 建立角色和账号, 用于管理副本集 12345678use admindb.createUser( &#123; user:&quot;root&quot;, pwd:&quot;root&quot;, roles:[&#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125;] &#125;) 1db.auth(&quot;root&quot;,&quot;root&quot;) #验证身份才能使用命令 1db.getUsers() 说明： “_id”：“myrs”：副本集的配置数据存储的主键值，默认就是副本集的名字 “members”：副本集成员数组，此时只有一个“host”：“172.30.77.41”，该成员不是仲裁节点：“arbiterOnly”：false，优先级（权重值）：”priority”：1 “setting”：副本集的参数配置 1rs.status() 查看节点的状态 添加副本从节点：注意添加其他节点时，要被添加的节点必须未初始化，否则将会报错Received heartbeat from member with the same，id值一样，副本集中节点之间的id值不能相同，具有唯一性，否则导致混乱，所有报错，初始化会默认为0，故不能初始化 1rs.add(&quot;172.30.77.41:27018&quot;) 添加仲裁节点：1rs.addArb(&quot;172.30.77.41:27019&quot;) 读写操作：主节点可以读写操作： 1db.comment.insert(&#123;&quot;articleid&quot;:&quot;1001&quot;,&quot;content&quot;:&quot;今天天气真好阳光明媚&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;nickname&quot;:&quot;Rose&quot;,&quot;createdatetime&quot;:&quot;new Date()&quot;&#125;) 1db.comment.find() 从节点只能读操作： 先承认是副本集中的从节点 1rs.slaveOk() 1show dbs 现在就实现了读写分离，主节点读写操作，从节点读操作 如果需要取消作为从节点的读操作： 12//缺省默认为truers.slaveOk(false) 仲裁节点不会同步数据，不能读写操作，只能选举 主节点选举原则： 主节点故障 主节点网络不可达（默认心跳10秒） 人工干预（rs.stepDown(600)） 选举规则： 票数大多数，票数相同时数据新的选举为主节点 节点优先级（权重） 十三、用户角色权限","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://fyupeng.github.io/tags/MongoDB/"},{"name":"数据库","slug":"数据库","permalink":"http://fyupeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"fyupeng"},{"title":"JDBC","slug":"JDBC","date":"2022-06-25T07:50:42.000Z","updated":"2022-06-25T07:51:55.452Z","comments":true,"path":"2022/06/25/JDBC/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/JDBC/","excerpt":"","text":"一、原理篇1.JDBC：Java DataBase Connectivity可以为多种关系型数据库DBMS 提供统一的访问形式，用Java来操作数据库 2.JDBC API 主要功能：三件事，具体时通过以下类/接口实现：DriverManager：管理jdbc驱动Connection：连接（通过DriverManager产生）Statement(PreparedStatement)：增删查改 （通过Connection产生）CallableStatement：调用数据库中的 存储过程/存储函数Result：返回的结果集（上面的Statement等产生） Connection产生操作数据库的对象：Connection产生Statement对象：createStatement（）Connection产生PreparedStatement对象：PrepareStatement（）Connection产生CallableStatement对象：prepareCall（） Statement操作数据库：增删改：executeUpdate（）查询：executeQuery（） ResultSet：保存结果集 select * from xxxnext（）：光标下移，判断是否有下一条数据；true/falseprevious（）：true/false PrepareStatement操作数据库：public interface PreparedStatement extends Statement因此增删改：executeUpdate（）查询：executeQuery（）赋值操作：setXxx（） PrepareStatement与Statement在使用时的区别：1.Statement： 12sqlexecuteUpdate（sql） 2.preparedStatement： 1234sql（可能存在占位符？）//在创建PreparedStatement 对象时，将sql预编译 prepareStatment(sql)executeUpdate()setXxx()替换占位符？ 推荐使用PreparedStatement：原因如下：（1）编码更加简便 12String name = &quot;zs&quot;; int age = 23; stmt： 12String sql = &quot;insert into student(stuno, stuname) values(&#x27;&quot; + name + &quot;&#x27;, &quot; + age +&quot;) &quot; ;stmt.executeUpdate(sql); pstmt： 12345String sql = &quot;insert into student(stuno, stuname) values(?, ?)&quot;;pstmt = connection.prepareStatement(sql);//预编译pstmt.setString(1, name);pstmt.setInt(2, age);pstmt.excuteUpdate(); （2）提高性能（因为有 预编译操作， 预编译只需执行一次）需要重复增加100条数stmt： 123String sql = &quot;insert into student(stuno, stuname) values(&#x27;&quot; + name + &quot;&#x27;, &quot; + age +&quot;) &quot; ;for(int i = 1; i &lt;= 100; i++)stmt.executeUpdate(sql); pstmt： 123456String sql = &quot;insert into student(stuno, stuname) values(?, ?)&quot;;pstmt = connection.prepareStatement(sql);//预编译pstmt.setString(1, name);pstmt.setInt(2, age);for(int i = 1; i &lt;= 100; i++)pstmt.excuteUpdate(); （3）安全（可以有效防止sql注入）sql注入：将客户端输入的内容 和 开发人员 的 SQL语句 混为一体stmt：存在被sql注入的风险；（例如输入 用户名：任意值 ‘ or 1=1 –密码：任意值）分析： 12select count(*) from login where uanme = &#x27;任意值&#x27; or 1=1 --&#x27; and upwd = &#x27;任意值&#x27;；select count(*) from login where uname = &#x27;&quot;+name+&quot;&#x27; and upwd = &#x27;&quot;+pwd+&quot;&#x27; pstmt有效防止sql注入 3.jdbc访问数据库的具体步骤：a.导入驱动，加载具体的驱动类b.与数据库建立连接c.发送sql，执行d.处理结果集(查询) 4.数据库驱动数据库名 驱动jar 具体驱动类 连接字符串 Oracle ojdbc-x.jar oracle.jdbc.OracleDriver jdbc:oracle:this:@localhost:1521:ORCL MySQL Mysql-connector-java-x.jar com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/数据库实例名 SqlServer sqljdbc-x.jar com.microsoft.sqlserver.jdbc.SQLServerDriver jdbc:sqlserver://localhost:1433;DatabaseName=mydatabase 二、操作篇1.使用JDBC连接Oracle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package exp1;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JDBCDemo &#123; private static final String URL = &quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;; private static final String USERNAME = &quot;system&quot;; private static final String PWD = &quot;FYp0103&quot;; public static void update() &#123; Connection connection = null; Statement stmt = null; try &#123; //a.导入驱动，加载具体的驱动类 Class.forName(&quot;oracle.jdbc.OracleDriver&quot;); //b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); //c.发送sql，执行（增删查改） stmt = connection.createStatement(); String sql = &quot;insert into student values(1, &#x27;zs&#x27;, 23, &#x27;s1&#x27;)&quot;; int count = stmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125; &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt !=null) stmt.close(); if(connection !=null) connection.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; update(); &#125; &#125; 2.Statement增删改、查操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//JDBC For Statementpackage exp1;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBCDemo_Statement &#123;// private static final String URL = &quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/MyDataBase&quot;; //新版的 private static final String URL = &quot;jdbc:sqlserver://localhost:1433;DatabaseName=mydatabase&quot;;//旧版的 private static final String URL = &quot;jdbc:microsoft:sqlserver:localhost:1433;database=MyDataBase&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PWD = &quot;&quot;; public static void update() &#123; Connection connection = null; Statement stmt = null; ResultSet rs = null; try &#123; //a.导入驱动，加载具体的驱动类// Class.forName(&quot;oracle.jdbc.OracleDriver&quot;); Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); //b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); //c.发送sql，执行（增删改, 查）/* //增 * stmt = connection.createStatement(); String sql = &quot;insert into student values(1, 23, &#x27;zs&#x27;, &#x27;s1&#x27;)&quot;; int count = stmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //删 stmt = connection.createStatement(); String sql = &quot;delete from student where stuno = 1&quot;; int count = stmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //改 stmt = connection.createStatement(); String sql = &quot;update student set stuname = zs5 where stuno = 1&quot;; int count = stmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //查 stmt = connection.createStatement(); String sql = &quot;select * from student&quot;; rs = stmt.executeQuery(sql);//返回值表示增删改几条数据 while(rs.next()) &#123; int Sno = rs.getInt(&quot;stuno&quot;); int Sage = rs.getInt(&quot;stuage&quot;); String Sname = rs.getString(&quot;stuname&quot;); String Sclass = rs.getString(&quot;stuclass&quot;); System.out.println(Sno + &quot;--&quot; + Sage + &quot;--&quot; + Sname + &quot;--&quot; + Sclass); &#125; */ &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(stmt !=null) stmt.close(); if(connection !=null) connection.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; update(); &#125; &#125; 3.preparedStatement增删改、查操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package exp2;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.sql.CallableStatement;import java.sql.PreparedStatement;public class JDBCDemo_prepareStatement &#123;// private static final String URL = &quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/MyDataBase&quot;;// private static final String URL = &quot;jdbc:microsofi:sqlserver:localhost:1433;database=MyDataBase&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PWD = &quot;&quot;; public static void update() &#123; Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; //a.导入驱动，加载具体的驱动类// Class.forName(&quot;oracle.jdbc.OracleDriver&quot;); Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); //b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); //c.发送sql，执行（增删查改）// String sql = &quot;insert into student values(?, ?, ?, ?)&quot;; //增 /* pstmt = connection.createStatement(); String sql = &quot;insert into student values(1, 23, &#x27;zs&#x27;, &#x27;s1&#x27;)&quot;; int count = pstmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //删 pstmt = connection.createStatement(); String sql = &quot;delete from student where stuno = 1&quot;; int count = pstmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //改 pstmt = connection.createStatement(); String sql = &quot;update student set stuname = zs5 where stuno = 1&quot;; int count = pstmt.executeUpdate(sql);//返回值表示增删改几条数据 if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*//* //查 pstmt = connection.createStatement(); String sql = &quot;select * from student&quot;; rs = pstmt.executeQuery(sql);//返回值表示增删改几条数据 while(rs.next()) &#123; int Sno = rs.getInt(&quot;stuno&quot;); int Sage = rs.getInt(&quot;stuage&quot;); String Sname = rs.getString(&quot;stuname&quot;); String Sclass = rs.getString(&quot;stuclass&quot;); System.out.println(Sno + &quot;--&quot; + Sage + &quot;--&quot; + Sname + &quot;--&quot; + Sclass); &#125;*/ /* //增 String sql = &quot;insert into student values(1, 23, &#x27;zs&#x27;, ?)&quot;; pstmt = connection.prepareStatement(sql); pstmt.setString(1, &quot;zs&quot;); int count = pstmt.executeUpdate(); if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //删 String sql = &quot;delete from student where stuno = ?&quot;; pstmt = connection.prepareStatement(sql); pstmt.setString(1, &quot;1&quot;); int count = pstmt.executeUpdate(); if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125;*/ /* //改 String sql = &quot;update student set stuname = zs5 where stuno = ?&quot;; pstmt = connection.prepareStatement(sql); pstmt.setString(1, &quot;1&quot;); int count = pstmt.executeUpdate(); if(count &gt; 0) &#123; System.out.println(&quot;操作成功！&quot;); &#125; *//* //改 String sql = &quot;select * from student where stuno = ?&quot;; pstmt = connection.prepareStatement(sql); pstmt.setString(1, &quot;1&quot;); rs = pstmt.executeQuery(); while(rs.next()) &#123; int sno = rs.getInt(&quot;stuno&quot;); int sage = rs.getInt(&quot;stuage&quot;); String sname = rs.getString(&quot;stuname&quot;); String sclass = rs.getString(&quot;stuclass&quot;); System.out.println(sno + &quot;--&quot; + sage + &quot;--&quot; + sname + &quot;--&quot; + sclass); &#125;*/ &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(pstmt !=null) pstmt.close(); if(connection !=null) connection.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; update(); &#125; &#125; 4.总结模板、八股文： a.导入驱动包、加载具体驱动类Class.forName(“具体驱动类”)； b.与数据库建立连接connection = DriverManager.getConnection(…); c.通过connection, 获取操作数据库的对象（Statement/preparedStatement/callablestatement） stmt = connection.createStatement(); d.(查询)处理结果集 123456789101112131415161718rs = pstmt.excuteQuery();while(rs.next())&#123; rs.getXxx(..);&#125;catch(ClassNotFoundExceptione)&#123;...&#125;catch(SQLException e)&#123;...&#125;catch(Exception e)&#123;...&#125;finally&#123; //打开顺序，与关闭顺序相反 if(rs != null)rs.close(); if(stmt != null)stmt.close(); if(connection != null)connection.close();&#125;--jdbc中， 除了Class.forName()抛出ClassNotFoundException, 其余方法全部抛出SQLEeception 5.JDBC调用存储过程和存储函数1.CallableStatement：调用 存储过程、存储函数 connection.prepareCall(参数：存储过程胡哦存储函数名) 参数格式： 存储过程（无返回值return, 用Out参数替代）: ​ {call 存储过程名（参数列表）} 存储函数（有返回值return）: ​ {? = call 存储函数名（参数列表）} 12345create or replace procedure addTwoNum(num1 in number, num2 in number, result out number)asbegin result := num1 + num2;end; 如果通过sql plus 访问数据库，只需要开启：OracleServiceSID 通过其他程序访问数据（sqldevelop、navicate、JDBC）,需要开启OracleServiceSID、XxxListener JDBC调用存储过程的步骤： a.产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall（“….”）; b.通过setXxx（）处理 输出参数值 cstmt.setInt（1，30）； c.通过 registerOutParameter(…)处理输出参数类型 d.cstmt.execute（）执行 e.接受 输出值 （返回值）getXxx() 调用存储函数： 12345678create or replace function addTwoNumfunction(num1 in number, num2 in number) return number as result number; begin result := num1 + num2; return result; end; JDBC调用存储函数：与存储过程的区别： 在调用时，注意参数：“{？ = call addTwoNumfunction(?, ?)}” 3.处理CLOB/BLOB类型 处理稍大型数据： a.存储路径 E:/A.txt ​ 通过JDBC存储文件路径，然后根据IO操作处理 ​ 例如：JDBC将E:/A.txt 文件 以字符串形式 “E：/A.txt”存储到数据库中 ​ 获取：1.获取该路径“E：/A.txt”2.IO b. ​ CLOB：大文本数据（小说→ 数据） ​ BLOB：二进制 clob： 存： 1.先通过pstmt的 ？ 代替小说内容 （占位符） 2.再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的 ？ 替换为小说流，注意第三个参数需要是Int类型 取： 1.通过Reader reader = rs.getCharacterStream(“NOVEL”); 将clob类型的数据 保存到 Reader 对象中 2.将Reader通过Writer输出即可。 blob：二进制 字节流 InputStream OutputStream 与CLOB步骤基本一致，区别：setBinaryStream(…) getBinaryStream(…)","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://fyupeng.github.io/tags/JDBC/"}],"author":"fyupeng"},{"title":"Oracle","slug":"Oracle","date":"2022-06-25T07:34:03.000Z","updated":"2022-06-25T07:50:08.047Z","comments":true,"path":"2022/06/25/Oracle/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/Oracle/","excerpt":"","text":"一、数据库启动状态1 状态查询 启动状态 SQL语句 结果 nomount select status from v$instance; STARTED select open_mode from v$database; ERROR at line 1:ORA-01507: database not mounted mount select status from v$instance; MOUNTED select open_mode from v$database; MOUNTED open select status from v$instance; OPEN select open_mode from v$database; READ WRITE 或者 READ ONLY 二、 表空间oracle删除表空间语句12345678910 --删除空的表空间，但是不包含物理文件drop tablespace tablespace_name;--删除非空表空间，但是不包含物理文件drop tablespace tablespace_name including contents;--删除空表空间，包含物理文件drop tablespace tablespace_name including datafiles;--删除非空表空间，包含物理文件drop tablespace tablespace_name including contents and datafiles;--如果其他表空间中的表有外键等约束关联到了本表空间中的表的字段，就要加上CASCADE CONSTRAINTSdrop tablespace tablespace_name including contents and datafiles CASCADE CONSTRAINTS;","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://fyupeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://fyupeng.github.io/tags/Oracle/"}],"author":"fyupeng"},{"title":"MySQL配置","slug":"MySQL配置","date":"2022-06-25T07:31:13.000Z","updated":"2022-06-25T07:48:58.062Z","comments":true,"path":"2022/06/25/MySQL配置/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/MySQL%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一、配置篇1.链接信息配置 5.6版本以下 jdbc.properties 1234driver=com.mysql.jdbc.Driver url=jdbc:mysql://192.168.10.102:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 username=root password=root springboot: 1234spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://192.168.10.102:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 spring.datasource.username=root spring.datasource.password=root 注意： 1.低版本的mysql对应mybatis逆向工程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--指定连接数据库的JDBC驱动包所在的位置，指定到你本机的完整路径--&gt; &lt;classPathEntry location=&quot;D:\\study\\software\\java\\jdbc\\mysql-connector-java-5.1.35.jar&quot;/&gt; &lt;!--配置table表信息内容体，targerRuntime指定采用MyBatis3的版本--&gt; &lt;context id=&quot;tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;!-- true:自动生成实体类、SQL映射文件时没有注释 --&gt; &lt;!-- false:自动生成实体类、SQL映射引进，并附有注释 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://192.168.10.102:3306/springboot&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;!-- 若为 8.0 版本以上的 mysql-connector-java 驱动，需要设置 nullCatalogMeansCurrent = true --&gt; &lt;!--&lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;--&gt; &lt;/jdbcConnection&gt; &lt;!--&lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL&quot; userId=&quot;scott&quot; password=&quot;tiger&quot;&gt; &lt;/jdbcConnection&gt;--&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.zhkucst.springboot.model&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;!-- true:对数据库的查询结果进行trim操作 --&gt; &lt;!-- false(默认)：不进行trim操作 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.zhkucst.springboot.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zhkucst.springboot.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表及对应的Java模型类名 --&gt; &lt;table tableName=&quot;t_student&quot; domainObjectName=&quot;Student&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt; &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 8.0版本以上 jdbc.properties 1234 driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://192.168.10.102:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;useJDBCComplliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTCusername=rootpassword=root springboot: 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://192.168.10.102:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;useJDBCComplliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root 注意： 1.高版本的mysql对应mybatis逆向工程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--指定连接数据库的JDBC驱动包所在的位置，指定到你本机的完整路径--&gt; &lt;classPathEntry location=&quot;D:\\study\\software\\java\\jdbc\\mysql-connector-java-8.0.25.jar&quot;/&gt; &lt;!--配置table表信息内容体，targerRuntime指定采用MyBatis3的版本--&gt; &lt;context id=&quot;tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;!-- true:自动生成实体类、SQL映射文件时没有注释 --&gt; &lt;!-- false:自动生成实体类、SQL映射引进，并附有注释 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://192.168.10.102:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;useJDBCComplliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;!-- 若为 8.0 版本以上的 mysql-connector-java 驱动，需要设置 nullCatalogMeansCurrent = true --&gt; &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt; &lt;/jdbcConnection&gt; &lt;!--&lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL&quot; userId=&quot;scott&quot; password=&quot;tiger&quot;&gt; &lt;/jdbcConnection&gt;--&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.zhkucst.springboot.model&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;!-- true:对数据库的查询结果进行trim操作 --&gt; &lt;!-- false(默认)：不进行trim操作 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.zhkucst.springboot.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zhkucst.springboot.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表及对应的Java模型类名 --&gt; &lt;table tableName=&quot;t_student&quot; domainObjectName=&quot;Student&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt; &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 二、错误解决篇1.数据库本身数据乱码mysql数据库字符集默集latin 需要手动设置成utf-8 2.调用数据库数据乱码在db.priperties中在url末尾添加 1?useUnicode=true&amp;characterEncoding=utf8 三、安装配置篇第一步：上传软件包到linux操作系统第二步：对mysql压缩包进行解压操作：tar.gz 1tar –zxf mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz 第三步：移动mysql文件夹到/usr/local目录下并更名为mysql 1mv mysql-5.6.44-linux-glibc2.12-x86_64.tar /usr/local/mysql 第四步：创建一个mysql用户并更改/usr/local/mysql目录权限（用户和组） 1useradd –r –s /sbin/nologin mysql 第五步：初始化数据库 1[root@localhost /usr/local/mysql/] # scripts/mysql_install_db --user=mysql 初始化之前需要安装autoconf库【命令：yum-y install autoconf】第六步：移除mariadb-libs库文件 1[root@localhost /usr/local/mysql/] # yum remove mariadb-libs 第七步：移动support-files目录下的mysql.server脚本到/etc/init.d目录一份=&gt;service 1[root@localhost /usr/local/mysql/] # cp support-files/mysql.server /etc/init.d/mysql 第八步：启动mysql脚本 1service mysql start 第九步：设置密码并测试mysql数据库 123bin/mysqladmin -u root password &#x27;root&#x27;;bin/mysql -uroot -pEnter Password:root 第十一步：mysql远程连接Navicate授予其他用户访问权限： 12mysql&gt; grant all privileges on . to root@&quot;%&quot; identified by &quot;root&quot;;mysql&gt; flush privileges; 第十二步：My.conf配置： 1cp /usr/local/mysql/support-files/my-default.cnf /etc/my.cnf 注释不带绿色，授予my.cnf具有644权限 1chmod 644 /etc/my.cnf 附：拒绝远程连接：回收权限： 1Mysql&gt;revoke all privileges,grant option from &#x27;root&#x27;@”%”;","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://fyupeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://fyupeng.github.io/tags/MySQL/"},{"name":"配置","slug":"配置","permalink":"http://fyupeng.github.io/tags/%E9%85%8D%E7%BD%AE/"}],"author":"fyupeng"},{"title":"Redis","slug":"Redis","date":"2022-06-25T07:26:18.000Z","updated":"2022-06-25T07:30:01.625Z","comments":true,"path":"2022/06/25/Redis/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/Redis/","excerpt":"","text":"一、NOSQLNOSQL: no only sql(不仅仅SQL) 泛指非关系型数据库 NoSQL特点： 1.方便扩展（数据之间没有关系，很好扩展） 2.大数据量高性能（Redis一秒写8万次，读取1万，NoSQL的缓存记录级，时一种细粒度的的缓存，性能会比较高） 3.数据类型时多样型的（不需要事先设计数据库，随取随用，如果时数据量十分大的表，很多人就无法设计了） 4.传统RDBMS 和 NoSQL RDBMS 结构化组织 SQL 数据和关系都存在单独的表中 数据操作，数据定义语言 严格的一致性 基础的事务 NoSQL 不仅仅是数据 没有固定的查询语言 键值对存储，列存储，文档存储，图形数据库（社交关系） 最终一致性 CAP定理和BASE（异地多活）初级架构师 高性能，高可用，高可扩 了解 3V + 3高 3V 1.海量Volume 2.多样Variety 3实时Velocity 3高 1.高可用 2.高可扩 3.高性能 二、阿里巴巴实践分析理解数据架构演进1.商品的基本信息： 名称、价格、商家信息： 关系型数据库就可以解决：MYSQL / Oracle （淘宝早年就去IOE了–王坚 –阿里云这群疯子） ​ （IOE: IBM小型机 –Oracle数据库 –EMC存储设备） 2.商品的描述、评论（文字比较多） 文档型数据库中，MongDB 3.图片 分布式文件系统 FastDFS 淘宝自己的 TFS Google的 GFS hadoop HDFS 阿里云的 oss 4.商品的关键字 （搜索） 搜素引擎 solr elasticsearch ISearch：多隆 三、NoSQL四大分类KV键值对： \\新浪：Redis 美团：Redis + Tair 阿里、百度：Redis+memcache 文档型数据库：（bson格式和json一样） MongoDB(一般必须掌握) ​ 1.MongDB是一个基于分布式文件存储的数据库，C++编写，主要用于处理大量文档 ​ 2.MongDB是一个介于关系型数据库和非关系型数据库中中间的产品，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库 ​ 3.ConthDB 列存储数据库： HBase 分布式文件系统 图关系数据库： 他不是存图形，放的是关系，比如：朋友圈社交网络、网络推荐 Neo4J, InfoGrid 四、Redis的概述Redis的概述（Remote Dictionary Server）即远程字典服务 是单线程的多路IO复用 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、key-Value数据库，并提供多种语言的API 1.周期性把更新的数据写入磁盘或者把修改操作写入追加的记录文件 2.实现master-slaver（主从）同步 3.免费和开源，是当下最热门的NoSQL技术之一 4.结构化数据库 Redis能干嘛？ 1.内存存储，持久化（rdb,aof） 2.效率高，可以用于高速缓存 3.发布订阅系统 4.地图信息分析 5.计时器、计数器（浏览量） 特征： 1.多样的数据类型 2.持久化 3.集群 4.事务 Redis推荐都是基于Linux搭建 五、Window版本Redis版本：3.2.100 默认端口：6379 官方文档：http://redis.cn/topics/introduction 六、Linux安装Redis Linux安装Redis 1.基本的环境配置： （1） 1yum install gcc-c++ （2） # make （3） make install 2.redis默认安装路径：/usr/local/bin 3.redis配置文件: （1）在/usr/local/bin/ 下新建文件夹kconfig （2）将redis配置文件redis.conf，复制到/usr/local/bin/kconfig （3）redis默认不是后台启动，需要修改配置文件，改为后台启动 4.启动redis服务： （1）启动redis服务端 1redis-server kconfig/redis.conf （2）使用客户端连接端口号6379 1redis-cli -p 6379 5.查看进程： 1ps -ef |grep redis[服务名] 6.关闭redis服务: 12345shutdownnot connected&gt; exit# 七、redis性能测试测试：100个并发连接 10 0000请求 1$ redis-benchmark -h localhost -p 6379 -c 100 -n 100000 八、基础知识1.redis默认有16个数据库,默认使用的是第0个 （1）切换数据库： 1127.0.0.1:6379&gt; select 3 （2）数据库大小： 1127.0.0.1:6379&gt; DBSIZE （3）查看所有key: 1127.0.0.1:6379&gt; keys * （4）清除当前数据库 1127.0.0.1:6379&gt; flushdb （5）清除全部数据内容 1127.0.0.1:6379&gt; flushall （6）删除指定key数据 1127.0.0.1:6379&gt; del key (7)根据value选择非阻塞删除 1127.0.0.1:6379&gt; unline key (8)为给定的key设置过期时间 12# 10秒钟127.0.0.1:6379&gt; expire key 10 2.Redis是单线程 Redis为什么单线程这么快？ 1.误区1：高性能的服务器一定是多线程的？ 2.误区2：多线程（CPU上下文会切换）一定比单线程效率高 核心：redis是所有的数据全部放在内存中的，所以说使用单线程去操作效率是最高的，多线程会切换CPU上下文切换，对于内存系统来说，没有上下文切换是效率最高的，多次读写都是在单个CPU上操作的 九、基本命令设置key过期时间： 1127.0.0.16379&gt; EXPIRE name 10 查看key的剩余时间： 1127.0.0.16379&gt; ttl name[key] 查看key的类型 1127.0.0.16379&gt; type name Redis命令帮助文档：https://redis.io/commands 十、五大数据类型StringString二进制安全的，意味着Redis中的String可以包含任何数据，比如jpg或序列化对象，字符串value最大可以是512M 判断存在： 1127.0.0.1:6379&gt; exist key 追加：（key值不存在，相当于set） 1127.0.0.1:6379&gt; append key1 &quot;hello&quot; 获取长度： 1127.0.0.1:6379&gt; strlen key1 自增1： 12127.0.0.1:6379&gt; incr key 自减1：127.0.0.1:6379&gt; dect key 指定增量： 1127.0.0.1:6379&gt; incrby key 10 指定减量： 1127.0.0.1:6379&gt; decrby key 10 获取字符串指定范围： 1127.0.0.1:6379&gt; GETRANGE key 0 3 #[0,3] 替换指定位置开始的字符串： 1127.0.0.1:6379&gt; SETRANGE key 1 xx 设置过期时间： ​ #setex(set with expire) # 设置过期时间 1127.0.0.1:6379&gt; setex key 30 &quot;hello&quot; ​ #setnx(set if not exist) # 不存在设置（分布式锁中常常使用） 1127.0.0.1:6379&gt; setnx key &quot;redis&quot; 批量set、get #mset 1127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 #msetnx 1127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 #原子性,要么全成功，要么全失败 #对象 12127.0.0.1:6379&gt; set user:1&#123;name:zhangsan,zge:3&#125;#user:&#123;id&#125;:&#123;filer&#125; getset #先get然后再set 123127.0.0.1:6379&gt; getset db redis 1.#如果不存在值，则返回nil2.#如果存在值，则返回原来的值 ListList的数据结构为快速链表quickList 首先在列表元素较少的情况请下会使用一块连续的内存储存，这个结构是ziplist,即是压缩列表 它将所有的元素紧挨着一起储存，分配的是一块连续的内存 当数据量比较多的时候才会改成quickList 因为普通的链表需要的附加指针空间太大，会比较浪费空间，比如这个列表里存的是int类型的数据，结构上还需要两个额外的指针prev和next 在redis里面，我们可以把list当成是对栈、队列、阻塞队列的操作 所有list命令都是用l开头的 1# LPUSH 123456127.0.0.1:6379&gt; LPUSH list one # 将一个值或多个值，插入到列表头部（左）(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3 12############################################################# LRANGE 1234567891011127.0.0.1:6379&gt; LRANGE list 0 -1 # 获取list中所有值1) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; LRANGE list 0 1 # 通过区间获取具体的值1) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; LRANGE list 0 21) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot; 12############################################################# RPUSH、LPOP、RPOP 123456789101112131415127.0.0.1:6379&gt; RPUSH list right # 将一个值或多个值，插入到列表尾部（右）(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot;127.0.0.1:6379&gt; LPOP list # 移除list的第一个元素&quot;three&quot;127.0.0.1:6379&gt; RPOP list&quot;right&quot;127.0.0.1:6379&gt; LRANGE list 0 -1 # 移除list的最后一个元素1) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; 12############################################################# LINDEX、LPUSH、LLEN 123456789101112131415161718192021222324127.0.0.1:6379&gt; lindex list 1 # 通过下标获得list 中的某一个值&quot;one&quot;127.0.0.1:6379&gt; lindex list 0&quot;two&quot;127.0.0.1:6379&gt; 127.0.0.1:6379&gt; Lpush list one(integer) 1127.0.0.1:6379&gt; Lpush list two(integer) 2127.0.0.1:6379&gt; Lpush list three(integer) 3127.0.0.1:6379&gt; Llen list # 获取list长度(integer) 3127.0.0.1:6379&gt; Lpush list thre(integer) 4127.0.0.1:6379&gt; LRANGE list 1 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;thre&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot; 12############################################################# LREM 1234567891011121314127.0.0.1:6379&gt; Lrem list 1 thre # 移除列表列表中一个元素为thre(integer) 1127.0.0.1:6379&gt; Lpush list three(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; Lrem list 2 three(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot; trim 修剪；list截断 12345678910111213141516# LTRIM127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; Rpush mylist &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; Rpush mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; Rpush mylist &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2 # 截取下标指定的长度，其他被截断OK127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot; 12############################################################RPOPLPUSH 12345678910111213127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush mylist &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpoplpush mylist myotherlist # 移除最后一个元素并将它移入新的列表中&quot;hello2&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;hello1&quot;127.0.0.1:6379&gt; LRANGE myotherlist 0 -11) &quot;hello2&quot; 12############################################################# LSET 12345678910111213141516127.0.0.1:6379&gt; exists list(integer) 0127.0.0.1:6379&gt; lset list 0 item # 如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379&gt; LPUSH list value1(integer) 1127.0.0.1:6379&gt; LRANGE list 0 01) &quot;value1&quot;127.0.0.1:6379&gt; LRANGE list 0 11) &quot;value1&quot;127.0.0.1:6379&gt; LSET list 0 item # 如果存在，更新当前下标的值OK127.0.0.1:6379&gt; LRANGE list 0 01) &quot;item&quot;127.0.0.1:6379&gt; LSET list 1 other # 如果不存在则会报错(error) ERR index out of range 12############################################################# LINSERT 123456789101112131415161718Linsert # 将某个具体的value插入到列表中某个元素的前面或者后面！127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; RPUSH mylist &quot;world&quot;(integer) 2127.0.0.1:6379&gt; LINSERT mylist before &quot;world&quot; &quot;other&quot;(integer) 3127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;127.0.0.1:6379&gt; LINSERT mylist after &quot;world&quot; &quot;new&quot;(integer) 4127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;4) &quot;new&quot; 总结： list实际是一个链表，before Node after , left , right都可以插入值 如果key不存在，创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在 在两边插入或者改动值，效率最高，中间元素，相对来说效率会低一点 消息队列 | LpushRpop ， 栈 | LpushLpop SetSet数据结构是dict字典，字典使用哈希表实现的 Java中HashSet的内部实现使用的是HashMap,只不过所有的value都指向同一个对象 Redis的set结构也是一样，它的内部也使用了hash结构，所有的value都指向同一个内部值 1# SADD、SMEMBERS、SISMEMBER、SCARD 1234567891011121314151617127.0.0.1:6379&gt; sadd myset &quot;hello&quot; # set集合添加元素(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set所有值1) &quot;world&quot;2) &quot;kuangshen&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; SISMEMBER myset &quot;hello&quot; # 判断某一个值是不是在集合set中(integer) 1127.0.0.1:6379&gt; SISMEMBER myset &quot;happy&quot;(integer) 0127.0.0.1:6379&gt; scard myset # 获取集合set中元素的个数(integer) 3127.0.0.1:6379&gt; 12############################################################# SRANDMEMBER 123456789101112131415161718127.0.0.1:6379&gt; SMEMBERS myset1) &quot;world&quot;2) &quot;kuangshen&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素&quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;world&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;kuangshen&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 2 随机抽选出指定个数的元素1) &quot;kuangshen&quot;2) &quot;world&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 21) &quot;kuangshen&quot;2) &quot;hello&quot; 12############################################################# SPOP 12345678910127.0.0.1:6379&gt; SMEMBERS myset1) &quot;world&quot;2) &quot;kuangshen&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; spop myset # 随机删除一些set集合中的元素&quot;world&quot;127.0.0.1:6379&gt; spop myset&quot;kuangshen&quot;127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot; 12############################################################# SMOVE 123456789101112131415161718192021222324将一个指定的值，移动到另一个set集合127.0.0.1:6379&gt; clear127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; sadd myset2 &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;world&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; SMEMBERS myset21) &quot;kuangshen&quot;127.0.0.1:6379&gt; SMOVE myset myset2 &quot;hello&quot; # 将一个指定的值，移动到另一个set集合(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;world&quot;127.0.0.1:6379&gt; SMEMBERS myset21) &quot;kuangshen&quot;2) &quot;hello&quot; 12############################################################# SDIFF、SINTER、SUNION 123456789101112131415161718192021222324252627B站、微博共同关注（并集）127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 a(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e(integer) 1127.0.0.1:6379&gt; SDIFF key1 key2 # 差集 左 - 右1) &quot;c&quot;2) &quot;b&quot;127.0.0.1:6379&gt; SDIFF key2 key11) &quot;e&quot;2) &quot;d&quot;127.0.0.1:6379&gt; SINTER key1 key2 # 交集1) &quot;a&quot;127.0.0.1:6379&gt; SUNION key1 key2 # 并集1) &quot;a&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;e&quot;5) &quot;d&quot; HashMap集合，key-map 这个值是一个Map，本质和Sring没有太大区别，还是一个简单的key-value Hash类型对应的数据结构有两种：ziplist（压缩列表）、hashtable（哈希表）,当field-value长度交短且个数较少时，使用ziplist，否则使用hashtable set myhash field kuangshen 1# HSET、HGET、HMSET、HMGET、HGETALL 1234567891011121314127.0.0.1:6379&gt; hset myhash field1 kuangshen # set 一个具体key-value(integer) 1127.0.0.1:6379&gt; hget myhash field1 # 获取一个字段值&quot;kuangshen&quot;127.0.0.1:6379&gt; hmset myhash field1 hello field2 world # set 多个key-valueOK127.0.0.1:6379&gt; hmget myhash field1 field2 # 获取多个字段值1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash # 获取全部的数据1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot; 12############################################################# HDEL 1234567891011121314127.0.0.1:6379&gt; hset myhash field1 hello(integer) 1127.0.0.1:6379&gt; hset myhash field2 world(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; hdel myhash field1 # 删除hash指定ley字段，对应的value也就消失了(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;world&quot; 12############################################################# hlen 12345678127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量(integer) 1############################################################# HEXISTS127.0.0.1:6379&gt; HEXISTS myhash field1 #判断hash 中指定的字段是否存在(integer) 0127.0.0.1:6379&gt; HEXISTS myhash field2(integer) 1 12############################################################# HKEYS 、HVALS 12345只获得所有field，只获得所有value127.0.0.1:6379&gt; hkeys myhash # 只获得所有field1) &quot;field2&quot;127.0.0.1:6379&gt; hvals myhash # 只获得所有value1) &quot;world&quot; 12############################################################# HINCRBY、HSETNX 12345678910127.0.0.1:6379&gt; hset myhash field3 5(integer) 1127.0.0.1:6379&gt; HINCRBY myhash field3 1 # 指定增量(integer) 6127.0.0.1:6379&gt; HINCRBY myhash field3 -1(integer) 5127.0.0.1:6379&gt; HSETNX myhash field4 hello # 如果value不存在则可以设置(integer) 1127.0.0.1:6379&gt; HSETNX myhash field4 world # 如果value存在则不允许设置(integer) 0 hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息，hash更适合于对象的存储，String更适合字符串存储 ZsetSortedSet（zset）是Redis提供的一个非常特别的数据结构，一方面它等价于Java数据结构Map&lt;String, Double&gt;，可以给每一个元素赋予权重score，另一方面它有类似于TreeSet，内部的元素会安装score权重进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。 查找使用的是跳跃链表 在set的基础上，增加了一个值，增加了一个值，set k1 v1 , zset k1 score1 v1 123456789# ZADD、ZRANGE127.0.0.1:6379&gt; zadd myset 1 one # 添加一个值(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; 12############################################################# ZRANGEBYSCORE 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; zadd salary 2500 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 5000 zhagsan(integer) 1127.0.0.1:6379&gt; zadd salary 500 kuangshen(integer) 1127.0.0.1:6379&gt; ZRANGE salary 0 -1 # 显示全部用户，从小到大1) &quot;zhangsan&quot;2) &quot;xiaohong&quot;3) &quot;xiaoming&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示全部用户 从小到大1) &quot;kuangshen&quot;2) &quot;xiaohong&quot;3) &quot;zhagsan&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 从小到大显示全部用户并且附带成绩1) &quot;kuangshen&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;5) &quot;zhagsan&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores1) &quot;kuangshen&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot; 12############################################################# ZREVRANGE、ZREVRANGEBYSCORE 123456789101112131415161718192021127.0.0.1:6379&gt; zadd salary 2500 xiaoming (integer) 1127.0.0.1:6379&gt; zadd salary 1800 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 1500 zhangsan(integer) 1127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 # 显示全部用户，从大到小1) &quot;xiaoming&quot;2) &quot;xiaohong&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; ZREVRANGEBYSCORE salary +inf -inf # 从大到小显示1) &quot;xiaoming&quot;2) &quot;xiaohong&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; ZREVRANGEBYSCORE salary +inf -inf withscores # 从大到小显示全部用户并且附带成绩1) &quot;xiaoming&quot;2) &quot;2500&quot;3) &quot;xiaohong&quot;4) &quot;1800&quot;5) &quot;zhangsan&quot;6) &quot;1500&quot; 12############################################################# ZCOUNT 12127.0.0.1:6379&gt; zcount salary 1500 3000 # 读取指定区间的用户数量(integer) 3 总结： ZRANGE 后面只能跟 0 -1 ZRANGEBYSCORE后面只能跟 范围，例如： -inf +inf 十一、三大特殊数据类型Geospatial地理位置八命令： 123# geoadd 添加地理位置#规则 两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入#参数 key 值（经度 纬度 名称） 123456789127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou(integer) 1127.0.0.1:6379&gt; 12#############################################################geopos 123456127.0.0.1:6379&gt; GEOPOS china:city beijing # 获取地理位置坐标1) 1) &quot;116.39999896287918091&quot; 2) &quot;39.90000009167092543&quot;127.0.0.1:6379&gt; GEOPOS china:city shanghai1) 1) &quot;121.47000163793563843&quot; 2) &quot;31.22999903975783553&quot; 12# GEODIST两人之间的距离 单位： m表示单位为米 km表示单位为千米 mi表示单位为英里 ft表示单位为英尺 1# GEODIST 123456127.0.0.1:6379&gt; GEODIST china:city beijing shanghai # 北京到上海的直径距离&quot;1067378.7564&quot;127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km&quot;1067.3788&quot;127.0.0.1:6379&gt; GEODIST china:city beijing chongqing km&quot;1464.0708&quot; 1# GEORADIUS [WITHCOORD] [WITHDIST] 12345678910111213141516171819202122232425262728293031323334127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km # 获取处在某个具体坐标指定半径内的地理位置1) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km1) &quot;chongqing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist1) 1) &quot;chongqing&quot; 2) &quot;341.9374&quot;2) 1) &quot;xian&quot; 2) &quot;483.8340&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord1) 1) &quot;chongqing&quot; 2) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot; 2) 1) &quot;108.96000176668167114&quot; 2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 11) 1) &quot;chongqing&quot; 2) &quot;341.9374&quot; 3) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 21) 1) &quot;chongqing&quot; 2) &quot;341.9374&quot; 3) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot; 2) &quot;483.8340&quot; 3) 1) &quot;108.96000176668167114&quot; 2) &quot;34.25999964418929977&quot; 12# GEOHASH该命令返回11个字符的Geohash字符串 1234# 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，name则距离越近127.0.0.1:6379&gt; GEOHASH china:city beijing chongqing1) &quot;wx4fbxxfke0&quot;2) &quot;wm5xzrybty0&quot; 1GEO 底层的实现原理其实就是Zset,我们可以使用Zset命令来操作geo 123456789101112131415127.0.0.1:6379&gt; ZRANGE china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing&quot;127.0.0.1:6379&gt; ZREM china:city beijing(integer) 1127.0.0.1:6379&gt; ZRANGE china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot; Hyperloglog基数统计Redis2.8.9版本就更新了Hyperloglog数据结构 Redis Hyperloglog基数统计的算法 优点：占用的内存是固定，计算2^64不同的元素的技术，只需要费12KB内存，如果要从内存角度来比较，Hyperloglog首选 网页的UV 传统方式：set保存用户的id,然后统计set中的元素数量作为标准判断 0.81%错误率，统计UV任务，可以忽略不计 12# PFADD、PFCOUNT、PFMERGE测试 12345678910127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i # 创建第一组元素 key(integer) 1127.0.0.1:6379&gt; pfadd mykey2 i j z x c v b n m (integer) 1127.0.0.1:6379&gt; pfcount mykey2 # 统计mykey2元素的基数数量(integer) 9127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集OK127.0.0.1:6379&gt; pfcount mykey3 # 统计并集中的元素数量(integer) 15 要使用Hyperloglog，前提是允许容错！ Bitmaps位图场景1位存储 统计用户信息，活跃，未活跃，登录，未登录，打卡，365打卡，两个状态的，都可以使用Bitmapes！ Bitmaps位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态 合理地使用操作位能够有效地提高内存使用率和开发效率 （1）Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value），但是它可以对字符串的位进行操作 （2）Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储1和0，数组的下标在Bitmaps中叫做偏移量 365天=365bit 1字节=8bit 46个字节左右 1测试 1# SETBIT、GETBIT 1234567891011121314127.0.0.1:6379&gt; setbit sign 0 1 # 设置第一天打卡(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 1(integer) 0127.0.0.1:6379&gt; setbit sign 3 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; getbit sign 3 # 查看第三天是否有打卡(integer) 1 1# bitop （1）格式 1bitop and(or/not/xor) &lt;destkey&gt; [key....] bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、or（并集）、not（非）。 xor（异或）操作并将结果保存在destkey中 注： 很多用户的id以一个指定的id开头，直接将用户的id和Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做setbit操作时将用户id减去这个指定数字。 在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis阻塞。 十二、Redis实现乐观锁监控 Watch（面试常问！） 悲观锁： 很悲观，认为什么时候都会出问题，无论做什么都会加锁 传统的关系数据库里边就用到这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁 实现方法：在sql后面加上 for update或者for update nowait 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据， 获取version 更新的时候比较数据库的version 乐观锁于多读的应用类型，这样可以提高吞吐量，Redis就是利用这种check-and-set机制实现事务的。 1Redis监视测试 两种之间的差别就是，在并发执行的时候，悲观锁会阻塞，而乐观锁会不执行 执行成功： 123456789101112131415127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money # 监视 money 对象OK127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功OK127.0.0.1:6379(TX)&gt; DECRBY money 20QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 20QUEUED127.0.0.1:6379(TX)&gt; exec1) (integer) 802) (integer) 20 执行失败： 客户端1： 12345678910111213127.0.0.1:6379&gt; watch money # 监视moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; DECRBY money 10QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 10QUEUED127.0.0.1:6379(TX)&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败(nil)127.0.0.1:6379&gt; get money&quot;1000&quot;127.0.0.1:6379&gt; 客户端2： 12345[fangyupeng@hadoop102 ~]$ redis-cli -p 6379127.0.0.1:6379&gt; get money&quot;80&quot;127.0.0.1:6379&gt; set money 1000OK 原因：watch到脏数据，需要unwatch后再watch 注意：实现乐观锁开启监视必须在开启事务之前！ 十三、Redis基本事务操作Redis事务本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行 一次性、顺序性、排他性，执行一些列的命令 Redis事务的主要作用串联多个命令，防止别的命令插队 单独的隔离操作，事务执行过程中不会被客户端发送来的命令请求所打断 Redis事务没有隔离级别的概念 所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会被执行，exec Redis单挑命令是保证原子性的，但是事务不保证原子性 redis事务： 开启事务（Multi） 命令入队（….） 执行事务（exec） 1正常执行事务 123456789101112131415127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; exec # 执行事务1) OK2) OK3) &quot;v2&quot;4) OK 1放弃事务 12345678910127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; DISCARDOK127.0.0.1:6379&gt; get k4(nil) 1编译型异常（代码有问题，命令有错），事务中所有的命令都不会执行 123456789101112131415161718127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; set k5 v5QUEUED127.0.0.1:6379(TX)&gt; exec # 所有的命令都不会执行(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5(nil) 1运行时异常（1/0），如果事务队列中存在语法性，那么执行命令的时候，其他命令可以正常执行，错误命令抛出异常 1234567891011121314151617181920212223127.0.0.1:6379&gt; set k1 &quot;v1&quot;OK127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379(TX)&gt; incr k1 # 失败QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; get k3QUEUED127.0.0.1:6379(TX)&gt; exec # 事务可以执行1) (error) ERR value is not an integer or out of range2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; get k3&quot;v3&quot;127.0.0.1:6379&gt; get k1&quot;v1&quot; 实现秒杀 使用乐观锁（库存遗留问题） 使用 lua（解决库存遗留问题） 库存遗留问题：第一个用户成功秒杀时，并发时的其他用户都秒杀失败，就算存在库存，lua作为嵌入式语言，可以使得整个事务具有原子性，不会被其他命令插队，不存在版本号不同问题 十四、通过Jedis操作Redis依赖： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt; testList 12345678910111213141516171819202122232425262728293031323334353637383940package com.zhkucst;import redis.clients.jedis.Jedis;public class TestList &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.10.102&quot;,6379); jedis.flushDB(); System.out.println(&quot;======添加一个List======&quot;); jedis.lpush(&quot;collections&quot;,&quot;ArrayList&quot;, &quot;Vector&quot;,&quot;Stack&quot;, &quot;HashMap&quot;,&quot;WeakHashMap&quot;,&quot;LinkedHashMap&quot;); jedis.lpush(&quot;collections&quot;,&quot;HashSet&quot;); jedis.lpush(&quot;collections&quot;,&quot;TreeSet&quot;); jedis.lpush(&quot;collections&quot;,&quot;TressMap&quot;); System.out.println(&quot;collection的内容：&quot; + jedis.lrange(&quot;collections&quot;,0, -1)); System.out.println(&quot;============================&quot;); System.out.println(&quot;删除指定元素个数：&quot; + jedis.lrem(&quot;collections&quot;,2, &quot;HashMao&quot;)); System.out.println(&quot;删除下表0-3区间之外的元素：&quot; + jedis.ltrim(&quot;collections&quot;,0,3)); System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,0, -1)); System.out.println(&quot;collections列表出栈（左端）:&quot; + jedis.lpop(&quot;collections&quot;)); System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,0, -1)); System.out.println(&quot;collections列表出栈（右端 ）：&quot; + jedis.rpop(&quot;collections&quot;)); System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,0, -1)); System.out.println(&quot;修改collections列表指定下标1的内容：&quot; + jedis.lset(&quot;collections&quot;,1,&quot;UpdateHashSet&quot;)); System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,0, -1)); System.out.println(&quot;============================&quot;); System.out.println(&quot;collections的长度：&quot; + jedis.llen(&quot;collections&quot;)); System.out.println(&quot;获取collections下标为2的元素：&quot; + jedis.lindex(&quot;collections&quot;,2)); System.out.println(&quot;============================&quot;); jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;,&quot;6&quot;,&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;); System.out.println(&quot;sortedList排序前：&quot; + jedis.lrange(&quot;sortedList&quot;, 0, -1)); System.out.println(jedis.sort(&quot;sortedList&quot;)); System.out.println(&quot;sortedList排序后：&quot; + jedis.lrange(&quot;sortedList&quot;, 0, -1)); &#125;&#125; testSet 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zhkucst;import redis.clients.jedis.Jedis;public class TestSet &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.10.102&quot;, 6379); jedis.flushDB(); System.out.println(&quot;======向集合中添加元素（不重复）======&quot;); System.out.println(jedis.sadd(&quot;eleSet&quot;,&quot;e1&quot;,&quot;e2&quot;,&quot;e3&quot;,&quot;e4&quot;,&quot;e0&quot;,&quot;e8&quot;,&quot;e7&quot;,&quot;e5&quot;)); System.out.println(jedis.sadd(&quot;eleSet&quot;,&quot;e6&quot;)); System.out.println(jedis.sadd(&quot;eleSet&quot;,&quot;e6&quot;)); System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;)); System.out.println(&quot;删除一个元素e0：&quot; + jedis.srem(&quot;eleSet&quot;,&quot;e0&quot;)); System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;)); System.out.println(&quot;删除两个元素e7,e6：&quot; + jedis.srem(&quot;eleSet&quot;,&quot;e7&quot;, &quot;e6&quot;)); System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;)); System.out.println(&quot;随机地移除集合中的一个元素：&quot; + jedis.spop(&quot;eleSet&quot;)); System.out.println(&quot;随机地移除集合中的一个元素：&quot; + jedis.spop(&quot;eleSet&quot;)); System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;)); System.out.println(&quot;eleSet集合中包含的元素个数：&quot; + jedis.scard(&quot;eleSet&quot;)); System.out.println(&quot;e3是否在eleSet集合中：&quot; + jedis.sismember(&quot;eleSet&quot;,&quot;e3&quot;)); System.out.println(&quot;e1是否在eleSet集合中：&quot; + jedis.sismember(&quot;eleSet&quot;,&quot;e1&quot;)); System.out.println(&quot;e5是否在eleSet集合中：&quot; + jedis.sismember(&quot;eleSet&quot;,&quot;e5&quot;)); System.out.println(&quot;============================&quot;); System.out.println(&quot;eleSet1:&quot; + jedis.sadd(&quot;eleSet1&quot;,&quot;e1&quot;,&quot;e2&quot;,&quot;e4&quot;,&quot;e3&quot;,&quot;e0&quot;,&quot;e8&quot;,&quot;e7&quot;,&quot;e5&quot;)); System.out.println(&quot;eleSet2:&quot; + jedis.sadd(&quot;eleSet2&quot;,&quot;e1&quot;,&quot;e2&quot;,&quot;e4&quot;,&quot;e3&quot;,&quot;e0&quot;,&quot;e8&quot;)); System.out.println(&quot;eleSet1的元素：&quot; + jedis.smembers(&quot;eleSet1&quot;)); System.out.println(&quot;eleSet2的元素：&quot; + jedis.smembers(&quot;eleSet2&quot;)); System.out.println(&quot;将eleSet1中删除e1并存入eleSet3：&quot; + jedis.smove(&quot;eleSet1&quot;,&quot;eleSet3&quot;,&quot;e1&quot;)); System.out.println(&quot;将eleSet1中删除e2并存入eleSet3：&quot; + jedis.smove(&quot;eleSet1&quot;,&quot;eleSet3&quot;,&quot;e2&quot;)); System.out.println(&quot;eleSet1的元素：&quot; + jedis.smembers(&quot;eleSet1&quot;)); System.out.println(&quot;eleSet3的元素：&quot; + jedis.smembers(&quot;eleSet3&quot;)); System.out.println(&quot;======集合运算======&quot;); System.out.println(&quot;eleSet1的元素：&quot; + jedis.smembers(&quot;eleSet1&quot;)); System.out.println(&quot;eleSet2的元素：&quot; + jedis.smembers(&quot;eleSet2&quot;)); System.out.println(&quot;eleSet1与eleSet2的交集：&quot; + jedis.sinter(&quot;eleSet1&quot;, &quot;eleSet2&quot;)); System.out.println(&quot;eleSet1与eleSet2的并集：&quot; + jedis.sunion(&quot;eleSet1&quot;,&quot;eleSet2&quot;)); System.out.println(&quot;eleSet1与eleSet2的差集：&quot; + jedis.sdiff(&quot;eleSet1&quot;,&quot;eleSet2&quot;)); &#125;&#125; testHash 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zhkucst;import redis.clients.jedis.Jedis;import java.util.HashMap;import java.util.Map;public class TestHash &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.10.102&quot;, 6379); jedis.flushDB(); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;k1&quot;,&quot;v1&quot;); map.put(&quot;k2&quot;,&quot;v2&quot;); map.put(&quot;k3&quot;,&quot;v3&quot;); map.put(&quot;k4&quot;,&quot;v4&quot;); jedis.hmset(&quot;hash&quot;,map); jedis.hset(&quot;hash&quot;,&quot;key5&quot;,&quot;value5&quot;); System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;散列hash的所有键：&quot; + jedis.keys(&quot;hash&quot;)); System.out.println(&quot;散列hash的所有值：&quot; + jedis.hvals(&quot;hash&quot;)); System.out.println(&quot;将k6保存的值加上一个整数，如果k6不存在则添加k6：&quot; + jedis.hincrBy(&quot;hash&quot;,&quot;key6&quot;,6)); System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;将k6保存的值加上一个整数，如果k6不存在则添加k6：&quot; + jedis.hincrBy(&quot;hash&quot;,&quot;key6&quot;,3)); System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;删除一个或多个键值对：&quot; + jedis.hdel(&quot;hash&quot;,&quot;k2&quot;)); System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;散列表hash中键值对个数：&quot; + jedis.hlen(&quot;hash&quot;)); System.out.println(&quot;判断hash中是否存在k2：&quot; + jedis.hexists(&quot;hash&quot;,&quot;k2&quot;)); System.out.println(&quot;判断hash中是否存在k3：&quot; + jedis.hexists(&quot;hash&quot;,&quot;k3&quot;)); System.out.println(&quot;获取hash中k3的值：&quot; + jedis.hmget(&quot;hash&quot;,&quot;k2&quot;)); System.out.println(&quot;获取hash中k2、k3的值：&quot; + jedis.hmget(&quot;hash&quot;,&quot;k2&quot;,&quot;k3&quot;)); &#125;&#125; 十五、通过Jedis操作事务TestTX.jar 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zhkucst;import com.alibaba.fastjson.JSONObject;import redis.clients.jedis.Jedis;import redis.clients.jedis.Transaction;public class TextTX &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.10.102&quot;,6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;hello&quot;,&quot;world&quot;); jsonObject.put(&quot;name&quot;,&quot;zhangsan&quot;); jedis.flushDB(); System.out.println(&quot;开启事务...&quot;); Transaction multi = jedis.multi(); //jedis.watch();//开启监视 // ..... //jedis.unwatch();关闭监视 try &#123; String result = jsonObject.toJSONString(); multi.set(&quot;user1&quot;,result); multi.set(&quot;user2&quot;,result); int i = 1/0; multi.exec(); &#125; catch (Exception exception) &#123; multi.discard(); exception.printStackTrace();//放弃事务 &#125; finally &#123; System.out.println(jedis.get(&quot;user1&quot;)); System.out.println(jedis.get(&quot;user2&quot;)); jedis.close();//关闭连接 &#125; &#125;&#125; 十六、自定义RedisTemplate通过自动配置类源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * Copyright 2012-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.boot.autoconfigure.data.redis;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;/** * &#123;@link EnableAutoConfiguration Auto-configuration&#125; for Spring Data&#x27;s Redis support. * * @author Dave Syer * @author Andy Wilkinson * @author Christian Dupuis * @author Christoph Strobl * @author Phillip Webb * @author Eddú Meléndez * @author Stephane Nicoll * @author Marco Aust * @author Mark Paluch * @since 1.0.0 */@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123; @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 可知，Redis可以自定义配置类，来实现序列化 通过接口 public interface RedisSerializer 的实现类分析，有几种序列化方式 pojo类实现接口Serializable以实现能够序列化对象 自定义RedisTemplate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhkucst.conf;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean //抑制所有警告 @SuppressWarnings(&quot;all&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; //一般使用&lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); //json序列化设置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); //String序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); //key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); //hash的key采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); //value采用json的序列化方式 template.setValueSerializer(jackson2JsonRedisSerializer); //hash的value采用json序列化方式 template.setHashValueSerializer(jackson2JsonRedisSerializer); //其他未自定义的属性通过该方法配置默认的PropertiesSet template.afterPropertiesSet(); return template; &#125;&#125; 测试 1234567891011121314 @Test public void test() throws JsonProcessingException &#123; User user = new User(&quot;张三&quot;,23); //String jsonUser = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(&quot;user&quot;, user); System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;)); &#125;&#125; 十七、Redis配置文件详解单位 1.配置文件unit单位对大小写不敏感，只支持byte，不支持bit 包含 好比我们学习Spring、Import、include 网络123bind 127.0.0.1 # 绑定的idprotected-mode yes # 保护模式port 6379 # 端口设置 通用GENERAL 12345678910111213daemonize yes # 以守护进程的方式进行，默认是no,我们需要自己开启为yespidfile /var/run/redis_6379.pid #如果以后台的方式运行，我们需要指定一个pid文件# 日志# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably) 生产模式# warning (only very important / critical messages are logged)loglevel notice # 日志文件的通知等级logfile &quot;/usr/local/bin/klog&quot; # 日志的文件位置名databases 16 # 数据库的数量， 默认是16个数据库always-show-logo no # 是否总显示logo 快照持久化，在规定时间内，执行了多少次操作，则会持久化到文件，rdb.aof redis是内存数据库，如果没有持久化，那么数据数据断电及失 1234567891011# 如果900s内，如果至少有1 key进行了修改，我们及进行持久化操作save 900 1# 如果300s内，如果至少有10 key进行了修改，我们及进行持久化操作save 300 10# 如果60s内，如果至少有10000 key进行了修改，我们及进行持久化操作save 60 10000stop-writes-on-bgsave-error yes # 持久化如果出错，是否需要继续工作rdbcompression yes # 是否压缩rdb文件，需要消耗一些cpurdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验#dir ./ # rdb 文件保存的目录，默认为启动服务时的当前路径，最好改成绝对路径 dir /usr/local/bin/krdb REPLICATION复制，主从复制详见十九篇：Redis主从复制 SECURITY 安全可以在这里设置redis的密码，默认是没有密码 1234567891011# root127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; config get requirepass # 获取redis的密码1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123456&quot; 12345678910# localhost127.0.0.1:6379&gt; config get requirepass(error) NOAUTH Authentication required.127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123456&quot; 限制CLIENTS1maxclients 10000MEMORY MANAGEMENT 内存处理策略 12345678910111213141516171819202122maxmemory &lt;bytes&gt; # redis配置最大内存容量maxmemory-policy noeviction # 内存到达上限后的处理策略1、volatile-lru -&gt; Evict using approximated LRU(Least Recently Used), only keys with an expire set. # 只对设置了过期时间的key 进行LRU（默认值）2、allkeys-lru -&gt; Evict any key using approximated LRU. # 删除LRU算法的key3、volatile-lfu -&gt; Evict using approximated LFU(Least Frequently Used), only keys with an expire set. # 只对设置了过期时间的key 进行LFU4、allkeys-lfu -&gt; Evict any key using approximated LFU. # 删除LFU算法的key5、volatile-random -&gt; Remove a random key having an expire set. # 随机删除即将过期的key6、allkeys-random -&gt; Remove a random key, any key. # 随机删除7、volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL) # 删除即将过期的8、noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations. # 永不过期，返回错误# LRU means Least Recently Used# LFU means Least Frequently Used APPEND ONLY MODE aof模式1234567appendonly no # 默认是不开启aof模式，默认是是rdb方式持久化，在大部分所有的情况下，rdb够用appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字# appendfsync always # 每次修改都会sync,消耗性能appendfsync everysec # 每秒执行 sync， 可能会丢失1s的数据# appendfsync no # 不执行 sync， 这个时候操作系统自己同步数据，速度更快 十八、持久化-RDB操作什么是RDB？ 查找文件名：root@hadoop102 bin# find / -name dump.rdb 查找配置文件中的配置，命令：config get dir save 和 bgsave save：save时只管保存，其他不管，全部阻塞，手动保存，不建议 bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求 生成RDB的方式： 满足save规则，会自动触发rdb规则 FLUSHALL命令，触发rdb规则 shutdown，退出redis，产生rdb文件 恢复RDB文件 步骤 只需将rdb文件放在redis启动目录，即配置文件中指定的dir路径： 123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/bin&quot; # 如果在该目录下存在dump.rdb，启动redis会自动恢复其中的数据，放到内存中 redis启动后会自动检查demp.rdb恢复其中的数据 优点 适合大规模的数据恢复 对数据的完整性要求不高 节省磁盘空间 恢复速度快 缺点 需要一定的时间间隔进程操作，如果redis意外死机了，这个最后一次修改的数据就没有了。（因为rdb持久化操作是先保存在了临时文件中，这是宕机那临时文件也就不能替换原来的rdb文件，导致最后一次持久化操作数据丢失） fork进程的时候，会占用一定的内容空间，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能 其他配置 stop-writes-on-bgsave-error 当Redis无法写入磁盘的话，直接关掉Redis的写操作，推荐yes rdbcompression压缩文件 对于存储到磁盘中的快照，可以设置是否进行压缩存储，如果是的话，redis会采用LZF算法进行压缩，默认是yes rdbchecksum检查完整性 在存储快照后，还可以让redis使用CRC64算法来进行数据校验 十九、持久化-AOF操作什么是AOF?（Append Only File） aof保存的是 appendonly.aof文件 默认是不开启的，我们需要手动配置，我们只需将 appendonly 改为 yes 就开启了 aof 如果这个aof文件有错误，这时候redis是启动不起来的，我们需要修复这个aof文件 redis给我们提供了一个工具 redis-check-aof 1234567appendonly no # 默认是不开启aof模式，默认使用rdb方式持久化，在大部分情况下，有rdb就够了appendfilename &quot;appendonly.aof&quot; # 持久化的文件名appendfsync always # 每次修改都会sync ,消耗性能appendfsync everysec # 每秒执行一次 sync，可能会丢失1s的数据appendfsync no # 不执行sync，这个时候操作系统自己同步数据，速度更快 AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失） AOF和RDB所在的目录在同一个位置 开启AOF进行备份时要先关闭redis或开启后重启redis，配置才会生效 重启redis便会加载aof文件进行恢复，文件损坏会启动失败 修复AOF文件1redis-check-aof --fix krdb/appendonly.aof 重写规则说明aof默认就是文件的无限追加，文件会越来越大 12345no-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb # 如果aof文件大于64m，太大了，fork一个新的进程来将我们的文件进行重写 优点和缺点 优点 每一次修改都同步，文件的完整性会更加好 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb,恢复的速度比rdb慢 aof运行效率要比rdb慢，所以我们redis默认的配置就是rdb持久化 二十、Redis主从复制概念主从复制，是指将一台redis服务器的数据，复制到其他Redis服务器，前者称为主节点（master/leader）,后者称为从节点（slaver/follower），数据的复制是单向的，只能从主节点到从节点，Master以写为主，Slaver以读为主。 默认情况下，每套Redis服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。 三种实现方式： 一主二仆 薪火相传 反客为主 主从复制的作用主要包括： 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式； 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余； 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供度服务（即写Redis数据是应用连接主节点，读Redis数据是应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担负载，可以大大提高Redis服务器的并发量。 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下： 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大； 从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G,也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。 电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点就算“多读少写” 对于这种场景，我们可以使用如下这种结构 主从复制、读写分离！ 查看主从复制中主机的角色1info replication 认定主机 是需要在需要作为从机上命令： 1127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379 # 这种方式是暂时性的 永久配置在从机配置文件redis.conf中配置： 1replicaof 127.0.0.1 6379 # 配置认定主机ip 地址和 port端口号 复制原理Slaver启动成功连接到master后会发送一个sync同步命令 master街道命令，启动后台的存盘进程，同时手机所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：而slave服务在接收到数据库数据文件后，将其存盘并加载在内存中。 增量复制：master继续将新的所有收集到的修改命令依次传给slave，完成1同步 但是只要是重新连接master，一次完成同步（全量复制）将自动执行，我们的数据可以在从机中看到 二十一、Redis发布订阅Redsi发布订阅（pub/sub）是一种消息通信模式，发送者（pub）发送消息，订阅者（sub）接收信息，微信、微博、关注系统 Redis客户端可以订阅任意数量的频道 第一个：消息发送者，第二个：频道，第三个：消息订阅者 下图展示了频道channel1，以及订阅这个频道的三个客户端–client2、client5、client1之间的关系 当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端 命令这些命令广泛用于构建即时通讯应用，比如网络聊天室（chatroom）和实时广播、实时提醒等 序号 命令及描述 1 [PSUBSCRIBE pattern pattern …] 订阅一个或多个符合给定模式的频道。 2 [PUBSUB subcommand argument [argument …]] 查看订阅与发布系统状态。 3 PUBLISH channel message 将信息发送到指定的频道。 4 [PUNSUBSCRIBE pattern [pattern …]] 退订所有给定模式的频道。 5 [SUBSCRIBE channel channel …] 订阅给定的一个或多个频道的信息。 6 [UNSUBSCRIBE channel [channel …]] 指退订给定的频道。 测试发送端： 1234127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,kuangshen&quot; # 发布者发布消息到频道(integer) 1127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,redis&quot; # 发布者发布消息到频道(integer) 1 订阅端： 123456789101112127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo # 订阅一个频道 kuangshenshuoReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;kuangshenshuo&quot;3) (integer) 1# 等待读取推送的消息1) &quot;message&quot; # 消息2) &quot;kuangshenshuo&quot; # 哪个频道的消息3) &quot;hello,kuangshen&quot; # 消息的具体内容1) &quot;message&quot;2) &quot;kuangshenshuo&quot;3) &quot;hello,redis&quot; 原理Redis是实验C实现的，通过分析Redis源码里的pubsub.c文件，了解了发布和订阅机制的底层实现，借此加深对Redis的理解。 Redis通过PUBLISH、SUBSCRIBE和PSUBSCRIBE实现发布和订阅功能。 微信： 通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。 通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在她所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。 Pub/Sub从字面上理解就是发布（Publish）与订阅（Subcribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端会收到相应的消息，这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。 二十二、集群环境搭建环境配置 只配置从库，不配置主库 复制3个配置文件，然后修改对应的信息 include /usr/local/bin/kconfig/redis.conf #包含默认配置，下面的配置会覆盖 端口 pid名 log文件名 dump.rdb名 cluster-enabled yes 打开集群模式 cluster-config-file nodes-6379.conf 设定节点配置文件名 cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换 vim全局替换脚本 1:%s/6379/6380 什么是插槽 插槽是Redis对Key进行分片的单元。在Redis的集群实现中，内置了数据自动分片机 制，集群内部会将所有的key映射到16384个插槽中，集群中的每个数据库实例负责其中部 分的插槽的读写。 合体（初始集群主从节点）cd /opt/module/redis-6.2.4/src 1redis-cli --cluster create --cluster-replicas 1 192.168.10.102:6379 192.168.10.102:6380 192.168.10.102:6381 192.168.10.102:6389 192.168.10.102:6390 192.168.10.102:6391 此处不要用127.0.0.1，请用真实ip地址 –replicas 1 采用最简单的方式配置集群 一台主机，一台从机，正好三组 一个Redis集群包含16384个插槽（hash slot），数据库中的每个键都属于这16384个插槽的其中一个 集群使用公式CRC16(key) % 16384 来计算键 key 属于哪个槽，其中CRC16(key) 语句用于计算键key的CRC16校验和 集群中的每个节点负责处理一部分插槽，举个例子，如果一个集群可以有主节点，其中 节点A负责处理0-5460号插槽 节点B负责处理5461-10922号插槽 节点C负责处理 10923-16383号插槽 查看集群状态： 1cluster nodes 集群客户端连接加上属性-c，表示以集群（cluster）模式连接 1redis-cli -c -h yourhost -p yourpost 计算key的插槽值 1cluster keyslot k1 计算在某个插槽中key的个数（只能在本客户端所在的插槽范围查询到） 1cluster countkeysinslot 7629 取出在具体插槽值的key 1cluster getkeysinslot 7629 1 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为yes，那么，整个集群都挂掉，也就是该集群要求完整性 如果某一段插槽的主从都挂掉，二cluster-require-full-converage为no,那么，该插槽数据全都不能使用，也无法存储，其他的插槽可以正常使用 Redis集群的不足多键操作是不被支持的 多键的Redis事务是不被支持的，lua脚本不被支持 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大 二十三、Redis的Jedis开发代码：1234567891011121314151617public class RedisClusterDemo &#123; public static void main(String[] args) &#123; //创建对象 HostAndPort hostAndPort = new HostAndPort(&quot;192.168.10.102&quot;, 6379); JedisCluster jedisCluster = new JedisCluster(hostAndPort); //进行操作 jedisCluster.set(&quot;b1&quot;, &quot;value1&quot;); String value = jedisCluster.get(&quot;b1&quot;); System.out.println(value); &#125;&#125; 二十四、宕机后手动配置主机如果出现master断开了连接，这个时候能不能选择一个老大处理呢？手动配置如果主机断开连接，我们可以使用 slaveof no one 来让自己变成主机，其他节点就可以手动连接到最新的这个主节点· 不管之前是通过配置文件认主或者是手动命令认主，都是可以的 主机宕机后，切换主机步骤： 找一个想成为主机的，将之设置为master，使用 slaveof no one 在其他端口节点上 认主slaveof id地址 端口号 注意： 原来的主机恢复后，将是一个独立的master，不会再与其他节点连接 手动配置后，再次启动Redis还会生效 二十五、哨兵模式概述（自动选举老大）主从切换技术的方法是：当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用，这不是一种推荐方式，更多时候，我们优先考虑哨兵模式，Redis从2..8开始正式提供了Senntinel（哨兵）架构来解决这个问题。 优先级在redis.conf中默认：replica-priority 100 值越小优先级越高 哨兵模式是一种特殊的模式，首先Redsi提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立运行，其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行多个Redis实例。 假设主服务宕机，哨兵1先监测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为服务不可用，这个现象称为主观下线，当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover故障转移操作，切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 优点 能够后台监控主机是否故障，如果故障根据投票数自动将从库转换为主库 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有 主从可以切换，故障可以转移，系统的可用性就会更好 哨兵模式就是主从模式的升级，手动到自动，更加健壮 缺点 Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦 实现哨兵模式的配置其实是很麻烦的，里面有很多选择 哨兵模式的全部配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster 127.0.0.1 6379 2 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass &lt;master-name&gt; &lt;password&gt; sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， 这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， 一个是事件的类型， 一个是事件的描述。 如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; # 目前&lt;state&gt;总是“failover”, # &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427# Example sentinel.conf# *** IMPORTANT ***## By default Sentinel will not be reachable from interfaces different than# localhost, either use the &#x27;bind&#x27; directive to bind to a list of network# interfaces, or disable protected mode with &quot;protected-mode no&quot; by# adding it to this configuration file.## Before doing that MAKE SURE the instance is protected from the outside# world via firewalling or other means.## For example you may use one of the following:## bind 127.0.0.1 192.168.1.1## protected-mode no# port &lt;sentinel-port&gt;# The port that this sentinel instance will run on# 哨兵 sentimel 实例运行的端口 默认 26379port 26379# By default Redis Sentinel does not run as a daemon. Use &#x27;yes&#x27; if you need it.# Note that Redis will write a pid file in /var/run/redis-sentinel.pid when# daemonized.daemonize no# When running daemonized, Redis Sentinel writes a pid file in# /var/run/redis-sentinel.pid by default. You can specify a custom pid file# location here.pidfile /var/run/redis-sentinel.pid# Specify the log file name. Also the empty string can be used to force# Sentinel to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile &quot;&quot;# sentinel announce-ip &lt;ip&gt;# sentinel announce-port &lt;port&gt;## The above two configuration directives are useful in environments where,# because of NAT, Sentinel is reachable from outside via a non-local address.## When announce-ip is provided, the Sentinel will claim the specified IP address# in HELLO messages used to gossip its presence, instead of auto-detecting the# local address as it usually does.## Similarly when announce-port is provided and is valid and non-zero, Sentinel# will announce the specified TCP port.## The two options don&#x27;t need to be used together, if only announce-ip is# provided, the Sentinel will announce the specified IP and the server port# as specified by the &quot;port&quot; option. If only announce-port is provided, the# Sentinel will announce the auto-detected local IP and the specified port.## Example:## sentinel announce-ip 1.2.3.4# dir &lt;working-directory&gt;# Every long running process should have a well-defined working directory.# For Redis Sentinel to chdir to /tmp at startup is the simplest thing# for the process to don&#x27;t interfere with administrative tasks such as# unmounting filesystems.# 哨兵 sentinel的工作目录dir /tmp# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;## Tells Sentinel to monitor this master, and to consider it in O_DOWN# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.## Note that whatever is the ODOWN quorum, a Sentinel will require to# be elected by the majority of the known Sentinels in order to# start a failover, so no failover can be performed in minority.## Replicas are auto-discovered, so you don&#x27;t need to specify replicas in# any way. Sentinel itself will rewrite this configuration file adding# the replicas using additional configuration options.# Also note that the configuration file is rewritten when a# replica is promoted to master.## Note: master name should not include special characters or spaces.# The valid charset is A-z 0-9 and the three characters &quot;.-_&quot;.sentinel monitor mymaster 127.0.0.1 6379 2# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;## Set the password to use to authenticate with the master and replicas.# Useful if there is a password set in the Redis instances to monitor.## Note that the master password is also used for replicas, so it is not# possible to set a different password in masters and replicas instances# if you want to be able to monitor these instances with Sentinel.## However you can have Redis instances without the authentication enabled# mixed with Redis instances requiring the authentication (as long as the# password set is the same for all the instances requiring the password) as# the AUTH command will have no effect in Redis instances with authentication# switched off.## Example:## sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# sentinel auth-user &lt;master-name&gt; &lt;username&gt;## This is useful in order to authenticate to instances having ACL capabilities,# that is, running Redis 6.0 or greater. When just auth-pass is provided the# Sentinel instance will authenticate to Redis using the old &quot;AUTH &lt;pass&gt;&quot;# method. When also an username is provided, it will use &quot;AUTH &lt;user&gt; &lt;pass&gt;&quot;.# In the Redis servers side, the ACL to provide just minimal access to# Sentinel instances, should be configured along the following lines:## user sentinel-user &gt;somepassword +client +subscribe +publish \\# +ping +info +multi +slaveof +config +client +exec on# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;## Number of milliseconds the master (or any attached replica or sentinel) should# be unreachable (as in, not acceptable reply to PING, continuously, for the# specified period) in order to consider it in S_DOWN state (Subjectively# Down).## Default is 30 seconds.sentinel down-after-milliseconds mymaster 30000# IMPORTANT NOTE: starting with Redis 6.2 ACL capability is supported for# Sentinel mode, please refer to the Redis website https://redis.io/topics/acl# for more details.# Sentinel&#x27;s ACL users are defined in the following format:## user &lt;username&gt; ... acl rules ...## For example:## user worker +@admin +@connection ~* on &gt;ffa9203c493aa99## For more information about ACL configuration please refer to the Redis# website at https://redis.io/topics/acl and redis server configuration # template redis.conf.# ACL LOG## The ACL Log tracks failed commands and authentication events associated# with ACLs. The ACL Log is useful to troubleshoot failed commands blocked # by ACLs. The ACL Log is stored in memory. You can reclaim memory with # ACL LOG RESET. Define the maximum entry length of the ACL Log below.acllog-max-len 128# Using an external ACL file## Instead of configuring users here in this file, it is possible to use# a stand-alone file just listing users. The two methods cannot be mixed:# if you configure users here and at the same time you activate the external# ACL file, the server will refuse to start.## The format of the external ACL user file is exactly the same as the# format that is used inside redis.conf to describe users.## aclfile /etc/redis/sentinel-users.acl# requirepass &lt;password&gt;## You can configure Sentinel itself to require a password, however when doing# so Sentinel will try to authenticate with the same password to all the# other Sentinels. So you need to configure all your Sentinels in a given# group with the same &quot;requirepass&quot; password. Check the following documentation# for more info: https://redis.io/topics/sentinel## IMPORTANT NOTE: starting with Redis 6.2 &quot;requirepass&quot; is a compatibility# layer on top of the ACL system. The option effect will be just setting# the password for the default user. Clients will still authenticate using# AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;# if they follow the new protocol: both will work.## New config files are advised to use separate authentication control for# incoming connections (via ACL), and for outgoing connections (via# sentinel-user and sentinel-pass) ## The requirepass is not compatable with aclfile option and the ACL LOAD# command, these will cause requirepass to be ignored.# sentinel sentinel-user &lt;username&gt;## You can configure Sentinel to authenticate with other Sentinels with specific# user name. # sentinel sentinel-pass &lt;password&gt;## The password for Sentinel to authenticate with other Sentinels. If sentinel-user# is not configured, Sentinel will use &#x27;default&#x27; user with sentinel-pass to authenticate.# sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;## How many replicas we can reconfigure to point to the new replica simultaneously# during the failover. Use a low number if you use the replicas to serve query# to avoid that all the replicas will be unreachable at about the same# time while performing the synchronization with the master.sentinel parallel-syncs mymaster 1# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;## Specifies the failover timeout in milliseconds. It is used in many ways:## - The time needed to re-start a failover after a previous failover was# already tried against the same master by a given Sentinel, is two# times the failover timeout.## - The time needed for a replica replicating to a wrong master according# to a Sentinel current configuration, to be forced to replicate# with the right master, is exactly the failover timeout (counting since# the moment a Sentinel detected the misconfiguration).## - The time needed to cancel a failover that is already in progress but# did not produced any configuration change (SLAVEOF NO ONE yet not# acknowledged by the promoted replica).## - The maximum time a failover in progress waits for all the replicas to be# reconfigured as replicas of the new master. However even after this time# the replicas will be reconfigured by the Sentinels anyway, but not with# the exact parallel-syncs progression as specified.## Default is 3 minutes.sentinel failover-timeout mymaster 180000# SCRIPTS EXECUTION## sentinel notification-script and sentinel reconfig-script are used in order# to configure scripts that are called to notify the system administrator# or to reconfigure clients after a failover. The scripts are executed# with the following rules for error handling:## If script exits with &quot;1&quot; the execution is retried later (up to a maximum# number of times currently set to 10).## If script exits with &quot;2&quot; (or an higher value) the script execution is# not retried.## If script terminates because it receives a signal the behavior is the same# as exit code 1.## A script has a maximum running time of 60 seconds. After this limit is# reached the script is terminated with a SIGKILL and the execution retried.# NOTIFICATION SCRIPT## sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;# # Call the specified notification script for any sentinel event that is# generated in the WARNING level (for instance -sdown, -odown, and so forth).# This script should notify the system administrator via email, SMS, or any# other messaging system, that there is something wrong with the monitored# Redis systems.## The script is called with just two arguments: the first is the event type# and the second the event description.## The script must exist and be executable in order for sentinel to start if# this option is provided.## Example:## sentinel notification-script mymaster /var/redis/notify.sh# CLIENTS RECONFIGURATION SCRIPT## sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;## When the master changed because of a failover a script can be called in# order to perform application-specific tasks to notify the clients that the# configuration has changed and the master is at a different address.# # The following arguments are passed to the script:## &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;## &lt;state&gt; is currently always &quot;failover&quot;# &lt;role&gt; is either &quot;leader&quot; or &quot;observer&quot;# # The arguments from-ip, from-port, to-ip, to-port are used to communicate# the old address of the master and the new address of the elected replica# (now a master).## This script should be resistant to multiple invocations.## Example:## sentinel client-reconfig-script mymaster /var/redis/reconfig.sh# SECURITY## By default SENTINEL SET will not be able to change the notification-script# and client-reconfig-script at runtime. This avoids a trivial security issue# where clients can set the script to anything and trigger a failover in order# to get the program executed.sentinel deny-scripts-reconfig yes# REDIS COMMANDS RENAMING## Sometimes the Redis server has certain commands, that are needed for Sentinel# to work correctly, renamed to unguessable strings. This is often the case# of CONFIG and SLAVEOF in the context of providers that provide Redis as# a service, and don&#x27;t want the customers to reconfigure the instances outside# of the administration console.## In such case it is possible to tell Sentinel to use different command names# instead of the normal ones. For example if the master &quot;mymaster&quot;, and the# associated replicas, have &quot;CONFIG&quot; all renamed to &quot;GUESSME&quot;, I could use:## SENTINEL rename-command mymaster CONFIG GUESSME## After such configuration is set, every time Sentinel would use CONFIG it will# use GUESSME instead. Note that there is no actual need to respect the command# case, so writing &quot;config guessme&quot; is the same in the example above.## SENTINEL SET can also be used in order to perform this configuration at runtime.## In order to set a command back to its original name (undo the renaming), it# is possible to just rename a command to itself:## SENTINEL rename-command mymaster CONFIG CONFIG# HOSTNAMES SUPPORT## Normally Sentinel uses only IP addresses and requires SENTINEL MONITOR# to specify an IP address. Also, it requires the Redis replica-announce-ip# keyword to specify only IP addresses.## You may enable hostnames support by enabling resolve-hostnames. Note# that you must make sure your DNS is configured properly and that DNS# resolution does not introduce very long delays.#SENTINEL resolve-hostnames no# When resolve-hostnames is enabled, Sentinel still uses IP addresses# when exposing instances to users, configuration files, etc. If you want# to retain the hostnames when announced, enable announce-hostnames below.#SENTINEL announce-hostnames no 测试我们目前状态是一主二从 在/use/local/bin/kconf/中配置哨兵配置文件 sentinel.conf 123# sentinel monitor 被监控的名称 host port 1 sentinel monitor myredis 192.168.10.102 6379 1 # 后面的数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机 启动哨兵 启动成功哨兵进程监听，它会监听所有redis端口 1redis-sentinel /usr/local/bin/kconfig/sentinel.conf 监听端口，发现master端口挂了，自动切换从机为主机 将原master恢复，切换原master为新master的从机 从机自动选举成为主机后，sentinel/conf中对主机的监听端口也会从原主机转成新主机 二十六、Redis缓存穿透和雪崩Redis缓存的使用，极大的提高了应用程序的性能和效率，特别是数据查询方面，但同时，它也带来了一些问题，其中，最要害的问题，就是数据的一致性问题，从严格意义上上讲，这个问题无解，如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前业界有都有比较流行的解决方案。 缓存穿透（缓存、DB无数据） 概念 缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 解决方案 布隆过滤器 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力； 缓存空对象 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源； 但是这种方法存在两个问题 如果空值 能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多空值的键； 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 设置可访问名单（白名单） 使用bitmaps类型定义一个可以访问额名单，名单id作为bitmaps的偏移量，每次访问和bitmaps里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。 进行实时监控 当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置给名单限制服务 缓存击穿（量太大，缓存过期） 概述 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一点进行访问，当这个key在失效的瞬间，持续的大并发就穿透缓存，直接请求数据库，就像在一个屏障上凿开了一个洞； 当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且会写缓存，会导致数据库瞬间压力过大。 解决方案 设置热点数据永不过期 从缓存层来看，没有设置过期时间，所有不会出现热点key过期后产生的问题。 加互斥锁 分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可，这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。 缓存雪崩 概念 缓存雪崩，是指在某一个时间段，缓存集中过期失效 产生雪崩的原因之一，比如在写文本的时候，马上就要到双十一零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时，到了凌晨一点的时候，这批商品的缓存就要过期了，二队这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力峰值，于是所有的请求都好到达存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 其实集中过期，倒不是非常致命的，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网，因而自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的，无非就是对数据库产生周期性的压力，而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 设置过期标志更新缓存 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存 将缓存失效时间分散开 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件 二十七、分布式锁使用setnx来实现12setnx users 20 # 上锁expire users 10 # 设置过期时间，防止用户没有释放锁导致出现死锁 如果上锁之后突然出现异常，无法设置过期时间 解决：上锁同时设置过期时间 1set users 10 nx ex 12 测试 1234567891011121314151617181920212223242526272829public String testLock()&#123; //获取锁 Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,&quot;111&quot;,3,TimeUnit.SECONDS); //获取锁成功，查询num的值 if(lock)&#123; Object value = redisTemplate.opsForValue().get(&quot;num&quot;); //判断num为空return if(StringUtils.isEmpty(value))&#123; return null; &#125; //有键值就转成int int num = Integer.parseInt(value + &quot;&quot;); //把redis的num加1 redisTemplate.opsForValue().set(&quot;num&quot;, ++num); //释放锁，del redisTemplate.delete(&quot;lock&quot;); return num + &quot;&quot;; &#125;else&#123; try &#123; Thread.sleep(100); testLock(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 其中： 1redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,&quot;111&quot;,3,TimeUnit.SECONDS); 参数值的过期设置不宜过短，至少要比手动释放锁所花费的时间长，也不宜过长，会导致长时间阻塞，严重影响性能 使用并发性能测试工具ab并发访问 1[root@localhost]# ab -n 1000 -c 100 http://192.168.56.1:8080/testLock 这种锁机制存在的问题（优化uuid防误删） 比如a方先上锁，b方等待a方释放，a上完锁未释放时，出现服务器卡顿导致锁自动释放，此时在等待的b会获取到锁，而a代码未执行完，会手动再去释放b的锁，可能导致不可预料的后果 解决方案 获取锁的时候设置锁的value值为uuid，每次释放锁之前先判断是否是自己的锁，避免出现释放别人锁的情况 1234567891011121314String uuid = UUID.randomUUID().toString();Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,uuid,3,TimeUnit.SECONDS);//.....//判断uuid值是否一样Object lockUuid = redisTemplate.opsForValue().get(&quot;lock&quot;);if(lockUuid.equals(uuid))&#123; redisTemplate.delete(&quot;lock&quot;);&#125; 该方案还是不能做到原子性，即仍然存在隐患：即当a释放锁的时候，这时刚好锁过期，这时b获取到了锁，但a恰好也把b的锁也释放了，所以要彻底解决事件隔离，需要内嵌使用lua 来释放锁，因为lua 具有原子性操作 解决方案 1234567891011121314151617181920212223String uuid = UUID.randomUUID().toString();String skuId = &quot;25&quot;;String locKey = &quot;lock&quot; + skuId;//获取锁Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey,uuid,3,TimeUnit.SECONDS);//....//使用lua脚本释放锁//定义lua脚本String script = &quot;if redis.call(&#x27;get&#x27; , KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27; , KEYS[1]) else &quot; + &quot;return 0 end&quot;;//使用redis执行lua脚本DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();redisScript.setScriptText(script);//设置一下返回值类型 为 Long//因为删除判断的时候，返回的是0，给其封装为数据类型，如果不封装那么默认返回String类型，//那么返回字符串与0 会有发生错误redisScript.setResultType(Long.class);//第一个要是script脚本，第二个需要判断的key，第三个就是key所对应的值redisTemplate.execute(redisScript , Arrays.asList(locKey) , uuid); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public String testLuaLock()&#123; String uuid = UUID.randomUUID().toString(); String skuId = &quot;25&quot;; String locKey = &quot;lock&quot; + skuId; //获取锁 Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey,uuid,3,TimeUnit.SECONDS); //获取锁成功，查询num的值 if(lock)&#123; Object value = redisTemplate.opsForValue().get(&quot;num&quot;); //判断num为空return if(StringUtils.isEmpty(value))&#123; return null; &#125; //有键值就转成int int num = Integer.parseInt(value + &quot;&quot;); //把redis的num加1 redisTemplate.opsForValue().set(&quot;num&quot;, ++num); //释放锁，del /* //判断uuid值是否一样 Object lockUuid = redisTemplate.opsForValue().get(&quot;lock&quot;); if(lockUuid.equals(uuid))&#123; redisTemplate.delete(&quot;lock&quot;); &#125;*/ //使用lua脚本释放锁 //定义lua脚本 String script = &quot;if redis.call(&#x27;get&#x27; , KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27; , KEYS[1]) else &quot; + &quot;return 0 end&quot;; //使用redis执行lua脚本 DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(); redisScript.setScriptText(script); //设置一下返回值类型 为 Long //因为删除判断的时候，返回的是0，给其封装为数据类型，如果不封装那么默认返回String类型， //那么返回字符串与0 会有发生错误 redisScript.setResultType(Long.class); //第一个要是script脚本，第二个需要判断的key，第三个就是key所对应的值 redisTemplate.execute(redisScript , Arrays.asList(locKey) , uuid); return num + &quot;&quot;; &#125;else&#123; try &#123; //其他线程等待 Thread.sleep(100); testLuaLock(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 二十八、RedisUtil工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593package com.zhkucst.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.Collection;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * Redis 工具类 * * @author FYP * * @data 2021年6月13日 */@Componentpublic class RedisUtil &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; //======================common============================ /** * 指定缓存失效时间 * @param key 键 * @param time 时间（秒） * @return */ public boolean expire(String key, long time)&#123; try&#123; if(time &gt; 0)&#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125;catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间（秒） 返回0 代表为永久有效 */ public long getExpire(String key)&#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * @param key 键 * @return true 存在 false 不存在 */ public boolean hasKey(String key)&#123; try&#123; return redisTemplate.hasKey(key); &#125;catch(Exception e)&#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(&quot;unchecked&quot;) public void del(String... key)&#123; if(key != null &amp;&amp; key.length &gt; 0)&#123; if(key.length == 1)&#123; redisTemplate.delete(key[0]); &#125;else&#123; redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)); &#125; &#125; &#125; //======================String============================ /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key)&#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** *普通缓存放入 * @param key 键 * @param value 值 * @return true 成功 false 失败 */ public boolean set(String key, Object value)&#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间（秒） time 要大于 等于 0,将设置无限制 * @return true 成功 false 失败 */ public boolean set(String key, Object value, long time)&#123; try &#123; if(time &gt; 0)&#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125;else&#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * @param key 键 * @param delta △,增量（大于0） * @return 增量后的返回值 */ public long incr(String key, long delta)&#123; if(delta &lt; 0)&#123; throw new RuntimeException(&quot;递增因子必须大于0&quot;); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递增 * @param key 键 * @param delta △,减量（小于0） * @return 减量后的返回值 */ public long decr(String key, long delta)&#123; if(delta &lt; 0)&#123; throw new RuntimeException(&quot;递减因子必须大于0&quot;); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; //======================Map============================ /** * HashGet * @param key 键 不能能null * @param item 值 不能能null * @return */ public Object hget(String key, String item)&#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个 k-v对 */ public Map&lt;Object, Object&gt; hmget(String key)&#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 向一张hash表中放入数据，如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false 失败 */ public boolean hset(String key, String item, Object value)&#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据，如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间（秒）注意：如果已存在的hash表有时间，这里将会替换原有的时间 * @return true 成功 false 失败 */ public boolean hset(String key, String item, Object value, long time)&#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if(time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet * @param key 键 * @param map 对应多个k-v对 * @return */ public boolean hmset(String key, Map&lt;String, Object&gt; map)&#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个k-v对 * @param time 时间（秒） * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time )&#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if(time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以是多个 不能为 null */ public void hdel(String key, Object item)&#123; redisTemplate.opsForHash().delete(key, item); &#125; /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 值 不能为null * @return true 存在 false 不存在 */ public boolean hHasKey(String key, String item)&#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash 递增 如果不存在，就会创建一个 并把新增后的值返回 * @param key 键 * @param item 值 * @param by 要增加几（大于0） * @return */ public double hincr(String key, String item, double by)&#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash 递减 如果不存在，就会创建一个 并把新增后的值返回 * @param key 键 * @param item 值 * @param by 要减少几（大于0） * @return */ public double hdecr(String key, String item, double by)&#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; //======================Set============================ /** * 根据key 获取 Set 中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询。是否存在 * @param key 键 * @param value 值 * @return true 存在 false 不存在 */ public boolean sHasKey(String key, Object value)&#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values)&#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将 set 数据放入缓存 * @param key 键 * @param time 时间（秒） * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values)&#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if(time &gt; 0)&#123; expire(key, time); &#125; return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key)&#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为 value的 元素 * @param key 键 * @param values 值 可以是多个 * @return */ public long setRemove(String key, Object... values)&#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; //======================List============================ /** * 获取llist缓存的内容 * @param key 键 * @param start 开始 * @param end 结束，结束 0 到 -1 代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end)&#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * @param key 键 * @return 返回长度 */ public long lGetListSize(String key)&#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list 中的值 * @param key 键 * @param index 索引 index &gt;= 0时， 表头，1 第二个元素，依次类推 index &lt; 0时， -1 表尾， -2 倒数第二个元素， 依次类推 * @return */ public Object lGetIndex(String key, long index)&#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value)&#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间（秒） * @return */ public boolean lSet(String key, Object value,long time)&#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if(time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param values 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; values)&#123; try &#123; redisTemplate.opsForList().rightPushAll(key, values); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param values 值 * @param time 时间（秒） * @return */ public boolean lSet(String key, List&lt;Object&gt; values, long time)&#123; try &#123; redisTemplate.opsForList().rightPushAll(key, values); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value)&#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * @param key 键 * @param count 移除个数 * @param value 值 * @return 真正移除的个数 */ public long lRemove(String key, long count, Object value)&#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125;&#125; 二十九、存数据转义符问题Redis客户端格式：从客户端存放key值时 12345# 存值set k1 v1# 取值get k1&quot;v1&quot; # 非字符串格式 k1是字符串类型，v1（非字符串类型、非json格式） 需使用以下格式，才可以与jedis连通 12345# 存值set k1 &#x27;&quot;v1&quot;&#x27;# 取值get k1&quot;\\&quot;v1\\&quot;&quot; #字符串格式 redisConfig标准配置json格式： 三十、Redis新功能新功能推出用户权限，更高的安全机制 1acl list # 查看用户操作权限 1hacl cat string # 查看添加指令类别 1acl setuser user1 # 添加用户 IO多线程 Redis终于支持多线程了，告别单线程了吗？ IO多线程其实指客户端交互部分的网络 IO 交互处理模块多线程，而非执行命令多线程，Redis执行命令依然是单线程 原理架构 Redos 6 加入多线程，但跟Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis的多线程部分只是用来处理网络数据的读写和解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制key、lua、事务，LPUSH、LPOP等等的并发问题。 12io-threads-do-reads yes # 默认关闭io-threads 4\\ 工具支持cluster 之前的老版本Redis需要搭建集群需要单独安装ruby环境，Redis5将redis-trib.rb的功能集成到redis-cli。另外官方redis-benchmark工具也开始支持cluster模式了，通过多线程的方式对多个分片进行压测 三十一、springboot整合Redis集群引入依赖 123456789101112131415161718&lt;!-- 引入 redis 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; redis.properties 1234567891011121314151617181920212223242526272829303132333435363738394041# 单机# Redis数据库索引（默认为0）# redis.database=1# Redis服务器地址# redis.host=localhost# Redis服务器连接端口# redis.port=6379#集群# Redis服务器集群配置redis.nodes=localhost:6379,localhost:6380,localhost:6381,localhost:6389,localhost:6390,localhost:6391# Redis服务器连接密码（默认为空）redis.password=redis#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal#redis.maxActive=600#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性redis.maxTotal=2000# 出现配置不能反射Total是因为springboot版本# 连接池最大阻塞等待时间（使用负值表示没有限制）redis.maxWaitMillis=1000# 连接池中的最大空闲连接redis.maxIdle=100# 连接池中的最小空闲连接redis.minIdle=2# 连接超时时间（毫秒）redis.timeout=0 redis配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.tony.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.data.redis.connection.RedisClusterConfiguration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.connection.RedisNode;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;import java.util.HashSet;@Configuration@PropertySource(&quot;classpath:onf/redis.properties&quot;)public class RedisConfig &#123; @Value(&quot;$&#123;redis.password&#125;&quot;) private String password; @Value(&quot;$&#123;redis.maxTotal&#125;&quot;) private Integer maxTotal; @Value(&quot;$&#123;redis.maxWaitMillis&#125;&quot;) private Integer maxWaitMillis; @Value(&quot;redis.maxIdle&quot;) private Integer maxIdle; @Value(&quot;$&#123;redis.minIdle&#125;&quot;) private Integer minIdle; @Value(&quot;$&#123;redis.timeout&#125;&quot;) private Integer timeout; @Value(&quot;$&#123;redis.nodes&#125;&quot;) private String clusterNodes; @Bean public RedisClusterConfiguration redisClusterConfiguration()&#123; RedisClusterConfiguration redisClusterConfiguration = new RedisClusterConfiguration(); String[] cNodes = clusterNodes.split(&quot;,&quot;); HashSet&lt;RedisNode&gt; nodes = new HashSet&lt;&gt;(); //分配集群节点 for(String node : cNodes)&#123; String[] hp = node.split(&quot;:&quot;);//host:port nodes.add(new RedisNode(hp[0], Integer.parseInt(hp[1]))); &#125; redisClusterConfiguration.setClusterNodes(nodes); return redisClusterConfiguration; &#125; @Bean public JedisPoolConfig jedisPoolConfig()&#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(maxTotal); jedisPoolConfig.setMaxWaitMillis(maxWaitMillis); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMinIdle(minIdle); jedisPoolConfig.setTestOnCreate(true); jedisPoolConfig.setTestOnBorrow(true); jedisPoolConfig.setTestOnReturn(true); jedisPoolConfig.setTestWhileIdle(true); //创建集群对象 return jedisPoolConfig; &#125; @Bean(&quot;myJedisConnectionFactory&quot;) public JedisConnectionFactory jedisConnectionFactory(RedisClusterConfiguration redisClusterConfiguration, JedisPoolConfig jedisPoolConfig)&#123; JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory((redisClusterConfiguration, jedisPoolConfig); jedisConnectionFactory.setTimeout(timeout); jedisConnectionFactory.setPassword(password); return jedisConnectionFactory; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(@Qualifier(&quot;myJedisConnectionFactory&quot;) RedisConnectionFactory redisConnectionFactory) &#123; //一般使用&lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); //json序列化设置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); //String序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); //key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); //hash的key采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); //value采用json的序列化方式 template.setValueSerializer(jackson2JsonRedisSerializer); //hash的value采用json序列化方式 template.setHashValueSerializer(jackson2JsonRedisSerializer); //其他未自定义的属性通过该方法配置默认的PropertiesSet template.afterPropertiesSet(); return template; &#125;&#125;","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库、Redis","slug":"数据库、Redis","permalink":"http://fyupeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81Redis/"}],"author":"fyupeng"},{"title":"MySQL 优化","slug":"MySQL优化","date":"2022-06-25T07:23:24.000Z","updated":"2022-06-25T07:30:26.774Z","comments":true,"path":"2022/06/25/MySQL优化/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/MySQL%E4%BC%98%E5%8C%96/","excerpt":"","text":"一、 索引优化和语句优化1. 索引优化 索引是一种数据结构，能加快数据库的查询速度 索引类型包括：聚集索引、覆盖索引、组合索引、前缀索引、唯一索引 默认使用索引：B+树（多路搜索树）结构索引 1.1 执行计划汇中的 type system 一个表一条记录 const 常量匹配，仅匹配一条记录 eq_ref 唯一性索引扫描 对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。 ref 非唯一性索引扫描 返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。 range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引。 index 全索引扫描 all 全表扫描 2. 语句优化 查询语句不使用 select * 查询开销大 增加 IO 操作 失去“覆盖索引”优化器的可能性 可读性差 尽量减少子查询，使用关联查询（left join,right join,inner join）替代 子查询要查询两次 关联查询是先建立临时表，将多个表关联起来，再查询一次，效率要比子查询高 减少使用IN 或者 NOT IN，使用 exist，not exist 或者关联查询语句代替 IN 或 NOT IN 适合子表数据比较小，exist 和 not exist 适合子表数据比较大 IN 和 NO INT 是先对两个表缓存数据，再笛卡尔积查询，属于内存查询 exist 和 not exist 是查询数据库消耗性能更高 or 的查询尽量用 union 或者 union all代替，union all有重复情况,union 会消除重复情况 or 查询时，查询条件出现非索引列，存在索引的查询列会失效 使用 union 有索引列的用索引查询，没有索引列的 正常查询 尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将 引擎放弃使用索引而进行全表扫描 尽量避免在where 字句中对 字段进行 null 值判断，否则将导致 引擎放弃索引进行全表扫描 2.1 多表优化 小表驱动大表，效率要比大表驱动小表高 频繁查询的字段加上索引 2.2 避免索引失效 复合索引，不要跨列或无序使用 复合索引，尽量使用全索引匹配 对索引进行函数、计算、类型转换 复合索引不能使用不等于 (!= &lt;&gt;) 或 is null (is not null) ，否则自身以及右侧全部索引失效 使用索引范围查询有sql优化器干预，索引有概率失效，尽量使用索引覆盖 like 尽量以常量开头不要以 ‘%’开头，否则索引失效 尽量不要使用or ，否则索引失效 3. 其他优化3.1 exist 和 in 如果主查询的数据集大，则使用In 如果子查询的数据集大，则使用exist exist 语法：将主查询查询的结果，放到子查询结果中进行条件校验，看子查询中是否有数据，如果有数据，则校验成功 ​ 如果符合校验，则保留数据 in 语法：先子查询，然后结果给主查询，子查询会缓存起来 3.2 order byusing filesort 有两种算法：双路排序、单路排序（根据 IO 次数) MySQL 4.1之前 默认使用 双路排序：双路：扫描2次磁盘（1：从磁盘读取排序字段，对排序进行排序 2：扫描其他字段） —— IO 较消耗性能 MySQL 4.1 之后 默认使用 单路排序：只读取一次（全部字段），在buffer 中进行排序。但此种单路排序会有一定隐患（不一定真的是“单路 | 一次IO”，有可能对次） 注意：单路排序比双路排序占用更多的buffer 单路排序在使用时，如果数据量大，可以考虑调大 buffer 的容量大小：set max_length_for_sort_data = 1024 如果 max_length_for_sort_data 值太低，则 mysql 会自动从 单路-&gt;双路 (太低：需要排序的列的总大小超过了 max_length_for_sort_data 定义的字节数) 原因：如果数据量特别大，则无法 将所有字段的数据 一次性读取完毕，因此会进行 “分片读取、多次读取” 提高 order by 查询的策略： 选择使用单路、双路，调整buffer 的容量大小 避免select * … 复合索引 不要跨列使用，出现 using filesort 二、锁和死锁1. 锁：乐观锁：通过版本号控制，查询时获取版本号，提交时比较版本号 悲观锁：基于数据库的锁机制，真正保证数据访问的排他性 1.1 造成死锁的必要条件： 互斥条件 请求与保持 不剥夺条件 循环等待 1.2 锁升级锁升级也是跟索引挂钩的，InnoDB 是使用的行锁，但在操作时很容易升级为表锁 InnoDB 的行锁是加在索引上的，操作不走锁引，也就是 where 条件不是索引列，则会升级锁 有索引查询，说明要操作的数据在索引上已经确定了，只要锁住 索引条件的记录，加行锁 无索引查询，说明是要全表查询，并不能保证要查询的记录有其他事务要去操作，所以升级为表锁 非唯一索引记录超过一定数量时，查询语句优化时会选择不走索引，从而造成索引失效，行锁也会升级为表锁 1.3 解决死锁： 查询时使用索引条件，避免因查询优化导致锁失效或不使用索引条件查询，从而出现锁升级为表锁 合理设计索引，行锁都是加在索引上的，尽量缩小锁的范围 尽可能使用低级别的事务隔离机制 尽量减少查询条件的范围，尽量避免间隙锁或缩小间隙锁的范围 设置按照同一顺序访问资源，类似于串行执行 2. 表锁的操作mysql 要使用表锁，mysql 引擎 Myisam 使用的就是 表锁，但不支持事务，没有提交这说法 2.1 查看加锁的表1show open tables; 2.2 加读锁 当前session回话： 123lock table tablelock read;select * from tablelock; -- 读（查）允许delete from tablelock where id = 1; -- 写（增删改）不允许 1ERROR 1099 (HY000): Table &#x27;tablelock&#x27; was locked with a READ lock and can&#x27;t be updated 12select count(1) emp; -- 不允许delete from emp where id = 1; -- 不允许 1ERROR 1100 (HY000): Table &#x27;emp&#x27; was not locked with LOCK TABLES 其他session会话： 12select * from tablelock; -- 读（查）允许delete from tablelock where id = 1; -- 写（增删改）等待直到锁释放 12select * from dept; -- 读允许delete from emp where eno = 1; -- 写允许 总结： 获得读锁的会话只能对锁本身的表可以读操作，不允许写操作 获得锁的会话不允许对其他表读写操作 其他会话对锁本身的表可以读操作，写等待 其他会话对其他表可以读写操作 2,.3 加写锁当前会话： 123lock table tablelock write;select * from tablelock; -- 允许读insert into tablelock(name) values(&#x27;a6&#x27;); -- 允许写 12select * from dept; -- 读不允许delete from dept where dno = 1; -- 写不允许 1ERROR 1100 (HY000): Table &#x27;dept&#x27; was not locked with LOCK TABLES 其他会话： 12select * from tablelock; -- 读等待delete from tablelock where id = 2; -- 写等待 12select * from dept; -- 读允许delete from emp where eno = 1; -- 写允许 总结： 获得读锁的会话只能对锁本身的表读写操作 获得锁的会话不允许对其他表读写操作 其他会话对锁本身的表读写等待 其他会话对其他表可以读写操作 2.4 释放锁1unlock tables; 2.5 分析表锁定分析表锁定严重程度： 1show status like &#x27;table%&#x27;; 123456789+----------------------------+-------+| Variable_name | Value |+----------------------------+-------+| Table_locks_immediate | 5 | -- 可以立即获取表锁请求的次数| Table_locks_waited | 0 | -- 不能立即获取表锁请求而且需要等待的次数，数值越大，说明存在越大的竞争，优化请求| Table_open_cache_hits | 0 || Table_open_cache_misses | 0 || Table_open_cache_overflows | 0 |+----------------------------+-------+ 官方文档：https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html 一般建议：Table_locks_immediate / Table_locks_waited &gt; 5000，建议采用 InnoDB 引擎，否则 MyISAM 引擎 3. 行锁的操作mysql 默认使用 InnoDB 引擎，而InnoDB 使用的是行锁，事务默认会自动提交，分析行锁，需要关闭自动提交 1set autocommit=0; 3.1 读操作1select * from linelock; 一个会话关联一个事务，也就是说，打开了一个会话窗口，就是开启了一个事务 其他事务在该事务期间提交的数据都是不可见的，这就是事务默认级别的可重复读，就是会读到历史记录 3.2 写操作当前会话： 12insert into linelock(name) values(&#x27;7a&#x27;); -- 写操作rollback; -- 等其他会话写操作后 其他会话： 1select * from linelock; -- 允许读操作 注意：读当前会话刚插入的数据时其他会话是不可见的，因为未提交 12update linelock set name=&#x27;77&#x27; where id = 8; -- 行上锁，等待写操作,直到当前会话commit/rollbackupdate linelock set name=&#x27;77&#x27; where id = 6; -- 其他行允许写操作 总结（默认可重复读级别）： 当前会话读操作，不会出现脏读和不可重复读，可能导致读取到历史记录 当前会话写操作，其他会话写等待，会出现丢失更新（回滚/覆盖）、幻读 select 就是快照读，快照读不加锁，不会产生幻读，MVCC 机制 select for update、insert、update、delete 都是当前读，当前读会产生幻读，数据库角度不会产生丢失更新，应用逻辑会产生丢失更新 可重复读级别下，两个事务同时查询一条数据，第一个事务先更新并提交，第二个事务由于是快照读，会读到历史数据，但更新是属于当前读，更新条件是当前最新数据，所以更新失败 可重复读级别下，两个事务同时查询一条数据，两个事务同时更新该数据，后更新的数据会阻塞，直到先更新的事务提交，后一个事务才会更新，但后提交的事务由于发生阻塞，又因为更新是当前读，所以更新条件是当前最新数据，更新失败 3.3 查询行锁将自动提交关闭 123456-- 第一种 方法set autocommit=0;-- 第二种 方法start transaction;-- 第三种 方法begin; 通过 for update 给查询 加行锁 1select * from linklock where id = 2 for update; 总结： 如果查询的数据时通过 id很明确的，则使用的是 行锁 如果查询条件不包含主键也不明确，这个时候会锁住整个表，使用的是 next-lock (行锁 + 间隙锁) 另外补充: update、insert、delete 这种操作 也是使用了 next-lock 机制 next-lock 机制 只会 让写操作 锁住整个表，对于 读操作不影响 3.4 分析行锁行锁分析： 1show status like &#x27;%innodb_row_lock%&#x27;; 123456789+-------------------------------+--------+| Variable_name | Value |+-------------------------------+--------+| Innodb_row_lock_current_waits | 0 | -- 当前正在等待锁的数量| Innodb_row_lock_time | 177608 | -- 等待总时长，从系统启动到现在 一共等待的时间| Innodb_row_lock_time_avg | 11840 | -- 平均等待时长，从系统启动到现在平均等待的时间| Innodb_row_lock_time_max | 51004 | -- 最大等待时长，从系统启动到现在最大一次等待的时间| Innodb_row_lock_waits | 15 | -- 等待次数，从系统启动到现在一共等待的次数+-------------------------------+--------+ 4. 可重复读原理用到的原理就是 MVCC (多版本并发控制机制) 关于 readView、undo log、redo log undo log 包含两个隐含域：事务id和回滚point（指向undo log），是一种链表的数据结构 readView 包含一个事务数组、最大事务id、最小事务id、当前事务id 如果 trx_id &lt; min_trx_id，则说明该版本对于当前事务(read view)来说，是已提交事务生成的，那么对于当前事务可见。 如果trx_id &gt;= max_trx_id：则说明该版本对于当前事务(read view)来说，是”将来”的事务生成的，那么对于当前事务不可见。 如果min_trx_id &lt;= trx_id &lt; max_trx_id： 如果trx_id在read view的活跃事务id列表中，则说明该版本对于当前事务(read view)来说，是已开始但未提交的事务生成的，那么对于当前事务不可见。 如果trx_id不在read view的活跃事务id列表中，则说明该版本对于当前事务(read view)来说，是已提交的事务生成的，那么对于当前事务可见。 三、 慢查询日志和海量数据分析MySQL提供一种日志记录，用于记录MYSQL 响应时间超过阈值的SQL 语句 (slow_query_log) 1. 慢查询日志：慢查询日志默认关闭，建议：开发调优时打开，最终部署时关闭 1.1 开启慢查询日志：检查是否开启了 慢查询日志：show variables like ‘slow_query_log’ 临时开启：set global slow_query_log = 1 永久开启：/etc/my.cnf 中追加配置： 1234vim /etc/my.cnf[mysqld]slow_query_log=1slow_query_log_file=/var/lib/mysql/localhost-slow.log 1.2 设置慢查询阈值： 临时设置阈值：set global long_query_time=5 永久设置阈值：/etc/my.cnf 中追加配置： 123vim /etc/my.cnf[mysqld]long_query_time=3 1.3 查询超过阈值sql查询超过阈值的SQL数：show global status like ‘%slow_queries%’; 查询慢查询的sql: cat /var/lib/mysql/localhost-slow.log 通过mysqldumpslow工具查询慢sql s：排序方式 r：逆序 l：锁定时间 g：正则匹配模式 123456-- 获取返回记录最多的 3 个sqlmysqldumslow -s r -t 3 /var/lib/myqsl/localhost-slow.log-- 获取访问次数最多的 3 个sqlmysqldumslow -s c -t 3 /var/lib/myqsl/localhost-slow.log-- 按照时间排序，前10条包含 left join 查询语句的 SQLmysqldumslow -s t -t 10 -g &quot;left join&quot; /var/lib/myqsl/localhost-slow.log 2. 海量数据分析2.1 解决开启过程函数与慢查询日志冲突： 临时解决：set global log_bin_trust_function_creators=1 永久解决：/etc/my.cnf 中追加配置： 123vim /etc/my.cnf[mysqld]log_bin_trust_function_creators=1 2.2 使用存储过程插入海量元素：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061create table dept( dno int(5) primary key default 0, dname varchar(20) not null default &#x27;&#x27;, loc varchar(30) default &#x27;&#x27;) engine=innodb default charset=utf8;create table emp( eid int(5) primary key, ename varchar(20) not null default &#x27;&#x27;, job varchar(20) not null default &#x27;&#x27;, deptno int(5) not null default 0) engine=innodb default charset=utf8;delimiter $create function randstring(n int) returns varchar(255)begin declare all_str varchar(100) default &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIZKLMNOPQRSTUVWXYZ&#x27;; declare return_str varchar(255) default &#x27;&#x27;; declare i int default 0; while i &lt; n do set return_str = concat(return_str, substring(all_str, floor(1+rand()*52), 1)); set i = i+1; end while; return return_str;end $create function rand_num() returns INT(5)begin declare i int default 0; set i = floor(rand()*100); return i;end $create procedure insert_emp(in eid_start int(10), in data_times int(10))begin declare i int default 0; set autocommit = 0; repeat insert into emp values(eid_start + i,randstring(5),&#x27;other&#x27;,ran_num()); set i = i+1; until i=data_times end repeat; commit;end $create procedure insert_dept(in dno_start int(10), in data_times int(10))begin declare i int default 0; set autocommit = 0; repeat insert into dept values(dno_start + i,randstring(6), randstring(8)); set i = i+1; until i=data_times end repeat; commit;end $call insert_emp(1000,800000);call insert_dept(10,30); 2.3 分析海量数据：profilesshow variables like ‘%profiling%’; set profiling = on （1）profiles show profiles; – 记录所有 profiling 打开之后的， 全部SQL 查询语句所花费的时间 （2）精确分析：sql诊断 12show profile all for query [上一步查询的 Query_id]show profile cpu,block io for query 2; （3）全局查询日志：记录开启之后的 全部 Sql 语句 全局的记录操作 ，仅仅在调优、开发过程中打开，部署一定关闭 show variables like ‘%general_log%’ 全局日志保存到表： 12set global general_log = 1 -- 开启全局日志set global log_output=&#x27;table&#x27; 开启后，会被记录到 mysql_general_log 表中 全局日志保存： 123set global general_log = 1 -- 开启全局日志set global log_output=&#x27;file&#x27; set global general_log_file=&#x27;/tmp/general.log&#x27; 开启后，会被记录到文件/tmp/general.log中","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL、数据库","slug":"MySQL、数据库","permalink":"http://fyupeng.github.io/tags/MySQL%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"fyupeng"},{"title":"juc原理","slug":"JUC原理","date":"2022-06-25T07:17:34.000Z","updated":"2022-06-25T07:22:42.638Z","comments":true,"path":"2022/06/25/JUC原理/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/JUC%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、Java 线程1.创建和运行线程 直接使用Thread开启线程 123456// 创建线程对象Thread t = new Thread() &#123; public void run() &#123; // 要执行的任务 &#125;&#125;; 例如： 1234567891011// 启动线程t.start();// 构造方法的参数是给线程指定名字，推荐Thread t1 = new Thread(&quot;t1&quot;) &#123; @Override // run 方法内实现了要执行的任务 public void run() &#123; log.debug(&quot;hello&quot;); &#125;&#125;;t1.start(); 输出： 119:19:00 [t1] c.ThreadStarter - hello 使用Runnable配合Thread 123456789Runnable runnable = new Runnable() &#123; public void run()&#123; // 要执行的任务 &#125;&#125;;// 创建线程对象Thread t = new Thread( runnable );// 启动线程t.start() 例如： 12345678910// 创建任务对象Runnable task2 = new Runnable() &#123; @Override public void run() &#123; log.debug(&quot;hello&quot;); &#125;&#125;;// 参数1 是任务对象; 参数2 是线程名字，推荐Thread t2 = new Thread(task2, &quot;t2&quot;);t2.start(); 输出： 119:19:00 [t2] c.ThreadStarter - hello Java 8 以后可以使用 lambda 精简代码 1234Runnable task2 = () -&gt; log.debug(&quot;hello&quot;);// 参数1 是任务对象; 参数2 是线程名字，推荐Thread t2 = new Thread(task2, &quot;t2&quot;);t2.start(); Thread与Runnable的关系： （1）用Runable更容易与线程池高级API配合 （2）配合Runnable让任务类脱离了Thread继承体系，更灵活 使用FutureTask配合Thread FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况 12345678910// 创建任务对象FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;&gt;(() -&gt; &#123; log.debug(&quot;hello&quot;); return 100;&#125;);// 参数1 是任务对象; 参数2 是线程名字，推荐new Thread(task3, &quot;t3&quot;).start();// 主线程阻塞，同步等待 task 执行完毕的结果Integer result = task3.get();log.debug(&quot;结果是:&#123;&#125;&quot;, result); 输出 1219:22:27 [t3] c.ThreadStarter - hello19:22:27 [main] c.ThreadStarter - 结果是:100 2.观察多个线程同时运行主要是理解 交替执行 谁先谁后，不由我们控制 3.查看进程线程的方法windows 任务管理器可以查看进程和线程数，也可以用来杀死进 tasklist 查看进程 taskkill 杀死进程 linux ps -fe 查看所有进程 ps -fT -p 查看某个进程（PID）的所有线程 kill 杀死进程 top 按大写 H 切换是否显示线程 top -H -p 查看某个进程（PID）的所有线程 Java jps 命令查看所有 Java 进程 jstack 查看某个 Java 进程（PID）的所有线程状态 jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）jconsole 远程监控配置 需要以如下方式运行你的 java 类1java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -Dcom.sun.management.jmxremote.authenticate=是否认证 java类 修改 /etc/hosts 文件将 127.0.0.1 映射至主机名 如果要认证访问，还需要做如下步骤 复制 jmxremote.password 文件 修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写 连接时填入 controlRole（用户名），R&amp;D（密码） 4.栈与栈帧Java Virtual Machine Stacks （Java 虚拟机栈）我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 5.线程上下文切换（Thread Context Switch）因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 线程的 cpu 时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能 6.常见方法 方法名 static 功能说明 注意 start() 启动一个新线 程，在新的线程 运行 run 方法 中的代码，线程之间并行 start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException run() 新线程启动后会 调用的方法，线程之间串行 如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为 join() 等待线程运行结束 join(long n) 等待线程运行结 束,最多等待 n 毫秒 getId() 获取线程长整型 的 id id 唯一 getName() 获取线程名 setName(String) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率 getState() 获取线程状态 Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED isInterrupted() 判断是否被打 断， 不会清除 打断标记 isAlive() 线程是否存活 （还没有运行完 毕） interrupt() 打断线程 如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 ；如果打断的正在运行的线程，不会清除 ；park 的线程被打断，也会设置 打断标记，不会清除 interrupted() static 判断当前线程是 否被打断 会清除 打断标记 currentThread() static 获取当前正在执 行的线程 sleep(long n) static 让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程 yield() static 提示线程调度器 让出当前线程对 CPU的使用 主要是为了测试和调试 6.1 start 与 run调用run1234567891011public static void main(String[] args) &#123; Thread t1 = new Thread(&quot;t1&quot;) &#123; @Override public void run() &#123; log.debug(Thread.currentThread().getName()); FileReader.read(Constants.MP4_FULL_PATH); &#125; &#125;; t1.run(); log.debug(&quot;do other things ...&quot;);&#125; 输出 123419:39:14 [main] c.TestStart - main19:39:14 [main] c.FileReader - read [1.mp4] start ...19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms19:39:18 [main] c.TestStart - do other things ... 程序仍在 main 线程运行， FileReader.read()方法调用还是同步的 调用 start将上述代码的 t1.run() 改为 1t1.start(); 输出 1234519:39:14 [main] c.TestStart - main19:39:14 [main] c.FileReader - read [1.mp4] start ...19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms19:39:18 [main] c.TestStart - do other things ...t1.start(); 程序在 t1 线程运行， FileReader.read() 方法调用是异步的 小结 直接调用 run 是在主线程中执行了 run，没有启动新的线程 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码 6.2 sleep 与 yieldsleep 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 睡眠结束后的线程未必会立刻得到执行 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 yield 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 具体的实现依赖于操作系统的任务调度器 线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用 12345678910111213141516171819Runnable task1 = () -&gt; &#123; int count = 0; for (;;) &#123; System.out.println(&quot;----&gt;1 &quot; + count++); &#125;&#125;;Runnable task2 = () -&gt; &#123; int count = 0; for (;;) &#123; // Thread.yield(); System.out.println(&quot; ----&gt;2 &quot; + count++); &#125;&#125;;Thread t1 = new Thread(task1, &quot;t1&quot;);Thread t2 = new Thread(task2, &quot;t2&quot;);// t1.setPriority(Thread.MIN_PRIORITY);// t2.setPriority(Thread.MAX_PRIORITY);t1.start();t2.start(); 6.3 join方法为什么需要 join下面的代码执行，打印 r 是什么？ 12345678910111213141516static int r = 0;public static void main(String[] args) throws InterruptedException &#123; test1();&#125;private static void test1() throws InterruptedException &#123; log.debug(&quot;开始&quot;); Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;开始&quot;); sleep(1); log.debug(&quot;结束&quot;); r = 10; &#125;); t1.start(); log.debug(&quot;结果为:&#123;&#125;&quot;, r); log.debug(&quot;结束&quot;);&#125; 分析 因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10 而主线程一开始就要打印 r 的结果，所以只能打印出 r=0 解决方法 用 sleep 行不行？为什么？ 用 join，加在 t1.start() 之后即可 等待多个结果问，下面代码 cost 大约多少秒？ 12345678910111213141516171819202122static int r1 = 0;static int r2 = 0;public static void main(String[] args) throws InterruptedException &#123;test2();&#125;private static void test2() throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; sleep(1); r1 = 10; &#125;); Thread t2 = new Thread(() -&gt; &#123; sleep(2); r2 = 20; &#125;); long start = System.currentTimeMillis(); t1.start(); t2.start(); t1.join(); t2.join(); long end = System.currentTimeMillis(); log.debug(&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;, r1, r2, end - start);&#125; 分析如下 第一个 join：等 待 t1 时, t2 并没有停止, 而在运行 第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s 如果颠倒两个 join 呢？最终都是输出 120:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005 有时效的 join等够时间 1234567891011121314151617static int r1 = 0;static int r2 = 0;public static void main(String[] args) throws InterruptedException &#123; test3();&#125;public static void test3() throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; sleep(1); r1 = 10; &#125;); long start = System.currentTimeMillis(); t1.start(); // 线程执行结束会导致 join 结束 t1.join(1500); long end = System.currentTimeMillis(); log.debug(&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;, r1, r2, end - start);&#125; 输出 120:48:01.320 [main] c.TestJoin - r1: 10 r2: 0 cost: 1010 没等够时间 1234567891011121314151617static int r1 = 0;static int r2 = 0;public static void main(String[] args) throws InterruptedException &#123; test3();&#125;public static void test3() throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; sleep(2); r1 = 10; &#125;); long start = System.currentTimeMillis(); t1.start(); // 线程执行结束会导致 join 结束 t1.join(1500); long end = System.currentTimeMillis(); log.debug(&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;, r1, r2, end - start);&#125; 输出 120:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502 6.4 interrupt 方法打断 sleep，wait，join 的线程这几个方法都会让线程进入阻塞状态打断 sleep 的线程, 会清空打断状态，以 sleep 为例 1234567891011121314151617181920Thread t1 = new Thread(()-&gt; &#123; //sleep(1); //try &#123; // Thread.currentThread().join(); //&#125; catch (InterruptedException e) &#123; // e.printStackTrace(); //&#125; try &#123; Thread.currentThread().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;t1&quot;);t1.start();sleep(0.5);t1.interrupt();log.debug(&quot; 打断状态: &#123;&#125;&quot;, t1.isInterrupted()); 输出 sleep： 12345678java.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at java.lang.Thread.sleep(Thread.java:340)at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)at java.lang.Thread.run(Thread.java:745)21:18:10.374 [main] c.TestInterrupt - 打断状态: false wait： 123456Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at cn.itcast.test.Test.lambda$main$0(Test.java:30) at java.lang.Thread.run(Thread.java:748)15:37:32.974 c.Test [main] - 打断状态: false join： 1234567java.lang.InterruptedException at java.lang.Object.wait(Native Method) at java.lang.Thread.join(Thread.java:1252) at java.lang.Thread.join(Thread.java:1326) at cn.itcast.test.Test.lambda$main$0(Test.java:25) at java.lang.Thread.run(Thread.java:748)15:46:22.178 c.Test [main] - 打断状态: false 打断正常运行的线程打断正常运行的线程, 不会清空打断状态 12345678910111213141516private static void test2() throws InterruptedException &#123; Thread t2 = new Thread(()-&gt;&#123; while(true) &#123; Thread current = Thread.currentThread(); boolean interrupted = current.isInterrupted(); if(interrupted) &#123; log.debug(&quot; 打断状态: &#123;&#125;&quot;, interrupted); break; &#125; &#125; &#125;, &quot;t2&quot;); t2.start(); sleep(0.5); t2.interrupt();&#125; 输出 120:57:37.964 [t2] c.TestInterrupt - 打断状态: true 打断 park 线程打断 park 线程, 不会清空打断状态 1234567891011private static void test3() throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;park...&quot;); LockSupport.park(); log.debug(&quot;unpark...&quot;); log.debug(&quot;打断状态：&#123;&#125;&quot;, Thread.currentThread().isInterrupted()); &#125;, &quot;t1&quot;); t1.start(); sleep(0.5); t1.interrupt();&#125; 输出 12321:11:52.795 [t1] c.TestInterrupt - park...21:11:53.295 [t1] c.TestInterrupt - unpark...21:11:53.295 [t1] c.TestInterrupt - 打断状态：true 如果打断标记已经是 true, 则 park 会失效 123456789101112131415161718private static void test4() &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; log.debug(&quot;park...&quot;); LockSupport.park(); log.debug(&quot;打断状态：&#123;&#125;&quot;, Thread.currentThread().isInterrupted()); &#125; // 清除 打断标记，即 设置为 false Thread.interrupted(); log.debug(&quot;打断状态：&#123;&#125;&quot;, Thread.currentThread().isInterrupted()); log.debug(&quot;park...&quot;); LockSupport.park(); log.debug(&quot;打断状态：&#123;&#125;&quot;, Thread.currentThread().isInterrupted()); &#125;); t1.start(); sleep(1); t1.interrupt();&#125; 输出 1234567891011121315:54:57.684 c.Test [Thread-0] - park...15:54:58.692 c.Test [Thread-0] - 打断状态：true15:54:58.696 c.Test [Thread-0] - park...15:54:58.696 c.Test [Thread-0] - 打断状态：true15:54:58.696 c.Test [Thread-0] - park...15:54:58.696 c.Test [Thread-0] - 打断状态：true15:54:58.696 c.Test [Thread-0] - park...15:54:58.696 c.Test [Thread-0] - 打断状态：true15:54:58.696 c.Test [Thread-0] - park...15:54:58.696 c.Test [Thread-0] - 打断状态：true15:54:58.696 c.Test [Thread-0] - 打断状态：false15:54:58.696 c.Test [Thread-0] - park...# 还有 下一句打断标记没打印出来，此时已恢复 park 功能 提示可以使用 Thread.interrupted() 清除打断状态 总结：处于sleep、join、wait 状态的线程 使用 interrupt() 会清除打断标记 Thread.currentThread().isInterrupted()) 处于park和 run 的线程，使用 interrupt()不会清除打断标记 Thread.currentThread().isInterrupted()) park线程 调用 interrupt()后，该线程后面再使用的 park会失效，需要使用 Thread.interrupted() 恢复park 为有效 6.5 不推荐的方法还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁 方法名 static 功能说明 stop() 停止线程运行 suspend() 挂起（暂停）线程运行 resume() 恢复线程运行 7. 主线程和守护线程默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。例： 1234567891011log.debug(&quot;开始运行...&quot;);Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;开始运行...&quot;); sleep(2); log.debug(&quot;运行结束...&quot;);&#125;, &quot;daemon&quot;);// 设置该线程为守护线程t1.setDaemon(true);t1.start();sleep(1);log.debug(&quot;运行结束...&quot;); 输出 12308:26:38.123 [main] c.TestDaemon - 开始运行...08:26:38.213 [daemon] c.TestDaemon - 开始运行...08:26:39.215 [main] c.TestDaemon - 运行结束... 注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 8. 五种状态这是从 操作系统 层面来描述的 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联)，以由 CPU 调度执行 【运行状态】指获取了 CPU 时间片运行中的状态当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】（1）如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】（2）等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】（3）与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 9. 六种状态这是从 Java API 层面来描述的根据 Thread.State 枚举，分为六种状态 NEW 线程刚被创建，但是还没有调用 start() 方法 RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行） BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述 TERMINATED 当线程代码运行结束 二、共享模型之管程1. 共享带来的问题1.1 临界区 Critical Section 一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源（1）多个线程读共享资源其实也没有问题（2）在多个线程对共享资源读写操作时发生指令交错，就会出现问题 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为**临界区**例如，下面代码中的临界区 12345678910111213static int counter = 0;static void increment() // 临界区&#123; counter++; &#125;static void decrement() // 临界区&#123; counter--;&#125; 1.2 竞态条件 Race Condition多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 2. synchronized解决方案2.1 解决方案为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 2.2 synchronized使用的是阻塞式的解决方案：synchronized，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点 语法 1234synchronized(对象) // 线程1， 线程2(blocked)&#123; 临界区&#125; 解决 1234567891011121314151617181920212223static int counter = 0;static final Object room = new Object();public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123; synchronized (room) &#123; counter++; &#125; &#125; &#125;, &quot;t1&quot;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123; synchronized (room) &#123; counter--; &#125; &#125; &#125;, &quot;t2&quot;); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(&quot;&#123;&#125;&quot;,counter);&#125; 你可以做这样的类比： synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人 当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码 这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入 当 t1 执行完 synchronized&#123;&#125; 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码 2.3 思考synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。为了加深理解，请思考下面的问题 如果把 synchronized(obj) 放在 for 循环的外面，如何理解？– 原子性 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？– 锁对象 如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？– 锁对象 3. 方法上的synchronized注意锁的不是方法，而是对象 1234567891011class Test&#123; public synchronized void test() &#123; &#125;&#125;//等价于class Test&#123; public void test() &#123; synchronized(this) &#123; &#125; &#125;&#125; 1234567891011class Test&#123; public synchronized static void test() &#123; &#125;&#125;//等价于class Test&#123; public static void test() &#123; synchronized(Test.class) &#123; &#125; &#125;&#125; 3.1 不加 synchronized 的方法不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的） 3.2 所谓的“线程八锁”其实就是考察 synchronized 锁住的是哪个对象 线程八锁的重点： 非静态方法的默认锁是this，静态方法的默认锁是class 某一时刻内，只能有一个线程有锁，无论几个方法 情况1：12 或 21 123456789101112131415@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public synchronized void a() &#123; log.debug(&quot;1&quot;); &#125; public synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n1.b(); &#125;).start();&#125; 情况2：1s后12，或 2 1s后 1 12345678910111213141516@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n1.b(); &#125;).start();&#125; 情况3：3 1s 12 或 23 1s 1 或 32 1s 1 1234567891011121314151617181920@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public synchronized void b() &#123; log.debug(&quot;2&quot;); &#125; public void c() &#123; log.debug(&quot;3&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n1.b(); &#125;).start(); new Thread(()-&gt;&#123; n1.c(); &#125;).start();&#125; 情况4：2 1s 后 1 1234567891011121314151617@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); Number n2 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125; 情况5：2 1s 后 1 12345678910111213141516@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public static synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n1.b(); &#125;).start();&#125; 情况6：1s 后12， 或 2 1s后 1 12345678910111213141516@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public static synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public static synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125; public static void main(String[] args) &#123; Number n1 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n1.b(); &#125;).start();&#125; 情况7：2 1s 后 1 1234567891011121314151617@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public static synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); Number n2 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125; 情况8：1s 后12， 或 2 1s后 1 1234567891011121314151617@Slf4j(topic = &quot;c.Number&quot;)class Number&#123; public static synchronized void a() &#123; sleep(1); log.debug(&quot;1&quot;); &#125; public static synchronized void b() &#123; log.debug(&quot;2&quot;); &#125;&#125;public static void main(String[] args) &#123; Number n1 = new Number(); Number n2 = new Number(); new Thread(()-&gt;&#123; n1.a(); &#125;).start(); new Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125; 4. 变量的线程安全分析4.1 成员变量和静态变量是否线程安全？ 如果它们没有共享，则线程安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 如果只有读操作，则线程安全 如果有读写操作，则这段代码是临界区，需要考虑线程安全 4.2 局部变量是否线程安全？ 局部变量是线程安全的 但局部变量引用的对象则未必 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围，需要考虑线程安全 4.3 局部变量线程安全分析1234public static void test1() &#123;int i = 10;i++;&#125; 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享 12345678910111213141516public static void test1();descriptor: ()V flags: ACC_PUBLIC, ACC_STATICCode:stack=1, locals=1, args_size=00: bipush 102: istore_03: iinc 0, 16: returnLineNumberTable:line 10: 0line 11: 3line 12: 6LocalVariableTable:Start Length Slot Name Signature3 4 0 i I 如图 局部变量的引用稍有不同 先看一个成员变量的例子 12345678910111213141516171819202122class ThreadUnsafe &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); public void method1(int loopNumber) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; // &#123; 临界区, 会产生竞态条件 method2(); method3(); // &#125; 临界区 &#125; &#125; private void method2() &#123; list.add(&quot;1&quot;); &#125; private void method3() &#123; list.remove(0); &#125; &#125; 执行 12345678910static final int THREAD_NUMBER = 2;static final int LOOP_NUMBER = 200;public static void main(String[] args) &#123; ThreadUnsafe test = new ThreadUnsafe(); for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123; new Thread(() -&gt; &#123; test.method1(LOOP_NUMBER); &#125;, &quot;Thread&quot; + i).start(); &#125;&#125; 其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错： 1234567Exception in thread &quot;Thread1&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0at java.util.ArrayList.rangeCheck(ArrayList.java:657)at java.util.ArrayList.remove(ArrayList.java:496)at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35)at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26)at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14)at java.lang.Thread.run(Thread.java:748) 分析： 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量 method3 与 method2 分析相同 将 list 修改为局部变量 12345678910111213141516171819class ThreadSafe &#123; public final void method1(int loopNumber) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; loopNumber; i++) &#123; method2(list); method3(list); &#125; &#125; private void method2(ArrayList&lt;String&gt; list) &#123; list.add(&quot;1&quot;); &#125; private void method3(ArrayList&lt;String&gt; list) &#123; list.remove(0); &#125; &#125; 那么就不会有上述问题了 分析： list 是局部变量，每个线程调用时会创建其不同实例，没有共享 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 method3 的参数分析与 method2 相同 方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会带来线程安全问题？ 情况1：有其它线程调用 method2 和 method3 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即 1234567891011121314151617181920212223242526272829class ThreadSafe &#123; public final void method1(int loopNumber) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; loopNumber; i++) &#123; method2(list); method3(list); &#125; &#125; private void method2(ArrayList&lt;String&gt; list) &#123; list.add(&quot;1&quot;); &#125; private void method3(ArrayList&lt;String&gt; list) &#123; list.remove(0); &#125; &#125;class ThreadSafeSubClass extends ThreadSafe&#123; @Override public void method3(ArrayList&lt;String&gt; list) &#123; new Thread(() -&gt; &#123; list.remove(0); &#125;).start(); &#125;&#125; 4.4 常见线程安全类 String Integer StringBuffer Random Vector Hashtable java.util.concurrent 包下的类 这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为 12345678Hashtable table = new Hashtable();new Thread(()-&gt;&#123; table.put(&quot;key&quot;, &quot;value1&quot;);&#125;).start();new Thread(()-&gt;&#123; table.put(&quot;key&quot;, &quot;value2&quot;);&#125;).start(); 它们的每个方法是原子的 但注意它们多个方法的组合不是原子的，见后面分析 线程安全类方法的组合分析下面代码是否线程安全？ 12345Hashtable table = new Hashtable();// 线程1，线程2if( table.get(&quot;key&quot;) == null) &#123;table.put(&quot;key&quot;, value);&#125; 不可变类线程安全性String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？ 12345678910111213public class Immutable&#123; private int value = 0; public Immutable(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; &#125; 如果想增加一个增加的方法呢？ 12345678910111213141516public class Immutable&#123; private int value = 0; public Immutable(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; public Immutable add(int v)&#123; return new Immutable(this.value + v); &#125; &#125; 实例分析例1： 12345678910111213141516public class MyServlet extends HttpServlet &#123; // 是否安全？ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 是否安全？ String S1 = &quot;...&quot;; // 是否安全？ final String S2 = &quot;...&quot;; // 是否安全？ Date D1 = new Date(); // 是否安全？ final Date D2 = new Date(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; // 使用上述变量 &#125;&#125; 例2： 1234567891011121314151617public class MyServlet extends HttpServlet &#123; // 是否安全？ private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; userService.update(...); &#125;&#125;public class UserServiceImpl implements UserService &#123; // 记录调用次数 private int count = 0; public void update() &#123; // ... count++; &#125;&#125; 例3： 123456789101112131415161718@Aspect@Componentpublic class MyAspect &#123; // 是否安全？ private long start = 0L; @Before(&quot;execution(* *(..))&quot;) public void before() &#123; start = System.nanoTime(); &#125; @After(&quot;execution(* *(..))&quot;) public void after() &#123; long end = System.nanoTime(); System.out.println(&quot;cost time:&quot; + (end-start)); &#125;&#125; 例4： 12345678910111213141516171819202122232425262728public class MyServlet extends HttpServlet &#123; // 是否安全 private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; userService.update(...); &#125;&#125;public class UserServiceImpl implements UserService &#123; // 是否安全 private UserDao userDao = new UserDaoImpl(); public void update() &#123; userDao.update(); &#125;&#125;public class UserDaoImpl implements UserDao &#123; public void update() &#123; String sql = &quot;update user set password = ? where username = ?&quot;; // 是否安全 try (Connection conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;))&#123; // ... &#125; catch (Exception e) &#123; // ... &#125; &#125;&#125; 例5： 12345678910111213141516171819202122232425262728public class MyServlet extends HttpServlet &#123; // 是否安全 private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; userService.update(...); &#125;&#125;public class UserServiceImpl implements UserService &#123; // 是否安全 private UserDao userDao = new UserDaoImpl(); public void update() &#123; userDao.update(); &#125;&#125;public class UserDaoImpl implements UserDao &#123; // 是否安全 private Connection conn = null; public void update() throws SQLException &#123; String sql = &quot;update user set password = ? where username = ?&quot;; conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;); // ... conn.close(); &#125;&#125; 例6： 1234567891011121314151617181920212223242526public class MyServlet extends HttpServlet &#123; // 是否安全 private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; userService.update(...); &#125;&#125;public class UserServiceImpl implements UserService &#123; public void update() &#123; UserDao userDao = new UserDaoImpl(); userDao.update(); &#125;&#125;public class UserDaoImpl implements UserDao &#123; // 是否安全 private Connection = null; public void update() throws SQLException &#123; String sql = &quot;update user set password = ? where username = ?&quot;; conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;); // ... conn.close(); &#125;&#125; 例7： 12345678910111213public abstract class Test &#123; public void bar() &#123; // 是否安全 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); foo(sdf); &#125; public abstract foo(SimpleDateFormat sdf); public static void main(String[] args) &#123; new Test().bar(); &#125;&#125; 其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法 123456789101112131415public void foo(SimpleDateFormat sdf) &#123; String dateStr = &quot;1999-10-11 00:00:00&quot;; for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; try &#123; sdf.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 请比较 JDK 中 String 类的实现 例8： 1234567891011121314151617181920212223242526private static Integer i = 0;public static void main(String[] args) throws InterruptedException &#123; List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 2; j++) &#123; Thread thread = new Thread(() -&gt; &#123; for (int k = 0; k &lt; 5000; k++) &#123; synchronized (i) &#123; i++; &#125; &#125; &#125;, &quot;&quot; + j); list.add(thread); &#125; list.stream().forEach(t -&gt; t.start()); list.stream().forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); log.debug(&quot;&#123;&#125;&quot;, i);&#125; 5. 习题5.1 卖票练习测试下面代码是否存在线程安全问题，并尝试改正 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class ExerciseSell &#123; public static void main(String[] args) &#123; TicketWindow ticketWindow = new TicketWindow(2000); List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); // 用来存储买出去多少张票 List&lt;Integer&gt; sellCount = new Vector&lt;&gt;(); for (int i = 0; i &lt; 2000; i++) &#123; Thread t = new Thread(() -&gt; &#123; // 分析这里的竞态条件 int count = ticketWindow.sell(randomAmount()); sellCount.add(count); &#125;); list.add(t); t.start(); &#125; list.forEach((t) -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); // 买出去的票求和 log.debug(&quot;selled count:&#123;&#125;&quot;,sellCount.stream().mapToInt(c -&gt; c).sum()); // 剩余票数 log.debug(&quot;remainder count:&#123;&#125;&quot;, ticketWindow.getCount()); &#125; // Random 为线程安全 static Random random = new Random(); // 随机 1~5 public static int randomAmount() &#123; return random.nextInt(5) + 1; &#125;&#125;class TicketWindow &#123; private int count; public TicketWindow(int count) &#123; this.count = count; &#125; public int getCount() &#123; return count; &#125; public int sell(int amount) &#123; if (this.count &gt;= amount) &#123; this.count -= amount; return amount; &#125; else &#123; return 0; &#125; &#125;&#125; 另外，用下面的代码行不行，为什么？ 1List&lt;Integer&gt; sellCount = new ArrayList&lt;&gt;(); 测试脚本 1for /L %n in (1,1,10) do java -cp &quot;.;D:\\Users\\Administrator\\.m2\\repository\\ch\\qos\\logback\\1.2.3\\logback-classic-1.2.3.jar;D:\\Users\\Administrator\\.m2\\repository\\ch\\qos\\logback\\logbackcore\\1.2.3\\logback-core-1.2.3.jar;D:\\Users\\Administrator\\.m2\\repository\\org\\slf4j\\slf4japi\\1.7.25\\slf4j-api-1.7.25.jar&quot; cn.itcast.n4.exercise.ExerciseSell 5.2 转账练习测试下面代码是否存在线程安全问题，并尝试改正 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ExerciseTransfer &#123; public static void main(String[] args) throws InterruptedException &#123; Account a = new Account(1000); Account b = new Account(1000); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; a.transfer(b, randomAmount()); &#125; &#125;, &quot;t1&quot;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; b.transfer(a, randomAmount()); &#125; &#125;, &quot;t2&quot;); t1.start(); t2.start(); t1.join(); t2.join();// 查看转账2000次后的总金额 log.debug(&quot;total:&#123;&#125;&quot;,(a.getMoney() + b.getMoney())); &#125; // Random 为线程安全 static Random random = new Random(); // 随机 1~100 public static int randomAmount() &#123; return random.nextInt(100) +1; &#125;&#125;class Account &#123; private int money; public Account(int money) &#123; this.money = money; &#125; public int getMoney() &#123; return money; &#125; public void setMoney(int money) &#123; this.money = money; &#125; public void transfer(Account target, int amount) &#123; if (this.money &gt; amount) &#123; this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); &#125; &#125;&#125; 这样改正行不行，为什么？ 123456public synchronized void transfer(Account target, int amount) &#123; if (this.money &gt; amount) &#123; this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); &#125;&#125; 6. Monitor 概念6.1 Java 对象头以 32 位虚拟机为例 普通对象 12345|--------------------------------------------------------------|| Object Header (64 bits) ||------------------------------------|-------------------------|| Mark Word (32 bits) | Klass Word (32 bits) ||------------------------------------|-------------------------| 数组对象 12345|---------------------------------------------------------------------------------|| Object Header (96 bits) ||--------------------------------|-----------------------|------------------------|| Mark Word(32bits) | Klass Word(32bits) | array length(32bits) ||--------------------------------|-----------------------|------------------------| 其中 Mark Word 结构为 12345678910111213|-------------------------------------------------------|--------------------|| Mark Word (32 bits) | State ||-------------------------------------------------------|--------------------|| hashcode:25 | age:4 | biased_lock:0 | 01 | Normal ||-------------------------------------------------------|--------------------|| thread:23 | epoch:2 | age:4 | biased_lock:1 | 01 | Biased ||-------------------------------------------------------|--------------------|| ptr_to_lock_record:30 | 00 | Lightweight Locked ||-------------------------------------------------------|--------------------|| ptr_to_heavyweight_monitor:30 | 10 | Heavyweight Locked ||-------------------------------------------------------|--------------------|| | 11 | Marked for GC ||-------------------------------------------------------|--------------------| 64 位虚拟机 Mark Word 12345678910111213|--------------------------------------------------------------------|--------------------|| Mark Word (64 bits) | State ||--------------------------------------------------------------------|--------------------|| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 | Normal ||--------------------------------------------------------------------|--------------------|| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 | Biased ||--------------------------------------------------------------------|--------------------|| ptr_to_lock_record:62 | 00 | Lightweight Locked ||--------------------------------------------------------------------|--------------------|| ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked ||--------------------------------------------------------------------|--------------------|| | 11 | Marked for GC ||--------------------------------------------------------------------|--------------------| 参考资料 https://stackoverflow.com/questions/26357186/what-is-in-java-object-header 6.2 原理之 Monitor(锁)Monitor 被翻译为监视器或管程 每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针 Monitor 结构如下 刚开始 Monitor 中 Owner 为 null 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析 注意： synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则 6.3 原理之 synchronized1234567static final Object lock = new Object();static int counter = 0;public static void main(String[] args) &#123; synchronized (lock) &#123; counter++; &#125;&#125; 对应的字节码为 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(java.lang.String[]);descriptor: ([Ljava/lang/String;)Vflags: ACC_PUBLIC, ACC_STATICCode:stack=2, locals=3, args_size=10: getstatic #2 // &lt;- lock引用 （synchronized开始）3: dup4: astore_1 // lock引用 -&gt; slot 15: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针6: getstatic #3 // &lt;- i9: iconst_1 // 准备常数 110: iadd // +111: putstatic #3 // -&gt; i14: aload_1 // &lt;- lock引用15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList16: goto 2419: astore_2 // e -&gt; slot 220: aload_1 // &lt;- lock引用21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList22: aload_2 // &lt;- slot 2 (e)23: athrow // throw e24: returnException table:from to target type6 16 19 any19 22 19 anyLineNumberTable:line 8: 0line 9: 6line 10: 14line 11: 24LocalVariableTable:Start Length Slot Name Signature0 25 0 args [Ljava/lang/String;StackMapTable: number_of_entries = 2frame_type = 255 /* full_frame */offset_delta = 19locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]stack = [ class java/lang/Throwable ]frame_type = 250 /* chop */offset_delta = 4 注意 方法级别的 synchronized 不会在字节码指令中有所体现 6.4 小故事故事角色 老王 - JVM 小南 - 线程 小女 - 线程 房间 - 对象 房间门上 - 防盗锁 - Monitor 房间门上 - 小南书包 - 轻量级锁 房间门上 - 刻上小南大名 - 偏向锁 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，即使他离开了，别人也进不了门，他的工作就是安全的。 但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？ 小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。 后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。 于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。 同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字 后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包 6.5 原理之 synchronized 进阶轻量级锁轻量即锁的使用场景，如果一个对象虽然有多线程访问，但多线程访问的时间是错开的 (也就是没有竞争)，那么可以使用轻量级锁来优化。 轻量级锁对使用者是透明的，即语法依然是 synchronized 假设有两个方法同步块，利用同一个对象加锁 123456789101112static final Object obj = new Object();public static void method1() &#123; synchronized( obj ) &#123; // 同步块 A method2(); &#125;&#125;public static void method2() &#123; synchronized( obj ) &#123; // 同步块 B &#125;&#125; 创建锁记录 (Lock Record)，对象，每个线程的栈帧都包含一个锁记录的结构，内部可以存储锁对象的 Mark Word 让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下 如果 cas 失败，有两种情况 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 成功，则解锁成功 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 锁膨胀如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁 123456static Object obj = new Object(); public static void method1() &#123; synchronized( obj ) &#123; // 同步块 &#125;&#125; 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 然后自己进入 Monitor 的 EntryList BLOCKED 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程 自旋优化重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 自旋重试成功的情况 线程 1 （core 1 上） 对象 Mark 线程 2 （core 2 上） - 10（重量锁） - 访问同步块，获取 monitor 10（重量锁）重量锁指针 - 成功（加锁） 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor 执行同步块 10（重量锁）重量锁指针 自旋重试 执行完毕 10（重量锁）重量锁指针 自旋重试 成功（解锁） 01（无锁） 自旋重试 - 10（重量锁）重量锁指针 成功（加锁） - 10（重量锁）重量锁指针 执行同步块 - … … 自旋重试失败的情况 线程 1（core 1 上） 对象 Mark 线程 2（core 2 上） - 10（重量锁） - 访问同步块，获取 monitor 10（重量锁）重量锁指针 - 成功（加锁） 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 阻塞 - … … 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 Java 7 之后不能控制是否开启自旋功能 偏向锁轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 例如： 1234567891011121314151617181920static final Object obj = new Object();public static void m1() &#123; synchronized( obj ) &#123; // 同步块 A m2(); &#125;&#125;public static void m2() &#123; synchronized( obj ) &#123; // 同步块 B m3(); &#125;&#125;public static void m3() &#123; synchronized( obj ) &#123; // 同步块 C &#125;&#125; 偏向状态回忆一下对象头格式 12345678910111213|--------------------------------------------------------------------|--------------------|| Mark Word (64 bits) | State | |--------------------------------------------------------------------|--------------------|| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 | Normal ||--------------------------------------------------------------------|--------------------|| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 | Biased ||--------------------------------------------------------------------|--------------------|| ptr_to_lock_record:62 | 00 | Lightweight Locked ||--------------------------------------------------------------------|--------------------|| ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked ||--------------------------------------------------------------------|--------------------|| | 11 | Marked for GC ||--------------------------------------------------------------------|--------------------| 一个对象创建时： 如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值 1） 测试延迟特性 1234567891011// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0Dog d = new Dog();ClassLayout classLayout = ClassLayout.parseInstance(d);System.out.println(classLayout.toPrintable());// HotSpot 虚拟机在启动后有个 4s 的延迟才会对每个新建的对象开启偏向锁模式Thread.sleep(3000);System.out.println(ClassLayout.parseInstance(new Dog()).toPrintable()); 由于偏向锁是有延迟的，直接 给对象加锁是 看不到 偏向锁 效果的，可以使用Thread.sleep(4000)，或者 开启禁用 偏向锁延迟 -XX:BiasedLockingStartupDelay=0 2） 测试偏向锁 1class Dog &#123;&#125; 利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁） 12345 &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 //没有 延迟等待的话。就看不到 偏向锁的效果Thread.sleep(4000);Dog d = new Dog();ClassLayout classLayout = ClassLayout.parseInstance(d);new Thread(() -&gt; &#123; log.debug(&quot;synchronized 前&quot;); System.out.println(classLayout.toPrintable()); synchronized (d) &#123; log.debug(&quot;synchronized 中&quot;); System.out.println(classLayout.toPrintable()); &#125; log.debug(&quot;synchronized 后&quot;); System.out.println(classLayout.toPrintable());&#125;, &quot;t1&quot;).start(); 有了偏向锁后 123456789101112131415161718192021// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 //没有 延迟等待的话。就看不到 偏向锁的效果Thread.sleep(4000);Dog d = new Dog();ClassLayout classLayout = ClassLayout.parseInstance(d);new Thread(() -&gt; &#123; log.debug(&quot;synchronized 前&quot;); System.out.println(classLayout.toPrintable()); synchronized (d) &#123; log.debug(&quot;synchronized 中&quot;); System.out.println(classLayout.toPrintable()); &#125; log.debug(&quot;synchronized 后&quot;); System.out.println(classLayout.toPrintable());&#125;, &quot;t1&quot;).start(); 观察偏向锁与没有偏向锁导致重入锁的差异 12345678910111213//没有 延迟等待的话。就看不到 偏向锁的效果Thread.sleep(4000);Dog d = new Dog();log.debug(ClassLayout.parseInstance(d).toPrintable());synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintable());&#125;synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintable());&#125; 没有偏向锁，需要锁重入CAS 12345678910Dog d = new Dog();log.debug(ClassLayout.parseInstance(d).toPrintable());synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintable());&#125;synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintable());&#125; 撤销 - 调用对象 hashCode调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销 轻量级锁会在锁记录中记录 hashCode 重量级锁会在 Monitor 中记录 hashCode 在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking (禁用偏向锁) 123456789101112Thread.sleep(4000);Dog d = new Dog();d.hashCode();log.debug(ClassLayout.parseInstance(d).toPrintable());synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintable());&#125;log.debug(ClassLayout.parseInstance(d).toPrintable()); 输出 123456711:22:10.386 c.TestBiased [main] - 调用 hashCode:177853501511:22:10.391 c.TestBiased [t1] - synchronized 前00000000 00000000 00000000 01101010 00000010 01001010 01100111 0000000111:22:10.393 c.TestBiased [t1] - synchronized 中00000000 00000000 00000000 00000000 00100000 11000011 11110011 0110100011:22:10.393 c.TestBiased [t1] - synchronized 后00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 撤销 - 其他线程使用对象当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁 12345678910111213141516171819202122232425262728293031323334private static void test2() throws InterruptedException &#123; Dog d = new Dog(); Thread t1 = new Thread(() -&gt; &#123; synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; synchronized (TestBiased.class) &#123; TestBiased.class.notify(); &#125; // 如果不用 wait/notify 使用 join 必须打开下面的注释 // 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的 /*try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;*/ &#125;, &quot;t1&quot;); t1.start(); Thread t2 = new Thread(() -&gt; &#123; synchronized (TestBiased.class) &#123; try &#123; TestBiased.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125;, &quot;t2&quot;); t2.start();&#125; 输出 1234[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101[t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 由于是偏向锁，撤销锁再 CAS[t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 不可偏向 撤销 - 调用wait/notify123456789101112131415161718192021222324252627public static void main(String[] args) throws InterruptedException &#123; Dog d = new Dog(); Thread t1 = new Thread(() -&gt; &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); try &#123; d.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125;, &quot;t1&quot;); t1.start(); new Thread(() -&gt; &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (d) &#123; log.debug(&quot;notify&quot;); d.notify(); &#125; &#125;, &quot;t2&quot;).start();&#125; 1234[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101[t1] - 00000000 00000000 00000000 00000000 00011111 10110011 11111000 00000101[t2] - notify[t1] - 00000000 00000000 00000000 00000000 00011100 11010100 00001101 11001010 批量重偏向如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID 当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程 只会偏一次，如果又有一个线程 加锁，它不会在 锁阈值 超过20 次 重偏向，不过在 40 次之后会撤销 偏向锁，升级为 轻量锁 CAS 12345678910111213141516171819202122232425262728293031323334353637private static void test3() throws InterruptedException &#123; Vector&lt;Dog&gt; list = new Vector&lt;&gt;(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 30; i++) &#123; Dog d = new Dog(); list.add(d); synchronized (d) &#123; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125; synchronized (list) &#123; // list.notify(); &#125; &#125;, &quot;t1&quot;); t1.start(); Thread t2 = new Thread(() -&gt; &#123; synchronized (list) &#123; try &#123; list.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;===============&gt; &quot;); for (int i = 0; i &lt; 30; i++) &#123; Dog d = list.get(i); log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125;, &quot;t2&quot;); t2.start();&#125; 输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - ===============&gt;[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 批量撤销当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的 123456789101112131415161718192021222324252627282930313233343536373839404142434445static Thread t1,t2,t3;private static void test4() throws InterruptedException &#123; Vector&lt;Dog&gt; list = new Vector&lt;&gt;(); int loopNumber = 39; t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; Dog d = new Dog(); list.add(d); synchronized (d) &#123; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125; LockSupport.unpark(t2); &#125;, &quot;t1&quot;); t1.start(); t2 = new Thread(() -&gt; &#123; LockSupport.park(); log.debug(&quot;===============&gt; &quot;); for (int i = 0; i &lt; loopNumber; i++) &#123; Dog d = list.get(i); log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; LockSupport.unpark(t3); &#125;, &quot;t2&quot;); t2.start(); t3 = new Thread(() -&gt; &#123; LockSupport.park(); log.debug(&quot;===============&gt; &quot;); for (int i = 0; i &lt; loopNumber; i++) &#123; Dog d = list.get(i); log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(i + &quot;\\t&quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125;, &quot;t3&quot;); t3.start(); t3.join(); log.debug(ClassLayout.parseInstance(new Dog()).toPrintableSimple(true));&#125; 参考资料https://github.com/farmerjohngit/myblog/issues/12https://www.cnblogs.com/LemonFive/p/11246086.htmlhttps://www.cnblogs.com/LemonFive/p/11248248.html偏向锁论文 锁消除锁消除 12345678910111213141516171819@Fork(1)@BenchmarkMode(Mode.AverageTime)@Warmup(iterations=3)@Measurement(iterations=5)@OutputTimeUnit(TimeUnit.NANOSECONDS)public class MyBenchmark &#123; static int x = 0; @Benchmark public void a() throws Exception &#123; x++; &#125; @Benchmark public void b() throws Exception &#123; Object o = new Object(); synchronized (o) &#123; x++; &#125; &#125;&#125; java -jar benchmarks.jar 123Benchmark Mode Samples Score Score error Unitsc.i.MyBenchmark.a avgt 5 1.542 0.056 ns/opc.i.MyBenchmark.b avgt 5 1.518 0.091 ns/op java -XX:-EliminateLocks -jar benchmarks.jar 123Benchmark Mode Samples Score Score error Unitsc.i.MyBenchmark.a avgt 5 1.507 0.108 ns/opc.i.MyBenchmark.b avgt 5 16.976 1.572 ns/op 锁粗化 对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。 7. wait notify7.1 小故事 - 为什么需要 wait 由于条件不满足，小南不能继续进行计算 但小南如果一直占用着锁，其它人就得一直阻塞，效率太低 于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开，其它人可以由老王随机安排进屋 直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法） 小南于是可以离开休息室，重新进入竞争锁的队列 7.2 原理之 wait / notify Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 BLOCKED 线程会在 Owner 线程释放锁时唤醒 WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争 7.3 API 介绍 obj.wait() 让进入 object 监视器的线程到 waitSet 等待 obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒 它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法 1234567891011121314151617181920212223242526272829303132333435final static Object obj = new Object();public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (obj) &#123; log.debug(&quot;执行....&quot;); try &#123; obj.wait(); // 让线程在obj上一直等待下去 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(&quot;其它代码....&quot;); &#125; &#125;).start(); new Thread(() -&gt; &#123; synchronized (obj) &#123; log.debug(&quot;执行....&quot;); try &#123; obj.wait(); // 让线程在obj上一直等待下去 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(&quot;其它代码....&quot;); &#125; &#125;).start(); // 主线程两秒后执行 sleep(2); log.debug(&quot;唤醒 obj 上其它线程&quot;); synchronized (obj) &#123; obj.notify(); // 唤醒obj上一个线程 // obj.notifyAll(); // 唤醒obj上所有等待线程 &#125;&#125; notify 的一种结果 123420:00:53.096 [Thread-0] c.TestWaitNotify - 执行....20:00:53.099 [Thread-1] c.TestWaitNotify - 执行....20:00:55.096 [main] c.TestWaitNotify - 唤醒 obj 上其它线程20:00:55.096 [Thread-0] c.TestWaitNotify - 其它代码.... notifyAll 的结果 1234519:58:15.457 [Thread-0] c.TestWaitNotify - 执行....19:58:15.460 [Thread-1] c.TestWaitNotify - 执行....19:58:17.456 [main] c.TestWaitNotify - 唤醒 obj 上其它线程19:58:17.456 [Thread-1] c.TestWaitNotify - 其它代码....19:58:17.456 [Thread-0] c.TestWaitNotify - 其它代码.... wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止 wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify 8. wait notify 正确姿势开始之前先看看 8.1 sleep(long n) 和 wait(long n) 的区别 sleep 是 Thread 方法，而 wait 是 Object 的方法 sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 它们状态 TIMED_WAITING step1123static final Object room = new Object();static boolean hasCigarette = false;static boolean hasTakeout = false; 思考下面的解决方案好不好，为什么？ 1234567891011121314151617181920212223242526new Thread(() -&gt; &#123; synchronized (room) &#123; log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette); if (!hasCigarette) &#123; log.debug(&quot;没烟，先歇会！&quot;); sleep(2); &#125; log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette); if (hasCigarette) &#123; log.debug(&quot;可以开始干活了&quot;); &#125; &#125;&#125;, &quot;小南&quot;).start();for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; synchronized (room) &#123; log.debug(&quot;可以开始干活了&quot;); &#125; &#125;, &quot;其它人&quot;).start();&#125;sleep(1);new Thread(() -&gt; &#123; // 这里能不能加 synchronized (room)？ hasCigarette = true; log.debug(&quot;烟到了噢！&quot;);&#125;, &quot;送烟的&quot;).start(); 输出 1234567891020:49:49.883 [小南] c.TestCorrectPosture - 有烟没？[false]20:49:49.887 [小南] c.TestCorrectPosture - 没烟，先歇会！20:49:50.882 [送烟的] c.TestCorrectPosture - 烟到了噢！20:49:51.887 [小南] c.TestCorrectPosture - 有烟没？[true]20:49:51.887 [小南] c.TestCorrectPosture - 可以开始干活了20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了 其它干活的线程，都要一直阻塞，效率太低 小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来 加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加 synchronized 就好像 main 线程是翻窗户进来的 解决方法，使用 wait - notify 机制 step2思考下面的实现行吗，为什么？ 12345678910111213141516171819202122232425262728293031323334new Thread(() -&gt; &#123; synchronized (room) &#123; log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette); if (!hasCigarette) &#123; log.debug(&quot;没烟，先歇会！&quot;); try &#123; room.wait(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette); if (hasCigarette) &#123; log.debug(&quot;可以开始干活了&quot;); &#125; &#125;&#125;, &quot;小南&quot;).start() for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; synchronized (room) &#123; log.debug(&quot;可以开始干活了&quot;); &#125; &#125;, &quot;其它人&quot;).start();&#125;sleep(1);new Thread(() -&gt; &#123; synchronized (room) &#123; hasCigarette = true; log.debug(&quot;烟到了噢！&quot;); room.notify(); &#125;&#125;, &quot;送烟的&quot;).start(); 输出 1234567891020:51:42.489 [小南] c.TestCorrectPosture - 有烟没？[false]20:51:42.493 [小南] c.TestCorrectPosture - 没烟，先歇会！20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了20:51:43.490 [送烟的] c.TestCorrectPosture - 烟到了噢！20:51:43.490 [小南] c.TestCorrectPosture - 有烟没？[true]20:51:43.490 [小南] c.TestCorrectPosture - 可以开始干活了 解决了其它干活的线程阻塞的问题 但如果有其它线程也在等待条件呢？ step312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849new Thread(() -&gt; &#123; synchronized (room) &#123; log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette); if (!hasCigarette) &#123; log.debug(&quot;没烟，先歇会！&quot;); try &#123; room.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette); if (hasCigarette) &#123; log.debug(&quot;可以开始干活了&quot;); &#125; else &#123; log.debug(&quot;没干成活...&quot;); &#125; &#125;&#125;, &quot;小南&quot;).start();new Thread(() -&gt; &#123; synchronized (room) &#123; Thread thread = Thread.currentThread(); log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout); if (!hasTakeout) &#123; log.debug(&quot;没外卖，先歇会！&quot;); try &#123; room.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout); if (hasTakeout) &#123; log.debug(&quot;可以开始干活了&quot;); &#125; else &#123; log.debug(&quot;没干成活...&quot;); &#125; &#125;&#125;, &quot;小女&quot;).start();sleep(1);new Thread(() -&gt; &#123; synchronized (room) &#123; hasTakeout = true; log.debug(&quot;外卖到了噢！&quot;); room.notify(); &#125;&#125;, &quot;送外卖的&quot;).start(); 输出 123456720:53:12.173 [小南] c.TestCorrectPosture - 有烟没？[false]20:53:12.176 [小南] c.TestCorrectPosture - 没烟，先歇会！20:53:12.176 [小女] c.TestCorrectPosture - 外卖送到没？[false]20:53:12.176 [小女] c.TestCorrectPosture - 没外卖，先歇会！20:53:13.174 [送外卖的] c.TestCorrectPosture - 外卖到了噢！20:53:13.174 [小南] c.TestCorrectPosture - 有烟没？[false]20:53:13.174 [小南] c.TestCorrectPosture - 没干成活... notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】 解决方法，改为 notifyAll step41234567new Thread(() -&gt; &#123;synchronized (room) &#123; hasTakeout = true; log.debug(&quot;外卖到了噢！&quot;); room.notifyAll();&#125;&#125;, &quot;送外卖的&quot;).start(); 输出 12345678920:55:23.978 [小南] c.TestCorrectPosture - 有烟没？[false]20:55:23.982 [小南] c.TestCorrectPosture - 没烟，先歇会！20:55:23.982 [小女] c.TestCorrectPosture - 外卖送到没？[false]20:55:23.982 [小女] c.TestCorrectPosture - 没外卖，先歇会！20:55:24.979 [送外卖的] c.TestCorrectPosture - 外卖到了噢！20:55:24.979 [小女] c.TestCorrectPosture - 外卖送到没？[true]20:55:24.980 [小女] c.TestCorrectPosture - 可以开始干活了20:55:24.980 [小南] c.TestCorrectPosture - 有烟没？[false]20:55:24.980 [小南] c.TestCorrectPosture - 没干成活... 用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了 解决方法，用 while + wait，当条件不成立，再次 wait step5将 if 改为 while 12345678if (!hasCigarette) &#123; log.debug(&quot;没烟，先歇会！&quot;); try &#123; room.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 改动后 12345678while (!hasCigarette) &#123; log.debug(&quot;没烟，先歇会！&quot;); try &#123; room.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 输出 1234567820:58:34.322 [小南] c.TestCorrectPosture - 有烟没？[false]20:58:34.326 [小南] c.TestCorrectPosture - 没烟，先歇会！20:58:34.326 [小女] c.TestCorrectPosture - 外卖送到没？[false]20:58:34.326 [小女] c.TestCorrectPosture - 没外卖，先歇会！20:58:35.323 [送外卖的] c.TestCorrectPosture - 外卖到了噢！20:58:35.324 [小女] c.TestCorrectPosture - 外卖送到没？[true]20:58:35.324 [小女] c.TestCorrectPosture - 可以开始干活了20:58:35.324 [小南] c.TestCorrectPosture - 没烟，先歇会！ 1234567891011synchronized(lock) &#123; while(条件不成立) &#123; lock.wait(); &#125;// 干活&#125;//另一个线程synchronized(lock) &#123; lock.notifyAll();&#125; 同步模式之保护性暂停定义要点 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 消费队列可以用来平衡生产和消费的线程资源 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 JDK 中各种阻塞队列，采用的就是这种模式 实现123456789101112131415161718192021222324class GuardedObject &#123; private Object response; private final Object lock = new Object(); public Object get() &#123; synchronized (lock) &#123; // 条件不满足则等待 while (response == null) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return response; &#125; &#125; public void complete(Object response) &#123; synchronized (lock) &#123; // 条件满足，通知等待线程 this.response = response; lock.notifyAll(); &#125; &#125;&#125; 应用一个线程等待另一个线程的执行结果 123456789101112131415161718public static void main(String[] args) &#123; GuardedObject guardedObject = new GuardedObject(); new Thread(() -&gt; &#123; try &#123; // 子线程执行下载 List&lt;String&gt; response = download(); log.debug(&quot;download complete...&quot;); guardedObject.complete(response); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); log.debug(&quot;waiting...&quot;); // 主线程阻塞等待 Object response = guardedObject.get(); log.debug(&quot;get response: [&#123;&#125;] lines&quot;, ((List&lt;String&gt;) response).size());&#125; 执行结果 12308:42:18.568 [main] c.TestGuardedObject - waiting...08:42:23.312 [Thread-0] c.TestGuardedObject - download complete...08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines 带超时版 GuarderObject如果要控制超时时间呢 1234567891011121314151617181920212223242526272829303132333435363738394041class GuardedObjectV2 &#123; private Object response; private final Object lock = new Object(); public Object get(long millis) &#123; synchronized (lock) &#123; // 1) 记录最初时间 long begin = System.currentTimeMillis(); // 2) 已经经历的时间 long timePassed = 0; while (response == null) &#123; // 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等 long waitTime = millis - timePassed; log.debug(&quot;waitTime: &#123;&#125;&quot;, waitTime); if (waitTime &lt;= 0) &#123; log.debug(&quot;break...&quot;); break; &#125; try &#123; lock.wait(waitTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 3) 如果提前被唤醒，这时已经经历的时间假设为 400 timePassed = System.currentTimeMillis() - begin; log.debug(&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;, timePassed, response == null); &#125; return response; &#125; &#125; public void complete(Object response) &#123; synchronized (lock) &#123; // 条件满足，通知等待线程 this.response = response; log.debug(&quot;notify...&quot;); lock.notifyAll(); &#125; &#125; &#125; 测试，没有超时 123456789101112131415public static void main(String[] args) &#123; GuardedObjectV2 v2 = new GuardedObjectV2(); new Thread(() -&gt; &#123; sleep(1); v2.complete(null); sleep(1); v2.complete(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)); &#125;).start(); Object response = v2.get(2500); if (response != null) &#123; log.debug(&quot;get response: [&#123;&#125;] lines&quot;, ((List&lt;String&gt;) response).size()); &#125; else &#123; log.debug(&quot;can&#x27;t get response&quot;); &#125;&#125; 输出 123456708:49:39.917 [main] c.GuardedObjectV2 - waitTime: 250008:49:40.917 [Thread-0] c.GuardedObjectV2 - notify...08:49:40.917 [main] c.GuardedObjectV2 - timePassed: 1003, object is null true08:49:40.917 [main] c.GuardedObjectV2 - waitTime: 149708:49:41.918 [Thread-0] c.GuardedObjectV2 - notify...08:49:41.918 [main] c.GuardedObjectV2 - timePassed: 2004, object is null false08:49:41.918 [main] c.TestGuardedObjectV2 - get response: [3] lines 测试，超时 12// 等待时间不足List&lt;String&gt; lines = v2.get(1500); 输出 12345678908:47:54.963 [main] c.GuardedObjectV2 - waitTime: 150008:47:55.963 [Thread-0] c.GuardedObjectV2 - notify...08:47:55.963 [main] c.GuardedObjectV2 - timePassed: 1002, object is null true08:47:55.963 [main] c.GuardedObjectV2 - waitTime: 49808:47:56.461 [main] c.GuardedObjectV2 - timePassed: 1500, object is null true08:47:56.461 [main] c.GuardedObjectV2 - waitTime: 008:47:56.461 [main] c.GuardedObjectV2 - break...08:47:56.461 [main] c.TestGuardedObjectV2 - can&#x27;t get response08:47:56.963 [Thread-0] c.GuardedObjectV2 - notify... 原理之 join是调用者轮询检查线程 alive 状态 1t1.join(); 等价于下面的代码 123456synchronized (t1) &#123; // 调用者线程进入 t1 的 waitSet 等待, 即 调用 join 方法的 线程, 直到 t1 运行结束 while (t1.isAlive()) &#123; t1.wait(0);// 调用本地方法，会一直睡眠 &#125;&#125; 注意 join 体现的是【保护性暂停】模式，请参考之 多任务版 GuarderObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员 如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理 新增 id 用来标识 Guarded Object 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class GuardedObject &#123; // 标识 Guarded Object private int id; public GuardedObject(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; // 结果 private Object response; // 获取结果 // timeout 表示要等待多久 2000 public Object get(long timeout) &#123; synchronized (this) &#123; // 开始时间 15:00:00 long begin = System.currentTimeMillis(); // 经历的时间 long passedTime = 0; while (response == null) &#123; // 这一轮循环应该等待的时间 long waitTime = timeout - passedTime; // 经历的时间超过了最大等待时间时，退出循环 if (timeout - passedTime &lt;= 0) &#123; break; &#125; try &#123; this.wait(waitTime); // 虚假唤醒 15:00:01 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 求得经历时间 passedTime = System.currentTimeMillis() - begin; // 15:00:02 1s &#125; return response; &#125; &#125; // 产生结果 public void complete(Object response) &#123; synchronized (this) &#123; // 给结果成员变量赋值 this.response = response; this.notifyAll(); &#125; &#125; &#125; 中间解耦类 1234567891011121314151617181920212223class Mailboxes &#123; private static Map&lt;Integer, GuardedObject&gt; boxes = new Hashtable&lt;&gt;(); private static int id = 1; // 产生唯一 id private static synchronized int generateId() &#123; return id++; &#125; public static GuardedObject getGuardedObject(int id) &#123; return boxes.remove(id); &#125; public static GuardedObject createGuardedObject() &#123; GuardedObject go = new GuardedObject(generateId()); boxes.put(go.getId(), go); return go; &#125; public static Set&lt;Integer&gt; getIds() &#123; return boxes.keySet(); &#125;&#125; 业务相关类 12345678910class People extends Thread&#123; @Override public void run() &#123; // 收信 GuardedObject guardedObject = Mailboxes.createGuardedObject(); log.debug(&quot;开始收信 id:&#123;&#125;&quot;, guardedObject.getId()); Object mail = guardedObject.get(5000); log.debug(&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;, guardedObject.getId(), mail); &#125;&#125; 12345678910111213141516class Postman extends Thread &#123; private int id; private String mail; public Postman(int id, String mail) &#123; this.id = id; this.mail = mail; &#125; @Override public void run() &#123; GuardedObject guardedObject = Mailboxes.getGuardedObject(id); log.debug(&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;, id, mail); guardedObject.complete(mail); &#125;&#125; 测试 12345678910public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 3; i++) &#123; new People().start(); &#125; Sleeper.sleep(1); for (Integer id : Mailboxes.getIds()) &#123; new Postman(id, &quot;内容&quot; + id).start(); &#125;&#125; 某次运行结果 12345678910:35:05.689 c.People [Thread-1] - 开始收信 id:310:35:05.689 c.People [Thread-2] - 开始收信 id:110:35:05.689 c.People [Thread-0] - 开始收信 id:210:35:06.688 c.Postman [Thread-4] - 送信 id:2, 内容:内容210:35:06.688 c.Postman [Thread-5] - 送信 id:1, 内容:内容110:35:06.688 c.People [Thread-0] - 收到信 id:2, 内容:内容210:35:06.688 c.People [Thread-2] - 收到信 id:1, 内容:内容110:35:06.688 c.Postman [Thread-3] - 送信 id:3, 内容:内容310:35:06.689 c.People [Thread-1] - 收到信 id:3, 内容:内容3 异步模式之生产者/消费者定义要点 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 消费队列可以用来平衡生产和消费的线程资源 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 JDK 中各种阻塞队列，采用的就是这种模式 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Message &#123; private int id; private Object message; public Message(int id, Object message) &#123; this.id = id; this.message = message; &#125; public int getId() &#123; return id; &#125; public Object getMessage() &#123; return message; &#125;&#125;class MessageQueue &#123; private LinkedList&lt;Message&gt; queue; private int capacity; public MessageQueue(int capacity) &#123; this.capacity = capacity; queue = new LinkedList&lt;&gt;(); &#125; public Message take() &#123; synchronized (queue) &#123; while (queue.isEmpty()) &#123; log.debug(&quot;没货了, wait&quot;); try &#123; queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Message message = queue.removeFirst(); queue.notifyAll(); return message; &#125; &#125; public void put(Message message) &#123; synchronized (queue) &#123; while (queue.size() == capacity) &#123; log.debug(&quot;库存已达上限, wait&quot;); try &#123; queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; queue.addLast(message); queue.notifyAll(); &#125; &#125; &#125; 应用12345678910111213141516171819202122232425MessageQueue messageQueue = new MessageQueue(2);// 4 个生产者线程, 下载任务for (int i = 0; i &lt; 4; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; log.debug(&quot;download...&quot;); List&lt;String&gt; response = Downloader.download(); log.debug(&quot;try put message(&#123;&#125;)&quot;, id); messageQueue.put(new Message(id, response)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;生产者&quot; + i).start();&#125;// 1 个消费者线程, 处理结果new Thread(() -&gt; &#123; while (true) &#123; Message message = messageQueue.take(); List&lt;String&gt; response = (List&lt;String&gt;) message.getMessage(); log.debug(&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;, message.getId(), response.size()); &#125;&#125;, &quot;消费者&quot;).start(); 某次运行结果 12345678910111213141516171810:48:38.070 [生产者3] c.TestProducerConsumer - download...10:48:38.070 [生产者0] c.TestProducerConsumer - download...10:48:38.070 [消费者] c.MessageQueue - 没货了, wait10:48:38.070 [生产者1] c.TestProducerConsumer - download...10:48:38.070 [生产者2] c.TestProducerConsumer - download...10:48:41.236 [生产者1] c.TestProducerConsumer - try put message(1)10:48:41.237 [生产者2] c.TestProducerConsumer - try put message(2)10:48:41.236 [生产者0] c.TestProducerConsumer - try put message(0)10:48:41.237 [生产者3] c.TestProducerConsumer - try put message(3)10:48:41.239 [生产者2] c.MessageQueue - 库存已达上限, wait10:48:41.240 [生产者1] c.MessageQueue - 库存已达上限, wait10:48:41.240 [消费者] c.TestProducerConsumer - take message(0): [3] lines # 这里其实上面两个生产不了的有一个已经生产了，库存又满了10:48:41.240 [生产者2] c.MessageQueue - 库存已达上限, wait10:48:41.240 [消费者] c.TestProducerConsumer - take message(3): [3] lines10:48:41.240 [消费者] c.TestProducerConsumer - take message(1): [3] lines10:48:41.240 [消费者] c.TestProducerConsumer - take message(2): [3] lines10:48:41.240 [消费者] c.MessageQueue - 没货了, wait 9. Park &amp; Unpark9.1 基本使用它们是 LockSupport 类中的方法 1234// 暂停当前线程LockSupport.park();// 恢复某个线程的运行LockSupport.unpark(暂停线程对象) 先 park 再 unpark 1234567891011Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;start...&quot;); sleep(1); log.debug(&quot;park...&quot;); LockSupport.park(); log.debug(&quot;resume...&quot;);&#125;,&quot;t1&quot;);t1.start();sleep(2);log.debug(&quot;unpark...&quot;);LockSupport.unpark(t1); 输出 123418:42:52.585 c.TestParkUnpark [t1] - start...18:42:53.589 c.TestParkUnpark [t1] - park...18:42:54.583 c.TestParkUnpark [main] - unpark...18:42:54.583 c.TestParkUnpark [t1] - resume... 先 unpark 再 park 1234567891011Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;start...&quot;); sleep(2); log.debug(&quot;park...&quot;); LockSupport.park(); log.debug(&quot;resume...&quot;);&#125;, &quot;t1&quot;);t1.start();sleep(1);log.debug(&quot;unpark...&quot;);LockSupport.unpark(t1); 输出 123418:43:50.765 c.TestParkUnpark [t1] - start...18:43:51.764 c.TestParkUnpark [main] - unpark...18:43:52.769 c.TestParkUnpark [t1] - park...18:43:52.769 c.TestParkUnpark [t1] - resume... 9.2 特点与 Object 的 wait &amp; notify 相比 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify 9.3 原理之 park &amp; unpark每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻 线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足） 调用 park 就是要看需不需要停下来歇息 如果备用干粮耗尽，那么钻进帐篷歇息（park之前没有unpark） 如果备用干粮充足，那么不需停留，继续前进 （park之前有unpark） 调用 unpark，就好比令干粮充足 如果这时线程还在帐篷，就唤醒让他继续前进 （park之后有unpark） 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留，继续前进 因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮 (park之前有多次unpark，只对首个park起作用) 当前线程调用 Unsafe.park() 方法 检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁 线程进入 _cond 条件变量阻塞 设置 _counter = 0 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 唤醒 _cond 条件变量中的 Thread_0 Thread_0 恢复运行 设置 _counter 为 0 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 当前线程调用 Unsafe.park() 方法 检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行 设置 _counter 为 0 10. 重新理解线程状态转换 假设有线程 Thread t 情况 1 NEW --&gt; RUNNABLE 当调用 t.start() 方法时，由 NEW --&gt; RUNNABLE 情况 2 RUNNABLE &lt;--&gt; WAITINGt 线程用 synchronized(obj) 获取了对象锁后 调用 obj.wait() 方法时，t 线程从 RUNNABLE --&gt; WAITING 调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 竞争锁成功，t 线程从 WAITING --&gt; RUNNABLE 竞争锁失败，t 线程从 WAITING --&gt; BLOCKED 1234567891011121314151617181920212223242526272829303132public class TestWaitNotify &#123; final static Object obj = new Object(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (obj) &#123; log.debug(&quot;执行....&quot;); try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(&quot;其它代码....&quot;); // 断点 &#125; &#125;,&quot;t1&quot;).start(); new Thread(() -&gt; &#123; synchronized (obj) &#123; log.debug(&quot;执行....&quot;); try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(&quot;其它代码....&quot;); // 断点 &#125; &#125;,&quot;t2&quot;).start(); sleep(0.5); log.debug(&quot;唤醒 obj 上其它线程&quot;); synchronized (obj) &#123; obj.notifyAll(); // 唤醒obj上所有等待线程 断点 &#125; &#125;&#125; 情况 3 RUNNABLE &lt;--&gt; WAITING 当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --&gt; WAITING 注意是当前线程在t 线程对象的监视器上等待 t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --&gt; RUNNABLE 情况 4 RUNNABLE &lt;--&gt; WAITING 当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --&gt; WAITING 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING --&gt;RUNNABLE 情况 5 RUNNABLE &lt;--&gt; TIMED_WAITINGt 线程用 synchronized(obj) 获取了对象锁后 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --&gt; TIMED_WAITING t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 竞争锁成功，t 线程从 TIMED_WAITING --&gt; RUNNABLE 竞争锁失败，t 线程从 TIMED_WAITING --&gt; BLOCKED 情况 6 RUNNABLE &lt;--&gt; TIMED_WAITING 当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --&gt; TIMED_WAITING 注意是当前线程在t 线程对象的监视器上等待 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从TIMED_WAITING --&gt; RUNNABLE 情况 7 RUNNABLE &lt;--&gt; TIMED_WAITING 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --&gt; TIMED_WAITING 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING --&gt; RUNNABLE 情况 8 RUNNABLE &lt;--&gt; TIMED_WAITING 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE --&gt; TIMED_WAITING 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从TIMED_WAITING--&gt; RUNNABLE 情况 9 RUNNABLE &lt;--&gt; BLOCKED t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --&gt; BLOCKED 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED --&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED 情况 10 RUNNABLE &lt;–&gt; TERMINATED当前线程所有代码运行完毕，进入 TERMINATED 11. 多把锁11.1 多把不相干的锁一间大屋子有两个功能：睡觉、学习，互不相干。 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低 解决方法是准备多个房间（多个对象锁） 例如 1234567891011121314class BigRoom &#123; public void sleep() &#123; synchronized (this) &#123; log.debug(&quot;sleeping 2 小时&quot;); Sleeper.sleep(2); &#125; &#125; public void study() &#123; synchronized (this) &#123; log.debug(&quot;study 1 小时&quot;); Sleeper.sleep(1); &#125; &#125;&#125; 执行 1234567BigRoom bigRoom = new BigRoom();new Thread(() -&gt; &#123; bigRoom.compute();&#125;,&quot;小南&quot;).start();new Thread(() -&gt; &#123; bigRoom.sleep();&#125;,&quot;小女&quot;).start(); 某次结果 1212:13:54.471 [小南] c.BigRoom - study 1 小时12:13:55.476 [小女] c.BigRoom - sleeping 2 小时 改进 12345678910111213141516171819class BigRoom &#123; private final Object studyRoom = new Object(); private final Object bedRoom = new Object(); public void sleep() &#123; synchronized (bedRoom) &#123; log.debug(&quot;sleeping 2 小时&quot;); Sleeper.sleep(2); &#125; &#125; public void study() &#123; synchronized (studyRoom) &#123; log.debug(&quot;study 1 小时&quot;); Sleeper.sleep(1); &#125; &#125; &#125; 某次执行结果 1212:15:35.069 [小南] c.BigRoom - study 1 小时12:15:35.069 [小女] c.BigRoom - sleeping 2 小时 将锁的粒度细分 好处，是可以增强并发度 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 12. 活跃性12.1 死锁有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁 t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 、 例： 123456789101112131415161718192021222324252627Object A = new Object();Object B = new Object();Thread t1 = new Thread(() -&gt; &#123; synchronized (A) &#123; log.debug(&quot;lock A&quot;); sleep(1); synchronized (B) &#123; log.debug(&quot;lock B&quot;); log.debug(&quot;操作...&quot;); &#125; &#125;&#125;, &quot;t1&quot;);Thread t2 = new Thread(() -&gt; &#123; synchronized (B) &#123; log.debug(&quot;lock B&quot;); sleep(0.5); synchronized (A) &#123; log.debug(&quot;lock A&quot;); log.debug(&quot;操作...&quot;); &#125; &#125;&#125;, &quot;t2&quot;);t1.start();t2.start(); 结果 1212:22:06.962 [t2] c.TestDeadLock - lock B12:22:06.962 [t1] c.TestDeadLock - lock A 12.2 定位死锁 检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁： 1234567cmd &gt; jpsPicked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-812320 Jps22816 KotlinCompileDaemon33200 TestDeadLock // JVM 进程11508 Main28468 Launcher 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849cmd &gt; jstack 33200Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-82018-12-29 05:51:40Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000003525000 nid=0x2f60 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Thread-1&quot; #12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000] java.lang.Thread.State: BLOCKED (on object monitor) at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28) - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object) - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object) at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) &quot;Thread-0&quot; #11 prio=5 os_prio=0 tid=0x000000001eb68800 nid=0x1b28 waiting for monitor entry [0x000000001f44f000] java.lang.Thread.State: BLOCKED (on object monitor) at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15) - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object) - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object) at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:745)// 略去部分输出 Found one Java-level deadlock:============================= &quot;Thread-1&quot;:waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),which is held by &quot;Thread-0&quot; &quot;Thread-0&quot;:waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),which is held by &quot;Thread-1&quot; Java stack information for the threads listed above:=================================================== &quot;Thread-1&quot;:at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28) - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object) - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object) at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) &quot;Thread-0&quot;:at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15) - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object) - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object) at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) Found 1 deadlock. 避免死锁要注意加锁顺序 另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查 12.3 哲学家就餐问题 有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 筷子类 12345678910class Chopstick &#123; String name; public Chopstick(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;筷子&#123;&quot; + name + &#x27;&#125;&#x27;; &#125;&#125; 哲学家类 12345678910111213141516171819202122232425262728class Philosopher extends Thread &#123; Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) &#123; super(name); this.left = left; this.right = right; &#125; private void eat() &#123; log.debug(&quot;eating...&quot;); Sleeper.sleep(1); &#125; @Override public void run() &#123; while (true) &#123; // 获得左手筷子 synchronized (left) &#123; // 获得右手筷子 synchronized (right) &#123; // 吃饭 eat(); &#125; // 放下右手筷子 &#125; // 放下左手筷子 &#125; &#125;&#125; 就餐 12345678910Chopstick c1 = new Chopstick(&quot;1&quot;);Chopstick c2 = new Chopstick(&quot;2&quot;);Chopstick c3 = new Chopstick(&quot;3&quot;);Chopstick c4 = new Chopstick(&quot;4&quot;);Chopstick c5 = new Chopstick(&quot;5&quot;);new Philosopher(&quot;苏格拉底&quot;, c1, c2).start();new Philosopher(&quot;柏拉图&quot;, c2, c3).start();new Philosopher(&quot;亚里士多德&quot;, c3, c4).start();new Philosopher(&quot;赫拉克利特&quot;, c4, c5).start();new Philosopher(&quot;阿基米德&quot;, c5, c1).start(); 执行不多会，就执行不下去了 1234512:33:15.575 [苏格拉底] c.Philosopher - eating...12:33:15.575 [亚里士多德] c.Philosopher - eating...12:33:16.580 [阿基米德] c.Philosopher - eating...12:33:17.580 [阿基米德] c.Philosopher - eating...// 卡在这里, 不向下运行 使用 jconsole 检测死锁，发现 1234567891011121314151617181920212223242526272829303132333435-------------------------------------------------------------------------名称: 阿基米德状态: cn.itcast.Chopstick@1540e19d (筷子1) 上的BLOCKED, 拥有者: 苏格拉底总阻止数: 2, 总等待数: 1堆栈跟踪:cn.itcast.Philosopher.run(TestDinner.java:48)- 已锁定 cn.itcast.Chopstick@6d6f6e28 (筷子5)-------------------------------------------------------------------------名称: 苏格拉底状态: cn.itcast.Chopstick@677327b6 (筷子2) 上的BLOCKED, 拥有者: 柏拉图总阻止数: 2, 总等待数: 1堆栈跟踪:cn.itcast.Philosopher.run(TestDinner.java:48)- 已锁定 cn.itcast.Chopstick@1540e19d (筷子1)-------------------------------------------------------------------------名称: 柏拉图状态: cn.itcast.Chopstick@14ae5a5 (筷子3) 上的BLOCKED, 拥有者: 亚里士多德总阻止数: 2, 总等待数: 0堆栈跟踪:cn.itcast.Philosopher.run(TestDinner.java:48)- 已锁定 cn.itcast.Chopstick@677327b6 (筷子2)-------------------------------------------------------------------------名称: 亚里士多德状态: cn.itcast.Chopstick@7f31245a (筷子4) 上的BLOCKED, 拥有者: 赫拉克利特总阻止数: 1, 总等待数: 1堆栈跟踪:cn.itcast.Philosopher.run(TestDinner.java:48)- 已锁定 cn.itcast.Chopstick@14ae5a5 (筷子3)-------------------------------------------------------------------------名称: 赫拉克利特状态: cn.itcast.Chopstick@6d6f6e28 (筷子5) 上的BLOCKED, 拥有者: 阿基米德总阻止数: 2, 总等待数: 0堆栈跟踪:cn.itcast.Philosopher.run(TestDinner.java:48)- 已锁定 cn.itcast.Chopstick@7f31245a (筷子4) 这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况 12.4 活锁活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如 12345678910111213141516171819202122232425public class TestLiveLock &#123; static volatile int count = 10; static final Object lock = new Object(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; // 期望减到 0 退出循环 while (count &gt; 0) &#123; sleep(0.2); count--; log.debug(&quot;count: &#123;&#125;&quot;, count); &#125; &#125;, &quot;t1&quot;).start(); new Thread(() -&gt; &#123; // 期望超过 20 退出循环 while (count &lt; 20) &#123; sleep(0.2); count++; log.debug(&quot;count: &#123;&#125;&quot;, count); &#125; &#125;, &quot;t2&quot;).start(); &#125;&#125; 12.5 饥饿很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题 下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题 13. ReentrantLock相对于 synchronized 它具备如下特点 可中断 可以设置超时时间 可以设置为公平锁 支持多个条件变量 与 synchronized 一样，都支持可重入 基本语法 123456789// 获取锁reentrantLock.lock();try &#123; // 临界区&#125; finally &#123; // 释放锁 reentrantLock.unlock();&#125; 13.1 可重入可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁，如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住 12345678910111213141516171819202122232425262728293031323334static ReentrantLock lock = new ReentrantLock();public static void main(String[] args) &#123; method1();&#125;public static void method1() &#123; lock.lock(); try &#123; log.debug(&quot;execute method1&quot;); method2(); &#125; finally &#123; lock.unlock(); &#125;&#125;public static void method2() &#123; lock.lock(); try &#123; log.debug(&quot;execute method2&quot;); method3(); &#125; finally &#123; lock.unlock(); &#125;&#125;public static void method3() &#123; lock.lock(); try &#123; log.debug(&quot;execute method3&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125; 输出 12317:59:11.862 [main] c.TestReentrant - execute method117:59:11.865 [main] c.TestReentrant - execute method217:59:11.865 [main] c.TestReentrant - execute method3 13.2 可打断示例 12345678910111213141516171819202122232425262728ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;启动...&quot;); try &#123; lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); log.debug(&quot;等锁的过程中被打断&quot;); return; &#125; try &#123; log.debug(&quot;获得了锁&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125;, &quot;t1&quot;);lock.lock();log.debug(&quot;获得了锁&quot;);t1.start();try &#123; sleep(1); t1.interrupt(); log.debug(&quot;执行打断&quot;);&#125; finally &#123; lock.unlock();&#125; 输出 123456789101112131418:02:40.520 [main] c.TestInterrupt - 获得了锁18:02:40.524 [t1] c.TestInterrupt - 启动...18:02:41.530 [main] c.TestInterrupt - 执行打断java.lang.InterruptedExceptionatjava.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)atjava.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)at java.lang.Thread.run(Thread.java:748)18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断 注意 如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断 可打断只能在阻塞时被打断（打断后只会再重新执行循环，并不是真正打断），而获取锁后是不可打断的 123456789101112131415161718192021222324ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;启动...&quot;); lock.lock(); try &#123; log.debug(&quot;获得了锁&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125;, &quot;t1&quot;);lock.lock();log.debug(&quot;获得了锁&quot;);t1.start();try &#123; sleep(1); t1.interrupt(); log.debug(&quot;执行打断&quot;); sleep(1);&#125; finally &#123; log.debug(&quot;释放了锁&quot;); lock.unlock();&#125; 输出 1234518:06:56.261 [main] c.TestInterrupt - 获得了锁18:06:56.265 [t1] c.TestInterrupt - 启动...18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁18:06:58.267 [main] c.TestInterrupt - 释放了锁18:06:58.267 [t1] c.TestInterrupt - 获得了锁 13.3 锁超时立刻失败 12345678910111213141516171819202122ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;启动...&quot;); if (!lock.tryLock()) &#123; log.debug(&quot;获取立刻失败，返回&quot;); return; &#125; try &#123; log.debug(&quot;获得了锁&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125;, &quot;t1&quot;);lock.lock();log.debug(&quot;获得了锁&quot;);t1.start();try &#123; sleep(2);&#125; finally &#123; lock.unlock();&#125; 输出 12318:15:02.918 [main] c.TestTimeout - 获得了锁18:15:02.921 [t1] c.TestTimeout - 启动...18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回 超时失败 1234567891011121314151617181920212223242526ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;启动...&quot;); try &#123; if (!lock.tryLock(1, TimeUnit.SECONDS)) &#123; log.debug(&quot;获取等待 1s 后失败，返回&quot;); return; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; log.debug(&quot;获得了锁&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125;, &quot;t1&quot;);lock.lock();log.debug(&quot;获得了锁&quot;);t1.start();try &#123; sleep(2);&#125; finally &#123; lock.unlock();&#125; 输出 12318:19:40.537 [main] c.TestTimeout - 获得了锁18:19:40.544 [t1] c.TestTimeout - 启动...18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回 使用 tryLock 解决哲学家就餐问题 123456789101112class Chopstick extends ReentrantLock &#123; String name; public Chopstick(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;筷子&#123;&quot; + name + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435class Philosopher extends Thread &#123; Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) &#123; super(name); this.left = left; this.right = right; &#125; @Override public void run() &#123; while (true) &#123; // 尝试获得左手筷子 if (left.tryLock()) &#123; try &#123; // 尝试获得右手筷子 if (right.tryLock()) &#123; try &#123; eat(); &#125; finally &#123; right.unlock(); &#125; &#125; &#125; finally &#123; left.unlock(); &#125; &#125; &#125; &#125; private void eat() &#123; log.debug(&quot;eating...&quot;); Sleeper.sleep(1); &#125;&#125; 13.4 公平锁ReentrantLock 默认是不公平的 123456789101112131415161718192021222324ReentrantLock lock = new ReentrantLock(false);lock.lock();for (int i = 0; i &lt; 500; i++) &#123; new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot; running...&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;, &quot;t&quot; + i).start();&#125;// 1s 之后去争抢锁Thread.sleep(1000);new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; start...&quot;); lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot; running...&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125;, &quot;强行插入&quot;).start();lock.unlock(); 强行插入，有机会在中间输出 注意：该实验不一定总能复现 123456789101112t39 running...t40 running...t41 running...t42 running...t43 running...强行插入 start...强行插入 running...t44 running...t45 running...t46 running...t47 running...t49 running... 改为公平锁后 1ReentrantLock lock = new ReentrantLock(true); 强行插入，总是在最后输出 12345678910t465 running...t464 running...t477 running...t442 running...t468 running...t493 running...t482 running...t485 running...t481 running...强行插入 running... 公平锁一般没有必要，会降低并发度，后面分析原理时会讲解 13.5 条件变量synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 synchronized 是那些不满足条件的线程都在一间休息室等消息 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒 使用要点： await 前需要获得锁 await 执行后，会释放锁（透明释放锁，关键，可以有多个线程同时处于waing），进入 conditionObject 等待 await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 竞争 lock 锁成功后，从 await 后继续执行 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static ReentrantLock lock = new ReentrantLock();static Condition waitCigaretteQueue = lock.newCondition();static Condition waitbreakfastQueue = lock.newCondition();static volatile boolean hasCigrette = false;static volatile boolean hasBreakfast = false;public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; lock.lock(); while (!hasCigrette) &#123; try &#123; waitCigaretteQueue.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;等到了它的烟&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; lock.lock(); while (!hasBreakfast) &#123; try &#123; waitbreakfastQueue.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;等到了它的早餐&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;).start(); sleep(1); sendBreakfast(); sleep(1); sendCigarette();&#125;private static void sendCigarette() &#123; lock.lock(); try &#123; log.debug(&quot;送烟来了&quot;); hasCigrette = true; waitCigaretteQueue.signal(); &#125; finally &#123; lock.unlock(); &#125;&#125;private static void sendBreakfast() &#123; lock.lock(); try &#123; log.debug(&quot;送早餐来了&quot;); hasBreakfast = true; waitbreakfastQueue.signal(); &#125; finally &#123; lock.unlock(); &#125;&#125; 输出 123418:52:27.680 [main] c.TestCondition - 送早餐来了18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐18:52:28.683 [main] c.TestCondition - 送烟来了18:52:28.683 [Thread-0] c.TestCondition - 等到了它的烟 13.6 同步模式之顺序控制固定运行顺序比如，必须先 2 后 1 打印 1. wait notify 版12345678910111213141516171819202122232425262728293031// 用来同步的对象static Object obj = new Object();// t2 运行标记， 代表 t2 是否执行过static boolean t2runed = false;public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; synchronized (obj) &#123; // 如果 t2 没有执行过 while (!t2runed) &#123; try &#123; // t1 先等一会 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println(1); &#125;); Thread t2 = new Thread(() -&gt; &#123; System.out.println(2); synchronized (obj) &#123; // 修改运行标记 t2runed = true; // 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll） obj.notifyAll(); &#125; &#125;); t1.start(); t2.start();&#125; 2. Park Unpark 版可以看到，实现上很麻烦： 首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该wait 第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决此问题 最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个 可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目： 12345678910111213Thread t1 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; // 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行 LockSupport.park(); System.out.println(&quot;1&quot;);&#125;);Thread t2 = new Thread(() -&gt; &#123; System.out.println(&quot;2&quot;); // 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』） LockSupport.unpark(t1);&#125;);t1.start();t2.start(); park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，不需要『同步对象』和『运行标记』 交替输出线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现 wait notify 版123456789101112131415161718192021222324class SyncWaitNotify &#123; private int flag; private int loopNumber; public SyncWaitNotify(int flag, int loopNumber) &#123; this.flag = flag; this.loopNumber = loopNumber; &#125; public void print(int waitFlag, int nextFlag, String str) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; synchronized (this) &#123; while (this.flag != waitFlag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(str); flag = nextFlag; this.notifyAll(); &#125; &#125; &#125;&#125; 12345678910SyncWaitNotify syncWaitNotify = new SyncWaitNotify(1, 5);new Thread(() -&gt; &#123;syncWaitNotify.print(1, 2, &quot;a&quot;);&#125;).start();new Thread(() -&gt; &#123;syncWaitNotify.print(2, 3, &quot;b&quot;);&#125;).start();new Thread(() -&gt; &#123;syncWaitNotify.print(3, 1, &quot;c&quot;);&#125;).start(); Lock 条件变量版123456789101112131415161718192021222324252627282930class AwaitSignal extends ReentrantLock &#123; public void start(Condition first) &#123; this.lock(); try &#123; log.debug(&quot;start&quot;); first.signal(); &#125; finally &#123; this.unlock(); &#125; &#125; public void print(String str, Condition current, Condition next) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; this.lock(); try &#123; current.await(); log.debug(str); next.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; this.unlock(); &#125; &#125; &#125; // 循环次数 private int loopNumber; public AwaitSignal(int loopNumber) &#123; this.loopNumber = loopNumber; &#125;&#125; 12345678910111213141516171819AwaitSignal as = new AwaitSignal(5);Condition aWaitSet = as.newCondition();Condition bWaitSet = as.newCondition();Condition cWaitSet = as.newCondition();new Thread(() -&gt; &#123; as.print(&quot;a&quot;, aWaitSet, bWaitSet);&#125;).start();new Thread(() -&gt; &#123; as.print(&quot;b&quot;, bWaitSet, cWaitSet);&#125;).start();new Thread(() -&gt; &#123; as.print(&quot;c&quot;, cWaitSet, aWaitSet);&#125;).start();as.start(aWaitSet); 注意 该实现没有考虑 a，b，c 线程都就绪再开始 Park Unpark 版1234567891011121314151617181920212223242526272829303132333435363738394041424344class SyncPark &#123; private int loopNumber; private Thread[] threads; public SyncPark(int loopNumber) &#123; this.loopNumber = loopNumber; &#125; public void setThreads(Thread... threads) &#123; this.threads = threads; &#125; public void print(String str) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; LockSupport.park(); System.out.print(str); LockSupport.unpark(nextThread()); &#125; &#125; private Thread nextThread() &#123; Thread current = Thread.currentThread(); int index = 0; for (int i = 0; i &lt; threads.length; i++) &#123; if(threads[i] == current) &#123; index = i; break; &#125; &#125; if(index &lt; threads.length - 1) &#123; return threads[index+1]; &#125; else &#123; return threads[0]; &#125; &#125; public void start() &#123; for (Thread thread : threads) &#123; thread.start(); &#125; LockSupport.unpark(threads[0]); &#125; &#125; 123456789101112SyncPark syncPark = new SyncPark(5);Thread t1 = new Thread(() -&gt; &#123; syncPark.print(&quot;a&quot;);&#125;);Thread t2 = new Thread(() -&gt; &#123; syncPark.print(&quot;b&quot;);&#125;);Thread t3 = new Thread(() -&gt; &#123; syncPark.print(&quot;c\\n&quot;);&#125;);syncPark.setThreads(t1, t2, t3);syncPark.start(); 14. 本章小结本章我们需要重点掌握的是 分析多线程访问共享资源时，哪些代码片段属于临界区 使用 synchronized 互斥解决临界区的线程安全问题 掌握 synchronized 锁对象语法 掌握 synchronzied 加载成员方法和静态方法语法 掌握 wait/notify 同步方法 使用 lock 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 学会分析变量的线程安全性、掌握常见线程安全类的使用 了解线程活跃性问题：死锁、活锁、饥饿 应用方面 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果 原理方面 monitor、synchronized 、wait/notify 原理 synchronized 进阶原理 park &amp; unpark 原理 模式方面 同步模式之保护性暂停 异步模式之生产者消费者 同步模式之顺序控制 三、共享模型之内存1. 本章内容上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性 这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题 2. Java 内存模型JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。 JMM 体现在以下几个方面 原子性 - 保证指令不会受到线程上下文切换的影响 可见性 - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响 3. 可见性3.1 退不出的循环先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止： 1234567891011static boolean run = true;public static void main(String[] args) throws InterruptedException &#123;Thread t = new Thread(()-&gt;&#123;while(run)&#123;// ....&#125;&#125;);t.start();sleep(1);run = false; // 线程t不会如预想的停下来&#125; 为什么呢？分析一下： 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值 3.2 解决方法volatile（易变关键字） 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile 变量都是直接操作主存 3.3 可见性 vs 原子性前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的： 123456getstatic run // 线程 t 获取 run truegetstatic run // 线程 t 获取 run truegetstatic run // 线程 t 获取 run truegetstatic run // 线程 t 获取 run trueputstatic run // 线程 main 修改 run 为 false， 仅此一次getstatic run // 线程 t 获取 run false 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错 123456789// 假设i的初始值为0getstatic i // 线程2-获取静态变量i的值 线程内i=0getstatic i // 线程1-获取静态变量i的值 线程内i=0iconst_1 // 线程1-准备常量1iadd // 线程1-自增 线程内i=1putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1iconst_1 // 线程2-准备常量1isub // 线程2-自减 线程内i=-1putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？ 3.4 模式之两阶段终止Two Phase Termination 在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。 错误思路 使用线程对象的 stop() 方法停止线程 stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁 使用 System.exit(int) 方法停止线程 目的仅是停止一个线程，但这种做法会让整个程序都停止 两阶段终止模式 (1) 利用 isInterruptedinterrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行 12345678910111213141516171819202122232425class TPTInterrupt &#123; private Thread thread; public void start()&#123; thread = new Thread(() -&gt; &#123; while(true) &#123; Thread current = Thread.currentThread(); if(current.isInterrupted()) &#123; log.debug(&quot;料理后事&quot;); break; &#125; try &#123; Thread.sleep(1000); log.debug(&quot;将结果保存&quot;); &#125; catch (InterruptedException e) &#123; current.interrupt(); &#125; // 执行监控操作 &#125; &#125;,&quot;监控线程&quot;); thread.start(); &#125; public void stop() &#123; thread.interrupt(); &#125;&#125; 调用 12345TPTInterrupt t = new TPTInterrupt();t.start();Thread.sleep(3500);log.debug(&quot;stop&quot;);t.stop(); 结果 1234511:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存11:49:45.413 c.TestTwoPhaseTermination [main] - stop11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事 (2) 利用停止标记12345678910111213141516171819202122232425262728// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见class TPTVolatile &#123; private Thread thread; private volatile boolean stop = false; public void start()&#123; thread = new Thread(() -&gt; &#123; while(true) &#123; Thread current = Thread.currentThread(); if(stop) &#123; log.debug(&quot;料理后事&quot;); break; &#125; try &#123; Thread.sleep(1000); log.debug(&quot;将结果保存&quot;); &#125; catch (InterruptedException e) &#123; &#125; // 执行监控操作 &#125; &#125;,&quot;监控线程&quot;); thread.start(); &#125; public void stop() &#123; stop = true; thread.interrupt(); &#125;&#125; 调用 12345TPTVolatile t = new TPTVolatile();t.start();Thread.sleep(3500);log.debug(&quot;stop&quot;);t.stop(); 结果 1234511:54:52.003 c.TPTVolatile [监控线程] - 将结果保存11:54:53.006 c.TPTVolatile [监控线程] - 将结果保存11:54:54.007 c.TPTVolatile [监控线程] - 将结果保存11:54:54.502 c.TestTwoPhaseTermination [main] - stop11:54:54.502 c.TPTVolatile [监控线程] - 料理后事 (3) 案例：JVM 内存监控3.5 模式之Balking定义Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回 实现例如： 1234567891011121314public class MonitorService &#123; // 用来表示是否已经有线程已经在执行启动了 private volatile boolean starting; public void start() &#123; log.info(&quot;尝试启动监控线程...&quot;); synchronized (this) &#123; if (starting) &#123; return; &#125; starting = true; &#125; // 真正启动监控线程... &#125;&#125; 当前端页面多次点击按钮调用 start 时 输出 12345[http-nio-8080-exec-1] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(false)[http-nio-8080-exec-1] cn.itcast.monitor.service.MonitorService - 监控线程已启动...[http-nio-8080-exec-2] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true)[http-nio-8080-exec-3] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true)[http-nio-8080-exec-4] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true) 它还经常用来实现线程安全的单例 123456789101112public final class Singleton &#123; private Singleton() &#123; &#125; private static Singleton INSTANCE = null; public static synchronized Singleton getInstance() &#123; if (INSTANCE != null) &#123; return INSTANCE; &#125; INSTANCE = new Singleton(); return INSTANCE; &#125;&#125; 对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。 4. 有序性JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码 12345static int i;static int j;// 在某个线程内执行如下赋值操作i = ...;j = ...; 可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是 12i = ...;j = ...; 也可以是 12j = ...;i = ...; 这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU执行指令的原理来理解一下吧 4.1 原理之指令级并行事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 这 5 个阶段 术语参考： instruction fetch (IF) instruction decode (ID) execute (EX) memory access (MEM) register write back (WB) 在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在 80’s 中叶到 90’s 中叶占据了计算架构的重要地位。 提示： 分阶段，分工是提升效率的关键！ 指令重排的前提是，重排指令不能影响结果，例如 1234567// 可以重排的例子int a = 10; // 指令1int b = 20; // 指令2System.out.println( a + b );// 不能重排的例子int a = 10; // 指令1int b = a - 5; // 指令2 参考： Scoreboarding and the Tomasulo algorithm (which is similar to scoreboarding but makes use of register renaming) are two of the most common techniques for implementing out-of-order execution and instruction-level parallelism. 现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。 提示： 奔腾四（Pentium 4）支持高达 35 级流水线，但由于功耗太高被废弃 4.2 诡异的结果123456789101112131415int num = 0;boolean ready = false;// 线程1 执行此方法public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125;&#125;// 线程2 执行此方法public void actor2(I_Result r) &#123; num = 2; ready = true;&#125; I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ 有同学这么分析 情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1 情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1 情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了） 但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！ 这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2 相信很多人已经晕了 😵😵😵 这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现： 借助 java 并发压测工具 jcstress https://wiki.openjdk.java.net/display/CodeTools/jcstress 1mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -DartifactId=ordering -Dversion=1.0 创建 maven 项目，提供如下测试类 123456789101112131415161718192021@JCStressTest@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)@Statepublic class ConcurrencyTest &#123; int num = 0; boolean ready = false; @Actor public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125; &#125; @Actor public void actor2(I_Result r) &#123; num = 2; ready = true; &#125;&#125; 执行 12mvn clean installjava -jar target/jcstress.jar 会输出我们感兴趣的结果，摘录其中一次结果： 123456789101112131415161718192021222324*** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 2 matching test results. [OK] cn.itcast.ConcurrencyTest1 (JVM args: [-XX:-TieredCompilation]) Observed state Occurrences Expectation Interpretation 0 3,943 ACCEPTABLE_INTERESTING !!!! 1 20,090,265 ACCEPTABLE ok 4 26,615,603 ACCEPTABLE ok [OK] cn.itcast.ConcurrencyTest1 (JVM args: []) Observed state Occurrences Expectation Interpretation 0 1,714 ACCEPTABLE_INTERESTING !!!! 1 18,118,845 ACCEPTABLE ok 4 29,707,292 ACCEPTABLE ok 可以看到，出现结果为 0 的情况有 3,943 次，虽然次数相对很少，但毕竟是出现了。 4.3 解决方法volatile 修饰的变量，可以禁用指令重排 123456789101112131415161718192021@JCStressTest@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)@Statepublic class ConcurrencyTest &#123; int num = 0; volatile boolean ready = false; @Actor public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125; &#125; @Actor public void actor2(I_Result r) &#123; num = 2; ready = true; &#125;&#125; 结果为： 123*** INTERESTING testsSome interesting behaviors observed. This is for the plain curiosity.0 matching test results. 4.4 原理之 volatilevolatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） 对 volatile 变量的写指令后会加入写屏障 对 volatile 变量的读指令前会加入读屏障 (1) 如何保证可见性 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 12345public void actor2(I_Result r) &#123; num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障&#125; 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据 123456789public void actor1(I_Result r) &#123; // 读屏障 // ready 是 volatile 读取值带读屏障 if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125;&#125; (2) 如何保证有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 12345public void actor2(I_Result r) &#123; num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障&#125; 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 123456789public void actor1(I_Result r) &#123; // 读屏障 // ready 是 volatile 读取值带读屏障 if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125;&#125; 还是那句话，不能解决指令交错： 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去 而有序性的保证也只是保证了本线程内相关代码不被重排序 (3) double-checked locking 问题以著名的 double-checked locking 单例模式为例 123456789101112131415public final class Singleton &#123; private Singleton() &#123; &#125; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; if(INSTANCE == null) &#123; // t2 // 首次访问会同步，而之后的使用没有 synchronized synchronized(Singleton.class) &#123; if (INSTANCE == null) &#123; // t1 INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 以上的实现特点是： 懒惰实例化 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为： 123456789101112131415161718192021220: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; # 获取常量池 索引， 压入到 操作数栈 中3: ifnonnull 37 # 弹出 操作数 栈顶 元素， 判断 元素 是否 为 null6: ldc #3 // class cn/itcast/n5/Singleton # 将 前面 getstatic 获取的 Singleton 压入到 操作数栈8: dup # 复制 操作数 栈顶 值，并将其压入 栈顶 ，此时操作数栈上有连续相同的两个对象地址9: astore_0 # 弹出栈顶元素，将栈顶值 保存到成员变量对应的 slots(0) 槽10: monitorenter # 开启 sychronized 锁11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;14: ifnonnull 2717: new #3 // class cn/itcast/n5/Singleton 在 java 堆上为 Singleton 对象分配 内存空间，并将其 压入 操作数 栈顶20: dup # 复制 操作数 栈顶 值，并将其压入 栈顶 ，此时操作数栈上有连续相同的两个对象地址21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V # 调用实例初始化方法，从操作数栈顶弹出一个this引用24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; # 弹出操作数 栈顶元素，并将 栈顶值 赋值给 成员变量 INSTANCE27: aload_0 # 将成员变量表 slots(1) 槽（已经 实例好的 INSTANCE ） 压入到 操作数 栈中28: monitorexit # 关闭 sychronized 锁29: goto 37 32: astore_1 # 将 抛出异常的值 保存到 成员变量表 slots(2) 中，等下会取出33: aload_0 # 加载 INSTANCE 值 到 操作数栈 第二个 if 中 INSTANCE 不是 null 会执行，相当于 return INSTANCE34: monitorexit # 异常导致 非 正常 锁 关闭，这里 会再次去 关闭 synchronized 锁35: aload_1 # 取出 slots(2), 压入到 操作数栈36: athrow # 弹出操作数栈顶 元素，匹配 异常表 类型，然后抛出异常37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 获取 INSTANCE # 获取常量池 索引， 压入到 操作数栈 中40: areturn # 将 操作数 栈顶 元素 弹出，压入到 调用者的 操作数栈 其中 17 表示创建对象，将对象引用入栈 // new Singleton 20 表示复制一份对象引用 // 引用地址 21 表示利用一个对象引用，调用构造方法 24 表示利用一个对象引用，赋值给 static INSTANCE 也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行： 关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取INSTANCE 变量的值 这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效 (4) double-checked locking 解决12345678910111213141516public final class Singleton &#123; private Singleton() &#123; &#125; private static volatile Singleton INSTANCE = null; public static Singleton getInstance() &#123; // 实例没创建，才会进入内部的 synchronized代码块 if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; // t2 // 也许有其它线程已经创建实例，所以再判断一次 if (INSTANCE == null) &#123; // t1 INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 字节码上看不出来 volatile 指令的效果 123456789101112131415161718192021222324# -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;3: ifnonnull 376: ldc #3 // class cn/itcast/n5/Singleton8: dup9: astore_010: monitorenter -----------------------&gt; 保证原子性、可见性11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;14: ifnonnull 2717: new #3 // class cn/itcast/n5/Singleton20: dup21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;# -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障27: aload_028: monitorexit ------------------------&gt; 保证原子性、可见性29: goto 3732: astore_133: aload_034: monitorexit35: aload_136: athrow37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;40: areturn 如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点： 可见性 写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中 而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据 有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性 4.5 happens-beforehappens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见 12345678910111213static int x;static Object m = new Object();new Thread(()-&gt;&#123; synchronized(m) &#123; x = 10; &#125;&#125;,&quot;t1&quot;).start();new Thread(()-&gt;&#123; synchronized(m) &#123; System.out.println(x); &#125;&#125;,&quot;t2&quot;).start(); 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见 1234567volatile static int x;new Thread(()-&gt;&#123; x = 10;&#125;,&quot;t1&quot;).start();new Thread(()-&gt;&#123; System.out.println(x);&#125;,&quot;t2&quot;).start(); 线程 start 前对变量的写，对该线程开始后对该变量的读可见 12345static int x;x = 10;new Thread(()-&gt;&#123; System.out.println(x);&#125;,&quot;t2&quot;).start(); 线程结束前对变量的写，对其它线程得知它结束后的读可见，对共享变量的读取，加载的是主存中最新数据（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束） 1234567static int x;Thread t1 = new Thread(()-&gt;&#123; x = 10;&#125;,&quot;t1&quot;);t1.start();t1.join();System.out.println(x); 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted） 12345678910111213141516171819202122static int x;public static void main(String[] args) &#123; Thread t2 = new Thread(()-&gt;&#123; while(true) &#123; if(Thread.currentThread().isInterrupted()) &#123; System.out.println(x); break; &#125; &#125; &#125;,&quot;t2&quot;); t2.start(); new Thread(()-&gt;&#123; sleep(1); x = 10; t2.interrupt(); &#125;,&quot;t1&quot;).start(); while(!t2.isInterrupted()) &#123; Thread.yield(); &#125; System.out.println(x);&#125; 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子 12345678910volatile static int x;static int y;new Thread(()-&gt;&#123; y = 10; x = 20;&#125;,&quot;t1&quot;).start();new Thread(()-&gt;&#123; // x=20 对 t2 可见, 同时 y=10 也对 t2 可见 System.out.println(x);&#125;,&quot;t2&quot;).start(); 变量都是指成员变量或静态成员变量 4.6 习题balking 模式习题希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？ 123456789101112131415public class TestVolatile &#123; volatile boolean initialized = false; void init() &#123; if (initialized) &#123; return; &#125; doInit(); initialized = true; &#125; private void doInit() &#123; &#125;&#125; 线程安全单例习题单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题 饿汉式：类加载就会导致该单实例对象被创建 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 实现1： 123456789101112131415// 问题1：为什么加 final// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例public final class Singleton implements Serializable &#123; // 问题3：为什么设置为私有? 是否能防止反射创建新的实例? private Singleton() &#123;&#125; // 问题4：这样初始化是否能保证单例对象创建时的线程安全? private static final Singleton INSTANCE = new Singleton(); // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由 public static Singleton getInstance() &#123; return INSTANCE; &#125; public Object readResolve() &#123; return INSTANCE; &#125;&#125; 实现2： 123456789// 问题1：枚举单例是如何限制实例个数的// 问题2：枚举单例在创建时是否有并发问题// 问题3：枚举单例能否被反射破坏单例// 问题4：枚举单例能否被反序列化破坏单例// 问题5：枚举单例属于懒汉式还是饿汉式// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做enum Singleton &#123; INSTANCE;&#125; 实现3： 123456789101112public final class Singleton &#123; private Singleton() &#123; &#125; private static Singleton INSTANCE = null; // 分析这里的线程安全, 并说明有什么缺点 public static synchronized Singleton getInstance() &#123; if( INSTANCE != null )&#123; return INSTANCE; &#125; INSTANCE = new Singleton(); return INSTANCE; &#125;&#125; 实现4：DCL 12345678910111213141516171819public final class Singleton &#123; private Singleton() &#123; &#125; // 问题1：解释为什么要加 volatile ? private static volatile Singleton INSTANCE = null; // 问题2：对比实现3, 说出这样做的意义 public static Singleton getInstance() &#123; if (INSTANCE != null) &#123; return INSTANCE; &#125; synchronized (Singleton.class) &#123; // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗 if (INSTANCE != null) &#123; // t2 return INSTANCE; &#125; INSTANCE = new Singleton(); return INSTANCE; &#125; &#125;&#125; 实现5： 1234567891011public final class Singleton &#123; private Singleton() &#123; &#125; // 问题1：属于懒汉式还是饿汉式 private static class LazyHolder &#123; static final Singleton INSTANCE = new Singleton(); &#125; // 问题2：在创建时是否有并发问题 public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 5. 本章小结本章重点讲解了 JMM 中的 可见性 - 由 JVM 缓存优化引起 有序性 - 由 JVM 指令重排序优化引起 happens-before 规则 原理方面 CPU 指令并行 volatile 模式方面 两阶段终止模式的 volatile 改进 同步模式之 balking 四、共享模型之无锁1. 本章内容 CAS 与 volatile 原子整数 原子引用 原子累加器 Unsafe 2. 问题提出有如下需求，保证 account.withdraw 取款方法的线程安全 123456789101112131415161718192021222324252627282930313233package cn.itcast;import java.util.ArrayList;import java.util.List;interface Account &#123; // 获取余额 Integer getBalance(); // 取款 void withdraw(Integer amount); /*** 方法内会启动 1000 个线程，每个线程做 -10 元 的操作* 如果初始余额为 10000 那么正确的结果应当是 0*/ static void demo(Account account) &#123; List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); long start = System.nanoTime(); for (int i = 0; i &lt; 1000; i++) &#123; ts.add(new Thread(() -&gt; &#123; account.withdraw(10); &#125;)); &#125; ts.forEach(Thread::start); ts.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end = System.nanoTime(); System.out.println(account.getBalance() + &quot; cost: &quot; + (end-start)/1000_000 + &quot; ms&quot;); &#125;&#125; 原有实现并不是线程安全的 1234567891011121314class AccountUnsafe implements Account &#123; private Integer balance; public AccountUnsafe(Integer balance) &#123; this.balance = balance; &#125; @Override public Integer getBalance() &#123; return balance; &#125; @Override public void withdraw(Integer amount) &#123; balance -= amount; &#125;&#125; 执行测试代码 123public static void main(String[] args) &#123; Account.demo(new AccountUnsafe(10000));&#125; 某次的执行结果 1330 cost: 306 ms 2.1 为什么不安全withdraw 方法 123public void withdraw(Integer amount) &#123; balance -= amount;&#125; 对应的字节码 123456789ALOAD 0 // &lt;- thisALOAD 0 GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; // &lt;- this.balanceINVOKEVIRTUAL java/lang/Integer.intValue ()I // 拆箱ALOAD 1 // &lt;- amountINVOKEVIRTUAL java/lang/Integer.intValue ()I // 拆箱ISUB // 减法INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; // 结果装箱PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; // -&gt; this.balance 多线程执行流程 123456789101112131415161718ALOAD 0 // thread-0 &lt;- thisALOAD 0GETFIELD cn/itcast/AccountUnsafe.balance // thread-0 &lt;- this.balanceINVOKEVIRTUAL java/lang/Integer.intValue // thread-0 拆箱ALOAD 1 // thread-0 &lt;- amountINVOKEVIRTUAL java/lang/Integer.intValue // thread-0 拆箱ISUB // thread-0 减法INVOKESTATIC java/lang/Integer.valueOf // thread-0 结果装箱PUTFIELD cn/itcast/AccountUnsafe.balance // thread-0 -&gt; this.balanceALOAD 0 // thread-1 &lt;- thisALOAD 0GETFIELD cn/itcast/AccountUnsafe.balance // thread-1 &lt;- this.balanceINVOKEVIRTUAL java/lang/Integer.intValue // thread-1 拆箱ALOAD 1 // thread-1 &lt;- amountINVOKEVIRTUAL java/lang/Integer.intValue // thread-1 拆箱ISUB // thread-1 减法INVOKESTATIC java/lang/Integer.valueOf // thread-1 结果装箱PUTFIELD cn/itcast/AccountUnsafe.balance // thread-1 -&gt; this.balance 单核的指令交错 多核的指令交错 2.2 解决思路-锁首先想到的是给 Account 对象加锁 1234567891011121314class AccountUnsafe implements Account &#123; private Integer balance; public AccountUnsafe(Integer balance) &#123; this.balance = balance; &#125; @Override public synchronized Integer getBalance() &#123; return balance; &#125; @Override public synchronized void withdraw(Integer amount) &#123; balance -= amount; &#125;&#125; 结果为 10 cost: 399 ms 2.3 解决思路-无锁12345678910111213141516171819202122class AccountSafe implements Account &#123; private AtomicInteger balance; public AccountSafe(Integer balance) &#123; this.balance = new AtomicInteger(balance); &#125; @Override public Integer getBalance() &#123; return balance.get(); &#125; @Override public void withdraw(Integer amount) &#123; while (true) &#123; int prev = balance.get(); int next = prev - amount; if (balance.compareAndSet(prev, next)) &#123; break; &#125; &#125; // 可以简化为下面的方法 // balance.addAndGet(-1 * amount); &#125;&#125; 执行测试代码 123public static void main(String[] args) &#123; Account.demo(new AccountSafe(10000));&#125; 某次的执行结果 10 cost: 302 ms 3. CAS 与 volatile前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？ 123456789101112131415161718192021public void withdraw(Integer amount) &#123; while(true) &#123; // 需要不断尝试，直到成功为止 while (true) &#123; // 比如拿到了旧值 1000 int prev = balance.get(); // 在这个基础上 1000-10 = 990 int next = prev - amount; /*compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值- 不一致了，next 作废，返回 false 表示失败比如，别的线程已经做了减法，当前值已经被减成了 990那么本线程的这次 990 就作废了，进入 while 下次循环重试- 一致，以 next 设置为新值，返回 true 表示成功*/ if (balance.compareAndSet(prev, next)) &#123; break; &#125; &#125; &#125;&#125; 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。 注意 其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。 3.1 慢动作分析12345678910111213141516171819202122232425262728293031@Slf4jpublic class SlowMotion &#123; public static void main(String[] args) &#123; AtomicInteger balance = new AtomicInteger(10000); int mainPrev = balance.get(); log.debug(&quot;try get &#123;&#125;&quot;, mainPrev); new Thread(() -&gt; &#123; sleep(1000); int prev = balance.get(); balance.compareAndSet(prev, 9000); log.debug(balance.toString()); &#125;, &quot;t1&quot;).start(); sleep(2000); log.debug(&quot;try set 8000...&quot;); boolean isSuccess = balance.compareAndSet(mainPrev, 8000); log.debug(&quot;is success ? &#123;&#125;&quot;, isSuccess); if(!isSuccess)&#123; mainPrev = balance.get(); log.debug(&quot;try set 8000...&quot;); isSuccess = balance.compareAndSet(mainPrev, 8000); log.debug(&quot;is success ? &#123;&#125;&quot;, isSuccess); &#125; &#125; private static void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果 1234562019-10-13 11:28:37.134 [main] try get 100002019-10-13 11:28:38.154 [t1] 90002019-10-13 11:28:39.154 [main] try set 8000...2019-10-13 11:28:39.154 [main] is success ? false2019-10-13 11:28:39.154 [main] try set 8000...2019-10-13 11:28:39.154 [main] is success ? true 3.2 volatile获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。 注意 volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性） CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果 3.3 为什么无锁效率高 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。 3.4 CAS 的特点结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 4. 原子整数J.U.C 并发包提供了： AtomicBoolean AtomicInteger AtomicLong 以 AtomicInteger 为例 123456789101112131415161718192021222324252627AtomicInteger i = new AtomicInteger(0);// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++System.out.println(i.getAndIncrement());// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++iSystem.out.println(i.incrementAndGet());// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --iSystem.out.println(i.decrementAndGet());// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--System.out.println(i.getAndDecrement());// 获取并加值（i = 0, 结果 i = 5, 返回 0）System.out.println(i.getAndAdd(5));// 加值并获取（i = 5, 结果 i = 0, 返回 0）System.out.println(i.addAndGet(-5));// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）// 其中函数中的操作能保证原子，但函数需要无副作用System.out.println(i.getAndUpdate(p -&gt; p - 2));// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）// 其中函数中的操作能保证原子，但函数需要无副作用System.out.println(i.updateAndGet(p -&gt; p + 2));// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）// 其中函数中的操作能保证原子，但函数需要无副作用// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 finalSystem.out.println(i.getAndAccumulate(10, (p, x) -&gt; p + x));// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）// 其中函数中的操作能保证原子，但函数需要无副作用System.out.println(i.accumulateAndGet(-10, (p, x) -&gt; p + x)); 5. 原子引用为什么需要原子引用类型？ AtomicReference AtomicMarkableReference AtomicStampedReference 有如下方法 123456789101112131415161718192021222324252627public interface DecimalAccount &#123; // 获取余额 BigDecimal getBalance(); // 取款 void withdraw(BigDecimal amount); /*** 方法内会启动 1000 个线程，每个线程做 -10 元 的操作* 如果初始余额为 10000 那么正确的结果应当是 0*/ static void demo(DecimalAccount account) &#123; List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; ts.add(new Thread(() -&gt; &#123; account.withdraw(BigDecimal.TEN); &#125;)); &#125; ts.forEach(Thread::start); ts.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(account.getBalance()); &#125;&#125; 试着提供不同的 DecimalAccount 实现，实现安全的取款操作 5.1 不安全实现12345678910111213141516171819class DecimalAccountUnsafe implements DecimalAccount &#123; BigDecimal balance; public DecimalAccountUnsafe(BigDecimal balance) &#123; this.balance = balance; &#125; @Override public BigDecimal getBalance() &#123; return balance; &#125; @Override public void withdraw(BigDecimal amount) &#123; BigDecimal balance = this.getBalance(); this.balance = balance.subtract(amount); &#125;&#125; 5.2 安全实现-使用锁12345678910111213141516171819202122class DecimalAccountSafeLock implements DecimalAccount &#123; private final Object lock = new Object(); BigDecimal balance; public DecimalAccountSafeLock(BigDecimal balance) &#123; this.balance = balance; &#125; @Override public BigDecimal getBalance() &#123; return balance; &#125; @Override public void withdraw(BigDecimal amount) &#123; synchronized (lock) &#123; BigDecimal balance = this.getBalance(); this.balance = balance.subtract(amount); &#125; &#125;&#125; 5.3 安全实现-使用CAS123456789101112131415161718192021222324class DecimalAccountSafeCas implements DecimalAccount &#123; AtomicReference&lt;BigDecimal&gt; ref; public DecimalAccountSafeCas(BigDecimal balance) &#123; ref = new AtomicReference&lt;&gt;(balance); &#125; @Override public BigDecimal getBalance() &#123; return ref.get(); &#125; @Override public void withdraw(BigDecimal amount) &#123; while (true) &#123; BigDecimal prev = ref.get(); BigDecimal next = prev.subtract(amount); if (ref.compareAndSet(prev, next)) &#123; break; &#125; &#125; &#125;&#125; 测试代码 123DecimalAccount.demo(new DecimalAccountUnsafe(new BigDecimal(&quot;10000&quot;)));DecimalAccount.demo(new DecimalAccountSafeLock(new BigDecimal(&quot;10000&quot;)));DecimalAccount.demo(new DecimalAccountSafeCas(new BigDecimal(&quot;10000&quot;))); 运行结果 1234310 cost: 425 ms0 cost: 285 ms0 cost: 274 ms 5.4 ABA问题及解决ABA 问题1234567891011121314151617181920static AtomicReference&lt;String&gt; ref = new AtomicReference&lt;&gt;(&quot;A&quot;);public static void main(String[] args) throws InterruptedException &#123; log.debug(&quot;main start...&quot;); // 获取值 A // 这个共享变量被它线程修改过？ String prev = ref.get(); other(); sleep(1); // 尝试改为 C log.debug(&quot;change A-&gt;C &#123;&#125;&quot;, ref.compareAndSet(prev, &quot;C&quot;));&#125;private static void other() &#123; new Thread(() -&gt; &#123; log.debug(&quot;change A-&gt;B &#123;&#125;&quot;, ref.compareAndSet(ref.get(), &quot;B&quot;)); &#125;, &quot;t1&quot;).start(); sleep(0.5); new Thread(() -&gt; &#123; log.debug(&quot;change B-&gt;A &#123;&#125;&quot;, ref.compareAndSet(ref.get(), &quot;A&quot;)); &#125;, &quot;t2&quot;).start();&#125; 输出 123411:29:52.325 c.Test36 [main] - main start...11:29:52.379 c.Test36 [t1] - change A-&gt;B true11:29:52.879 c.Test36 [t2] - change B-&gt;A true11:29:53.880 c.Test36 [main] - change A-&gt;C true 主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号 AtomicStampedReference123456789101112131415161718192021222324252627static AtomicStampedReference&lt;String&gt; ref = new AtomicStampedReference&lt;&gt;(&quot;A&quot;, 0);public static void main(String[] args) throws InterruptedException &#123; log.debug(&quot;main start...&quot;); // 获取值 A String prev = ref.getReference(); // 获取版本号 int stamp = ref.getStamp(); log.debug(&quot;版本 &#123;&#125;&quot;, stamp); // 如果中间有其它线程干扰，发生了 ABA 现象 other(); sleep(1); // 尝试改为 C log.debug(&quot;change A-&gt;C &#123;&#125;&quot;, ref.compareAndSet(prev, &quot;C&quot;, stamp, stamp + 1));&#125;private static void other() &#123; new Thread(() -&gt; &#123; log.debug(&quot;change A-&gt;B &#123;&#125;&quot;, ref.compareAndSet(ref.getReference(), &quot;B&quot;, ref.getStamp(), ref.getStamp() + 1)); log.debug(&quot;更新版本为 &#123;&#125;&quot;, ref.getStamp()); &#125;, &quot;t1&quot;).start(); sleep(0.5); new Thread(() -&gt; &#123; log.debug(&quot;change B-&gt;A &#123;&#125;&quot;, ref.compareAndSet(ref.getReference(), &quot;A&quot;, ref.getStamp(), ref.getStamp() + 1)); log.debug(&quot;更新版本为 &#123;&#125;&quot;, ref.getStamp()); &#125;, &quot;t2&quot;).start();&#125; 输出为 123456715:41:34.891 c.Test36 [main] - main start...15:41:34.894 c.Test36 [main] - 版本 015:41:34.956 c.Test36 [t1] - change A-&gt;B true15:41:34.956 c.Test36 [t1] - 更新版本为 115:41:35.457 c.Test36 [t2] - change B-&gt;A true15:41:35.457 c.Test36 [t2] - 更新版本为 215:41:36.457 c.Test36 [main] - change A-&gt;C false AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt;C ，通过AtomicStamped-Reference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference AtomicMarkableReference1234567class GarbageBag &#123;String desc;public GarbageBag(String desc) &#123;this.desc = desc;&#125;public void setDesc(String desc) &#123;this.desc = desc; 123456789101112131415161718192021222324@Slf4jpublic class TestABAAtomicMarkableReference &#123; public static void main(String[] args) throws InterruptedException &#123; GarbageBag bag = new GarbageBag(&quot;装满了垃圾&quot;); // 参数2 mark 可以看作一个标记，表示垃圾袋满了 AtomicMarkableReference&lt;GarbageBag&gt; ref = new AtomicMarkableReference&lt;&gt;(bag, true); log.debug(&quot;主线程 start...&quot;); GarbageBag prev = ref.getReference(); log.debug(prev.toString()); new Thread(() -&gt; &#123; log.debug(&quot;打扫卫生的线程 start...&quot;); bag.setDesc(&quot;空垃圾袋&quot;); while (!ref.compareAndSet(bag, bag, true, false)) &#123;&#125; log.debug(bag.toString()); &#125;).start(); Thread.sleep(1000); log.debug(&quot;主线程想换一只新垃圾袋？&quot;); boolean success = ref.compareAndSet(prev, new GarbageBag(&quot;空垃圾袋&quot;), true, false); log.debug(&quot;换了么？&quot; + success); log.debug(ref.getReference().toString()); &#125;&#125; 输出 12345672019-10-13 15:30:09.264 [main] 主线程 start...2019-10-13 15:30:09.270 [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾2019-10-13 15:30:09.293 [Thread-1] 打扫卫生的线程 start...2019-10-13 15:30:09.294 [Thread-1] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋2019-10-13 15:30:10.294 [main] 主线程想换一只新垃圾袋？2019-10-13 15:30:10.294 [main] 换了么？false2019-10-13 15:30:10.294 [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋 可以注释掉打扫卫生线程代码，再观察输出 6. 原子数组 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 有如下方法 1234567891011121314151617181920212223242526272829303132333435/**参数1，提供数组、可以是线程不安全数组或线程安全数组参数2，获取数组长度的方法参数3，自增方法，回传 array, index参数4，打印数组的方法*/// supplier 提供者 无中生有 ()-&gt;结果// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;private static &lt;T&gt; void demo( Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun, BiConsumer&lt;T, Integer&gt; putConsumer, Consumer&lt;T&gt; printConsumer ) &#123; List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); T array = arraySupplier.get(); int length = lengthFun.apply(array); for (int i = 0; i &lt; length; i++) &#123; // 每个线程对数组作 10000 次操作 ts.add(new Thread(() -&gt; &#123; for (int j = 0; j &lt; 10000; j++) &#123; putConsumer.accept(array, j%length); &#125; &#125;)); &#125; ts.forEach(t -&gt; t.start()); // 启动所有线程 ts.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); // 等所有线程结束 printConsumer.accept(array);&#125; 6.1 不安全的数组123456demo( ()-&gt;new int[10], (array)-&gt;array.length, (array, index) -&gt; array[index]++, array-&gt; System.out.println(Arrays.toString(array))); 结果 1[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698] 6.2 安全的数组123456demo( ()-&gt; new AtomicIntegerArray(10), (array) -&gt; array.length(), (array, index) -&gt; array.getAndIncrement(index), array -&gt; System.out.println(array)); 结果 1[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 7. 字段更新器 AtomicReferenceFieldUpdater // 域 字段 AtomicIntegerFieldUpdater AtomicLongFieldUpdater 利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 1Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Must be volatile type 1234567891011121314151617public class Test5 &#123; private volatile int field; public static void main(String[] args) &#123; AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test5.class, &quot;field&quot;); Test5 test5 = new Test5(); fieldUpdater.compareAndSet(test5, 0, 10); // 修改成功 field = 10 System.out.println(test5.field); // 修改成功 field = 20 fieldUpdater.compareAndSet(test5, 10, 20); System.out.println(test5.field); // 修改失败 field = 20 fieldUpdater.compareAndSet(test5, 10, 30); System.out.println(test5.field); &#125;&#125; 输出 123102020 8. 原子累加器8.1 累加器性能比较1234567891011121314151617181920212223242526private static &lt;T&gt; void demo(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action) &#123; T adder = adderSupplier.get(); long start = System.nanoTime(); List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); // 4 个线程，每人累加 50 万 for (int i = 0; i &lt; 40; i++) &#123; ts.add(new Thread(() -&gt; &#123; for (int j = 0; j &lt; 500000; j++) &#123; action.accept(adder); &#125; &#125;)); &#125; ts.forEach(t -&gt; t.start()); ts.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end = System.nanoTime(); System.out.println(adder + &quot; cost:&quot; + (end - start)/1000_000);&#125; 比较 AtomicLong 与 LongAdder 1234567for (int i = 0; i &lt; 5; i++) &#123; demo(() -&gt; new LongAdder(), adder -&gt; adder.increment());&#125;for (int i = 0; i &lt; 5; i++) &#123; demo(() -&gt; new AtomicLong(), adder -&gt; adder.getAndIncrement());&#125; 输出 123456789101000000 cost:431000000 cost:91000000 cost:71000000 cost:71000000 cost:71000000 cost:311000000 cost:271000000 cost:281000000 cost:241000000 cost:22 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。 8.2 源码之LongAdderLongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧 LongAdder 类有几个关键域 123456// 累加单元数组, 懒惰初始化transient volatile Cell[] cells;// 基础值, 如果没有竞争, 则用 cas 累加这个域transient volatile long base;// 在 cells 创建或扩容时, 置为 1, 表示加锁transient volatile int cellsBusy; 8.3 cas 锁123456789101112131415// 不要用于实践！！！public class LockCas &#123; private AtomicInteger state = new AtomicInteger(0); public void lock() &#123; while (true) &#123; if (state.compareAndSet(0, 1)) &#123; break; &#125; &#125; &#125; public void unlock() &#123; log.debug(&quot;unlock...&quot;); state.set(0); &#125;&#125; 测试 1234567891011121314151617181920LockCas lock = new LockCas();new Thread(() -&gt; &#123; log.debug(&quot;begin...&quot;); lock.lock(); try &#123; log.debug(&quot;lock...&quot;); sleep(1); &#125; finally &#123; lock.unlock(); &#125;&#125;).start();new Thread(() -&gt; &#123; log.debug(&quot;begin...&quot;); lock.lock(); try &#123; log.debug(&quot;lock...&quot;); &#125; finally &#123; lock.unlock(); &#125;&#125;).start(); 输出 12345618:27:07.198 c.Test42 [Thread-0] - begin...18:27:07.202 c.Test42 [Thread-0] - lock...18:27:07.198 c.Test42 [Thread-1] - begin...18:27:08.204 c.Test42 [Thread-0] - unlock...18:27:08.204 c.Test42 [Thread-1] - lock...18:27:08.204 c.Test42 [Thread-1] - unlock... 8.4 原理之伪共享其中 Cell 即为累加单元 1234567891011// 防止缓存行伪共享@sun.misc.Contended static final class Cell &#123; volatile long value; Cell(long x) &#123; value = x; &#125; // 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值 final boolean cas(long prev, long next) &#123; return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next); &#125; // 省略不重要代码 &#125; 得从缓存说起 缓存与内存的速度比较 从 cpu 到 大约需要的时钟周期 寄存器 1 cycle (4GHz 的 CPU 约为0.25ns) L1 3~4 cycle L2 10~20 cycle L3 40~45 cycle 内存 120~240 cycle 因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）（译注：有可能处理器的缓存行是128字节，那么使用64字节填充还是会存在伪共享问题） 缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效 因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了： Core-0 要修改 Cell[0] Core-1 要修改 Cell[1] 无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效 @sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效 累加主要调用下面的方法 123456789101112131415161718192021222324public void add(long x) &#123; // as 为累加单元数组 // b 为基础值 // x 为累加值 Cell[] as; long b, v; int m; Cell a; // 进入 if 的两个条件 // 1. as 有值, 表示已经发生过竞争, 进入 if // 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if if ((as = cells) != null || !casBase(b = base, b + x)) &#123; // uncontended 表示 cell 没有竞争 boolean uncontended = true; if ( // as 还没有创建 as == null || (m = as.length - 1) &lt; 0 || // 当前线程对应的 cell 还没有 (a = as[getProbe() &amp; m]) == null || // cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell ) !(uncontended = a.cas(v = a.value, v + x)) ) &#123; // 进入 cell 数组创建、cell 创建的流程 longAccumulate(x, null, uncontended); &#125; &#125;&#125; add 流程图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123; int h; // 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell if ((h = getProbe()) == 0) &#123; // 初始化 probe ThreadLocalRandom.current(); // h 对应新的 probe 值, 用来对应 cell h = getProbe(); wasUncontended = true; &#125; // collide 为 true 表示需要扩容 boolean collide = false; for (;;) &#123; Cell[] as; Cell a; int n; long v; // 已经有了 cells if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123; // 还没有 cell if ((a = as[(n - 1) &amp; h]) == null) &#123; // 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x // 成功则 break, 否则继续 continue 循环 &#125; // 有竞争, 改变线程对应的 cell 来重试 cas else if (!wasUncontended) wasUncontended = true; // cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas else if (n &gt;= NCPU || cells != as) collide = false; // 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了 else if (!collide) collide = true; // 加锁 else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123; // 加锁成功, 扩容 continue; &#125; // 改变线程对应的 cell h = advanceProbe(h); &#125; // 还没有 cells, 尝试给 cellsBusy 加锁 else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; // 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell // 成功则 break; &#125; // 上两种情况失败, 尝试给 base 累加 else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; &#125;&#125; longAccumulate 流程图 每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位） 获取最终结果通过 sum 方法 1234567891011public long sum() &#123; Cell[] as = cells; Cell a; long sum = base; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; 9. Unsafe9.1 概述Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得 123456789101112131415public class UnsafeAccessor &#123; static Unsafe unsafe; static &#123; try &#123; Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; throw new Error(e); &#125; &#125; static Unsafe getUnsafe() &#123; return unsafe; &#125;&#125; 9.2 Unsafe CAS 操作12345@Dataclass Student &#123; volatile int id; volatile String name;&#125; 1234567891011Unsafe unsafe = UnsafeAccessor.getUnsafe();Field id = Student.class.getDeclaredField(&quot;id&quot;);Field name = Student.class.getDeclaredField(&quot;name&quot;);// 获得成员变量的偏移量long idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id);long nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name);Student student = new Student();// 使用 cas 方法替换成员变量的值UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, 0, 20); // 返回 trueUnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, null, &quot;张三&quot;); // 返回 trueSystem.out.println(student); 输出 1Student(id=20, name=张三) 使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现 12345678910111213141516171819202122232425262728293031class AtomicData &#123; private volatile int data; static final Unsafe unsafe; static final long DATA_OFFSET; static &#123; unsafe = UnsafeAccessor.getUnsafe(); try &#123; // data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性 DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(&quot;data&quot;)); &#125; catch (NoSuchFieldException e) &#123; throw new Error(e); &#125; &#125; public AtomicData(int data) &#123; this.data = data; &#125; public void decrease(int amount) &#123; int oldValue; while(true) &#123; // 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解 oldValue = data; // cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue - amount)) &#123; return; &#125; &#125; &#125; public int getData() &#123; return data; &#125;&#125; Account 实现 1234567891011Account.demo(new Account() &#123; AtomicData atomicData = new AtomicData(10000); @Override public Integer getBalance() &#123; return atomicData.getData(); &#125; @Override public void withdraw(Integer amount) &#123; atomicData.decrease(amount); &#125;&#125;); 10. 本章小 结 CAS 与 volatile API 原子整数 原子引用 原子数组 字段更新器 原子累加器 Unsafe 原理方面 LongAdder 源码 伪共享 五、共享模型之不可变1. 本章内容 不可变类的使用 不可变类设计 无状态类设计 2. 日期转换的问题2.1 问题提出下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的 12345678910SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; log.debug(&quot;&#123;&#125;&quot;, sdf.parse(&quot;1951-04-21&quot;)); &#125; catch (Exception e) &#123; log.error(&quot;&#123;&#125;&quot;, e); &#125; &#125;).start();&#125; 有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果，例如： 123456789101112131415161718192021222324252627282930313219:10:40.859 [Thread-2] c.TestDateParse - &#123;&#125;java.lang.NumberFormatException: For input string: &quot;&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2084) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) at java.lang.Thread.run(Thread.java:748)19:10:40.859 [Thread-1] c.TestDateParse - &#123;&#125;java.lang.NumberFormatException: empty String at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1842) at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) at java.lang.Double.parseDouble(Double.java:538) at java.text.DigitList.getDouble(DigitList.java:169) at java.text.DecimalFormat.parse(DecimalFormat.java:2089) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) at java.lang.Thread.run(Thread.java:748)19:10:40.857 [Thread-8] c.TestDateParse - Sat Apr 21 00:00:00 CST 195119:10:40.857 [Thread-9] c.TestDateParse - Sat Apr 21 00:00:00 CST 195119:10:40.857 [Thread-6] c.TestDateParse - Sat Apr 21 00:00:00 CST 195119:10:40.857 [Thread-4] c.TestDateParse - Sat Apr 21 00:00:00 CST 195119:10:40.857 [Thread-5] c.TestDateParse - Mon Apr 21 00:00:00 CST 17896064519:10:40.857 [Thread-0] c.TestDateParse - Sat Apr 21 00:00:00 CST 195119:10:40.857 [Thread-7] c.TestDateParse - Sat Apr 21 00:00:00 CST 195119:10:40.857 [Thread-3] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 2.2 思路 - 同步锁这样虽能解决问题，但带来的是性能上的损失，并不算很好： 123456789101112SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);for (int i = 0; i &lt; 50; i++) &#123; new Thread(() -&gt; &#123; synchronized (sdf) &#123; try &#123; log.debug(&quot;&#123;&#125;&quot;, sdf.parse(&quot;1951-04-21&quot;)); &#125; catch (Exception e) &#123; log.error(&quot;&#123;&#125;&quot;, e); &#125; &#125; &#125;).start();&#125; 2.3 思路 - 不可变如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类 1234567DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; LocalDate date = dtf.parse(&quot;2018-10-01&quot;, LocalDate::from); log.debug(&quot;&#123;&#125;&quot;, date); &#125;).start();&#125; 可以看 DateTimeFormatter 的文档： 12@implSpecThis class is immutable and thread-safe. 不可变对象，实际是另一种避免竞争的方式。 3. 不可变设计另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 // ...&#125; 3.1 final 的使用发现该类、类中所有属性都是 final 的 属性用 final 修饰保证了该属性是只读的，不能修改 类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性 3.2 保护性拷贝但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例： 12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做了修改： 123456789101112131415161718public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = &quot;&quot;.value; return; &#125; &#125; if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】 3.3 模式之享元简介定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时 wikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects 出自 “Gang of Four” design patterns归类 Structual patterns 体现包装类在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象： 1234567public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125; 注意： Byte, Short, Long 缓存的范围都是 -128~127 Character 缓存的范围是 0~127 Integer的默认范围是 -128~127 最小值不能变 但最大值可以通过调整虚拟机参数 -Djava.lang.Integer.IntegerCache.high 来改变 Boolean 缓存了 TRUE 和 FALSE String 池BigDecimal BigIntegerDIY例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Pool &#123; // 1. 连接池大小 private final int poolSize; // 2. 连接对象数组 private Connection[] connections; // 3. 连接状态数组 0 表示空闲， 1 表示繁忙 private AtomicIntegerArray states; // 4. 构造方法初始化 public Pool(int poolSize) &#123; this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &lt; poolSize; i++) &#123; connections[i] = new MockConnection(&quot;连接&quot; + (i+1)); &#125; &#125; // 5. 借连接 public Connection borrow() &#123; while(true) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; // 获取空闲连接 if(states.get(i) == 0) &#123; if (states.compareAndSet(i, 0, 1)) &#123; log.debug(&quot;borrow &#123;&#125;&quot;, connections[i]); return connections[i]; &#125; &#125; &#125; // 如果没有空闲连接，当前线程进入等待 synchronized (this) &#123; try &#123; log.debug(&quot;wait...&quot;); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; // 6. 归还连接 public void free(Connection conn) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (connections[i] == conn) &#123; states.set(i, 0); synchronized (this) &#123; log.debug(&quot;free &#123;&#125;&quot;, conn); this.notifyAll(); &#125; break; &#125; &#125; &#125;&#125;class MockConnection implements Connection &#123; // 实现略&#125; 使用连接池： 123456789101112Pool pool = new Pool(2);for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; Connection conn = pool.borrow(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; pool.free(conn); &#125;).start();&#125; 以上实现没有考虑： 连接的动态增长与收缩 连接保活（可用性检测） 等待超时处理 分布式 hash 对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apachecommons pool，例如redis连接池可以参考jedis中关于连接池的实现 3.4 原理之 final设置 final 变量的原理理解了 volatile 原理，再对比 final 的实现就比较简单了 123public class TestFinal &#123; final int a = 20;&#125; 字节码 123456780: aload_01: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: bipush 207: putfield #2 // Field a:I&lt;-- 写屏障10: return 发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况 获取final 变量的原理123456789101112131415161718192021222324252627282930313233public class TestFinal &#123; static int A = 10; static int B = Short.MAX_VALUE+1; final int a = 20; final int b = Integer.MAX_VALUE; final void test1() &#123; final int c = 30; new Thread(()-&gt;&#123; System.out.println(c); &#125;).start(); final int d = 30; class Task implements Runnable &#123; @Override public void run() &#123; System.out.println(d); &#125; &#125; new Thread(new Task()).start(); &#125;&#125;class UseFinal1 &#123; public void test() &#123; System.out.println(TestFinal.A); System.out.println(TestFinal.B); System.out.println(new TestFinal().a); System.out.println(new TestFinal().b); new TestFinal().test1(); &#125;&#125; 对UseFinal1类反编译后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class cn/itcast/n5/UseFinal1 &#123; // compiled from: TestFinal.java // access flags 0x0 &lt;init&gt;()V L0 LINENUMBER 29 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this Lcn/itcast/n5/UseFinal1; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public test()V L0 LINENUMBER 31 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; GETSTATIC cn/itcast/n5/TestFinal.A : I // 1 处 这里，直接拿 静态变量 INVOKEVIRTUAL java/io/PrintStream.println (I)V L1 LINENUMBER 32 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; GETSTATIC cn/itcast/n5/TestFinal.B : I // 2 处 这里 INVOKEVIRTUAL java/io/PrintStream.println (I)V L2 LINENUMBER 33 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; NEW cn/itcast/n5/TestFinal DUP INVOKESPECIAL cn/itcast/n5/TestFinal.&lt;init&gt; ()V INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class; POP BIPUSH 20 // 1 处 这里，加了 final,bipush 是 把20 放到 这个方法 test() 的栈中，相当于复制一份 INVOKEVIRTUAL java/io/PrintStream.println (I)V L3 LINENUMBER 34 L3 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; NEW cn/itcast/n5/TestFinal DUP INVOKESPECIAL cn/itcast/n5/TestFinal.&lt;init&gt; ()V INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class; POP LDC 2147483647 // 2 处 这里，是将 Integer.MAX_VALUE 放到运行常量池 里 INVOKEVIRTUAL java/io/PrintStream.println (I)V L4 LINENUMBER 35 L4 NEW cn/itcast/n5/TestFinal DUP INVOKESPECIAL cn/itcast/n5/TestFinal.&lt;init&gt; ()V INVOKEVIRTUAL cn/itcast/n5/TestFinal.test1 ()V L5 LINENUMBER 36 L5 RETURN L6 LOCALVARIABLE this Lcn/itcast/n5/UseFinal1; L0 L6 0 MAXSTACK = 3 MAXLOCALS = 1&#125; 总结： jdk1.8后，不加final修饰的类成员变量或非静态成员变量，类变量是通过getstatic 到该类 栈获取，普通变量是通过 getfield到栈获取 加 final 后，类变量或者普通变量 -128~127 数值使用 bipush 操作，修饰的变量压入到方法栈中，相当于复制了一份作为共享变量 供 方法 test() 使用 -2147483648~2147483647 数值 使用 ldc 操作，修饰的变量存放到了常量池中，共享变量从常量池获取 4. 无状态在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的 因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】 5. 本章小结 不可变类使用 不可变类设计 * 原理方面 final 模式方面 享元 六、共享模型之工具1. 线程池1.1 自定义线程池 步骤1：自定义拒绝策略接口 1234@FunctionalInterface // 拒绝策略interface RejectPolicy&lt;T&gt; &#123; void reject(BlockingQueue&lt;T&gt; queue, T task);&#125; 步骤2：自定义任务队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class BlockingQueue&lt;T&gt; &#123; // 1. 任务队列 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); // 2. 锁 private ReentrantLock lock = new ReentrantLock(); // 3. 生产者条件变量 private Condition fullWaitSet = lock.newCondition(); // 4. 消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); // 5. 容量 private int capcity; public BlockingQueue(int capcity) &#123; this.capcity = capcity; &#125; // 带超时阻塞获取 public T poll(long timeout, TimeUnit unit) &#123; lock.lock(); try &#123; // 将 timeout 统一转换为 纳秒 long nanos = unit.toNanos(timeout); while (queue.isEmpty()) &#123; try &#123; // 返回值是剩余时间 if (nanos &lt;= 0) &#123; return null; &#125; nanos = emptyWaitSet.awaitNanos(nanos); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); fullWaitSet.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; // 阻塞获取 public T take() &#123; lock.lock(); try &#123; while (queue.isEmpty()) &#123; try &#123; emptyWaitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); fullWaitSet.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; // 阻塞添加 public void put(T task) &#123; lock.lock(); try &#123; while (queue.size() == capcity) &#123; try &#123; log.debug(&quot;等待加入任务队列 &#123;&#125; ...&quot;, task); fullWaitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task); queue.addLast(task); emptyWaitSet.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; // 带超时时间阻塞添加 public boolean offer(T task, long timeout, TimeUnit timeUnit) &#123; lock.lock(); try &#123; long nanos = timeUnit.toNanos(timeout); while (queue.size() == capcity) &#123; try &#123; if(nanos &lt;= 0) &#123; return false; &#125; log.debug(&quot;等待加入任务队列 &#123;&#125; ...&quot;, task); nanos = fullWaitSet.awaitNanos(nanos); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task); queue.addLast(task); emptyWaitSet.signal(); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; lock.lock(); try &#123; return queue.size(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) &#123; lock.lock(); try &#123; // 判断队列是否满 if(queue.size() == capcity) &#123; rejectPolicy.reject(this, task); &#125; else &#123; // 有空闲 log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task); queue.addLast(task); emptyWaitSet.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 步骤3：自定义线程池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class ThreadPool &#123; // 任务队列 private BlockingQueue&lt;Runnable&gt; taskQueue; // 线程集合 private HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;(); // 核心线程数 private int coreSize; // 获取任务时的超时时间 private long timeout; private TimeUnit timeUnit; private RejectPolicy&lt;Runnable&gt; rejectPolicy; // 执行任务 public void execute(Runnable task) &#123; // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行 // 如果任务数超过 coreSize 时，加入任务队列暂存 synchronized (workers) &#123; if(workers.size() &lt; coreSize) &#123; Worker worker = new Worker(task); log.debug(&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;, worker, task); workers.add(worker); worker.start(); &#125; else &#123; // taskQueue.put(task); // 1) 死等 // 2) 带超时等待 // 3) 让调用者放弃任务执行 // 4) 让调用者抛出异常 // 5) 让调用者自己执行任务 taskQueue.tryPut(rejectPolicy, task); &#125; &#125; &#125; public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy) &#123; this.coreSize = coreSize; this.timeout = timeout; this.timeUnit = timeUnit; this.taskQueue = new BlockingQueue&lt;&gt;(queueCapcity); this.rejectPolicy = rejectPolicy; &#125; class Worker extends Thread&#123; private Runnable task; public Worker(Runnable task) &#123; this.task = task; &#125; @Override public void run() &#123; // 执行任务 // 1) 当 task 不为空，执行任务 // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行 // while(task != null || (task = taskQueue.take()) != null) &#123; while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) &#123; try &#123; log.debug(&quot;正在执行...&#123;&#125;&quot;, task); // task的run 方法跟 work 的run 是不同的，task的run 在外部 重写了 task.run(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; task = null; &#125; &#125; synchronized (workers) &#123; log.debug(&quot;worker 被移除&#123;&#125;&quot;, this); workers.remove(this); &#125; &#125; &#125;&#125; 步骤4：测试 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, (queue, task)-&gt;&#123; // 1. 死等 // queue.put(task); // 2) 带超时等待 // queue.offer(task, 1500, TimeUnit.MILLISECONDS); // 3) 让调用者放弃任务执行 // log.debug(&quot;放弃&#123;&#125;&quot;, task); // 4) 让调用者抛出异常 // throw new RuntimeException(&quot;任务执行失败 &quot; + task); // 5) 让调用者自己执行任务 task.run(); &#125;); for (int i = 0; i &lt; 4; i++) &#123; int j = i; threadPool.execute(() -&gt; &#123; try &#123; Thread.sleep(1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(&quot;&#123;&#125;&quot;, j); &#125;); &#125;&#125; 1.2 ThreadPoolExecutor (1) 线程池状态ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 状态名 高 3 位 接收新任 务 处理阻塞队列任 务 说明 RUNNING 111 Y Y SHUTDOWN 000 N Y 不会接收新任务，但会处理阻塞队列剩余 任务 STOP 001 N N 会中断正在执行的任务，并抛弃阻塞队列 任务 TIDYING 010 - - 任务全执行完毕，活动线程为 0 即将进入 终结 TERMINATED 011 - - 终结状态 从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值 1234// c 为旧值， ctlOf 返回结果为新值ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; (2) 构造方法1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize 核心线程数目 (最多保留的线程数) maximumPoolSize 最大线程数目 keepAliveTime 生存时间 - 针对救急线程 unit 时间单位 - 针对救急线程 workQueue 阻塞队列 threadFactory 线程工厂 - 可以为线程创建时起个好名字 handler 拒绝策略 工作方式： 123456789101112131415161718192021graph LRsubgraph 阻塞队列size=2t3(任务3)t4(任务4)endsubgraph 线程池c=2,m=3ct1(核心线程1)ct2(核心线程2)mt1(救急线程)ct1 --&gt; t1(任务1)ct2 --&gt; t2(任务2)endstyle ct1 fill:#ccf,stroke:#f66,stroke-width:2pxstyle ct2 fill:#ccf,stroke:#f66,stroke-width:2pxstyle mt1 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5.5 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现 AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略 CallerRunsPolicy 让调用者运行任务 DiscardPolicy 放弃本次任务 DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题 Netty 的实现，是创建一个新线程来执行任务 ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。 根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池 (3) newFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 特点 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 阻塞队列是无界的，可以放任意数量的任务 评价 适用于任务量已知，相对耗时的任务 (4) newCachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 特点 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 全部都是救急线程（60s 后可以回收） 救急线程可以无限创建 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货） 12345678910111213141516171819202122232425262728293031SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;();new Thread(() -&gt; &#123; try &#123; log.debug(&quot;putting &#123;&#125; &quot;, 1); integers.put(1); log.debug(&quot;&#123;&#125; putted...&quot;, 1); log.debug(&quot;putting...&#123;&#125; &quot;, 2); integers.put(2); log.debug(&quot;&#123;&#125; putted...&quot;, 2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,&quot;t1&quot;).start();sleep(1);new Thread(() -&gt; &#123; try &#123; log.debug(&quot;taking &#123;&#125;&quot;, 1); integers.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,&quot;t2&quot;).start();sleep(1);new Thread(() -&gt; &#123; try &#123; log.debug(&quot;taking &#123;&#125;&quot;, 2); integers.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,&quot;t3&quot;).start(); 输出 12345611:48:15.500 c.TestSynchronousQueue [t1] - putting 111:48:16.500 c.TestSynchronousQueue [t2] - taking 111:48:16.500 c.TestSynchronousQueue [t1] - 1 putted...11:48:16.500 c.TestSynchronousQueue [t1] - putting...211:48:17.502 c.TestSynchronousQueue [t3] - taking 211:48:17.503 c.TestSynchronousQueue [t1] - 2 putted... 评价 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况 (5) newSingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 使用场景： 希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。 区别： 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作 Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 FinalizableDelegatedExecutorService 应用的是装饰器模式（FinalizableDelegatedExecutorService 是具体装饰角色，DelegatedExecutorService 是抽象装饰角色，ExecutorService 是抽象构件角色），只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法 Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改 (6) 提交任务123456789101112131415161718// 执行任务void execute(Runnable command);// 提交任务 task，用返回值 Future 获得任务执行结果&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);// 提交 tasks 中所有任务&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;// 提交 tasks 中所有任务，带超时时间&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; execute和submit的区别 execute只能提交Runnable类型的任务，无返回值。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。 execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。 submit 执行后会立即返回一个结果，其他线程可以将返回的对象调用其方法get() 获取将来的结果，会阻塞等待（任务未执行完成）。 (7) 关闭线程池shutdown 1234567/*线程池状态变为 SHUTDOWN- 不会接收新任务- 但已提交任务会执行完- 此方法不会阻塞调用线程的执行*/void shutdown(); 12345678910111213141516public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); // 修改线程池状态 advanceRunState(SHUTDOWN); // 仅会打断空闲线程 interruptIdleWorkers(); onShutdown(); // 扩展点 ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等) tryTerminate();&#125; shutdownNow 1234567/*线程池状态变为 STOP- 不会接收新任务- 会将队列中的任务返回- 并用 interrupt 的方式中断正在执行的任务*/List&lt;Runnable&gt; shutdownNow(); 12345678910111213141516171819public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); // 修改线程池状态 advanceRunState(STOP); // 打断所有线程 interruptWorkers(); // 获取队列中剩余任务 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终结 tryTerminate(); return tasks;&#125; 其它方法 1234567// 不在 RUNNING 状态的线程池，此方法就返回 trueboolean isShutdown();// 线程池状态是否是 TERMINATEDboolean isTerminated();// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; * 异步模式之工作线程定义让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。 例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message） 注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率 例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工 饥饿固定大小线程池会有饥饿现象 两个工人是同一个线程池中的两个线程 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 后厨做菜：没啥说的，做就是了 比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿 123456789101112131415161718192021222324252627282930313233343536public class TestDeadLock &#123; static final List&lt;String&gt; MENU = Arrays.asList(&quot;地三鲜&quot;, &quot;宫保鸡丁&quot;, &quot;辣子鸡丁&quot;, &quot;烤鸡翅&quot;); static Random RANDOM = new Random(); static String cooking() &#123; return MENU.get(RANDOM.nextInt(MENU.size())); &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.execute(() -&gt; &#123; log.debug(&quot;处理点餐...&quot;); Future&lt;String&gt; f = executorService.submit(() -&gt; &#123; log.debug(&quot;做菜&quot;); return cooking(); &#125;); try &#123; log.debug(&quot;上菜: &#123;&#125;&quot;, f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); /* executorService.execute(() -&gt; &#123; log.debug(&quot;处理点餐...&quot;); Future&lt;String&gt; f = executorService.submit(() -&gt; &#123; log.debug(&quot;做菜&quot;); return cooking(); &#125;); try &#123; log.debug(&quot;上菜: &#123;&#125;&quot;, f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); */ &#125;&#125; 输出 12317:21:27.883 c.TestDeadLock [pool-1-thread-1] - 处理点餐...17:21:27.891 c.TestDeadLock [pool-1-thread-2] - 做菜17:21:27.891 c.TestDeadLock [pool-1-thread-1] - 上菜: 烤鸡翅 当注释取消后，可能的输出 1217:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐...17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池，例如： 1234567891011121314151617181920212223242526272829303132333435public class TestDeadLock &#123; static final List&lt;String&gt; MENU = Arrays.asList(&quot;地三鲜&quot;, &quot;宫保鸡丁&quot;, &quot;辣子鸡丁&quot;, &quot;烤鸡翅&quot;); static Random RANDOM = new Random(); static String cooking() &#123; return MENU.get(RANDOM.nextInt(MENU.size())); &#125; public static void main(String[] args) &#123; ExecutorService waiterPool = Executors.newFixedThreadPool(1); ExecutorService cookPool = Executors.newFixedThreadPool(1); waiterPool.execute(() -&gt; &#123; log.debug(&quot;处理点餐...&quot;); Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123; log.debug(&quot;做菜&quot;); return cooking(); &#125;); try &#123; log.debug(&quot;上菜: &#123;&#125;&quot;, f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); waiterPool.execute(() -&gt; &#123; log.debug(&quot;处理点餐...&quot;); Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123; log.debug(&quot;做菜&quot;); return cooking(); &#125;); try &#123; log.debug(&quot;上菜: &#123;&#125;&quot;, f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125; 输出 12345617:25:14.626 c.TestDeadLock [pool-1-thread-1] - 处理点餐...17:25:14.630 c.TestDeadLock [pool-2-thread-1] - 做菜17:25:14.631 c.TestDeadLock [pool-1-thread-1] - 上菜: 地三鲜17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 处理点餐...17:25:14.632 c.TestDeadLock [pool-2-thread-1] - 做菜17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁 创建多少线程池合适 过小会导致程序不能充分地利用系统资源、容易导致饥饿 过大会导致更多的线程上下文切换，占用更多内存 CPU 密集型运算通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 I/O 密集型运算CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 经验公式如下 线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间 例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 50% = 8 例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 10% = 40 自定义线程池(8) 任务调度线程池在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。 1234567891011121314151617181920public static void main(String[] args) &#123; Timer timer = new Timer(); TimerTask task1 = new TimerTask() &#123; @Override public void run() &#123; log.debug(&quot;task 1&quot;); sleep(2); &#125; &#125;; TimerTask task2 = new TimerTask() &#123; @Override public void run() &#123; log.debug(&quot;task 2&quot;); &#125; &#125;; // 使用 timer 添加两个任务，希望它们都在 1s 后执行 // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行 timer.schedule(task1, 1000); timer.schedule(task2, 1000);&#125; 输出 1230:46:09.444 c.TestTimer [main] - start...20:46:10.447 c.TestTimer [Timer-0] - task 120:46:12.448 c.TestTimer [Timer-0] - task 2 使用 ScheduledExecutorService 改写： 123456789ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);// 添加两个任务，希望它们都在 1s 后执行executor.schedule(() -&gt; &#123; System.out.println(&quot;任务1，执行时间：&quot; + new Date()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125;&#125;, 1000, TimeUnit.MILLISECONDS);executor.schedule(() -&gt; &#123; System.out.println(&quot;任务2，执行时间：&quot; + new Date());&#125;, 1000, TimeUnit.MILLISECONDS); 输出 12任务1，执行时间：Thu Jan 03 12:45:17 CST 2019任务2，执行时间：Thu Jan 03 12:45:17 CST 2019 scheduleAtFixedRate 例子： 12345ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);log.debug(&quot;start...&quot;);pool.scheduleAtFixedRate(() -&gt; &#123; log.debug(&quot;running...&quot;);&#125;, 1, 1, TimeUnit.SECONDS); 输出 1234521:45:43.167 c.TestTimer [main] - start...21:45:44.215 c.TestTimer [pool-1-thread-1] - running...21:45:45.215 c.TestTimer [pool-1-thread-1] - running...21:45:46.215 c.TestTimer [pool-1-thread-1] - running...21:45:47.215 c.TestTimer [pool-1-thread-1] - running... scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）： 123456ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);log.debug(&quot;start...&quot;);pool.scheduleAtFixedRate(() -&gt; &#123; log.debug(&quot;running...&quot;); sleep(2);&#125;, 1, 1, TimeUnit.SECONDS); 输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s 1234521:44:30.311 c.TestTimer [main] - start...21:44:31.360 c.TestTimer [pool-1-thread-1] - running...21:44:33.361 c.TestTimer [pool-1-thread-1] - running...21:44:35.362 c.TestTimer [pool-1-thread-1] - running...21:44:37.362 c.TestTimer [pool-1-thread-1] - running... scheduleWithFixedDelay 例子： 123456ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);log.debug(&quot;start...&quot;);pool.scheduleWithFixedDelay(()-&gt; &#123; log.debug(&quot;running...&quot;); sleep(2);&#125;, 1, 1, TimeUnit.SECONDS); 输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所以间隔都是 3s 1234521:40:55.078 c.TestTimer [main] - start...21:40:56.140 c.TestTimer [pool-1-thread-1] - running...21:40:59.143 c.TestTimer [pool-1-thread-1] - running...21:41:02.145 c.TestTimer [pool-1-thread-1] - running...21:41:05.147 c.TestTimer [pool-1-thread-1] - running... 评价 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务 (9) 正确处理执行任务异常方法1：主动捉异常 123456789ExecutorService pool = Executors.newFixedThreadPool(1);pool.submit(() -&gt; &#123; try &#123; log.debug(&quot;task1&quot;); int i = 1 / 0; &#125; catch (Exception e) &#123; log.error(&quot;error:&quot;, e); &#125;&#125;); 输出 12345678921:59:04.558 c.TestTimer [pool-1-thread-1] - task121:59:04.562 c.TestTimer [pool-1-thread-1] - error:java.lang.ArithmeticException: / by zero at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 方法2：使用 Future 1234567ExecutorService pool = Executors.newFixedThreadPool(1);Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123; log.debug(&quot;task1&quot;); int i = 1 / 0; return true;&#125;);log.debug(&quot;result:&#123;&#125;&quot;, f.get()); 输出 12345678910111221:54:58.208 c.TestTimer [pool-1-thread-1] - task1Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException:java.lang.ArithmeticException: / by zero at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:192) at cn.itcast.n8.TestTimer.main(TestTimer.java:31)Caused by: java.lang.ArithmeticException: / by zero at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) * 应用之定时任务定期执行如何让每周四 18:00:00 定时执行任务？ 123456789101112131415161718// 获得当前时间LocalDateTime now = LocalDateTime.now();// 获取本周四 18:00:00.000LocalDateTime thursday = now.with(DayOfWeek.THURSDAY).withHour(18).withMinute(0).withSecond(0).withNano(0);// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000if(now.compareTo(thursday) &gt;= 0) &#123; thursday = thursday.plusWeeks(1);&#125;// 计算时间差，即延时执行时间long initialDelay = Duration.between(now, thursday).toMillis();// 计算间隔时间，即 1 周的毫秒值long oneWeek = 7 * 24 * 3600 * 1000;ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);System.out.println(&quot;开始时间：&quot; + new Date());executor.scheduleAtFixedRate(() -&gt; &#123; System.out.println(&quot;执行时间：&quot; + new Date());&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS); (10) tomcat 线程池Tomcat 在哪里用到了线程池呢 LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 Acceptor 只负责【接收新的 socket 连接】 Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理 Executor 线程池中的工作线程最终负责【处理请求】 Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同 如果总线程数达到 maximumPoolSize 这时不会立刻抛 RejectedExecutionException 异常 而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常 源码 tomcat-7.0.42 1234567891011121314151617181920212223public void execute(Runnable command, long timeout, TimeUnit unit) &#123; submittedCount.incrementAndGet(); try &#123; super.execute(command); &#125; catch (RejectedExecutionException rx) &#123; if (super.getQueue() instanceof TaskQueue) &#123; final TaskQueue queue = (TaskQueue)super.getQueue(); try &#123; if (!queue.force(command, timeout, unit)) &#123; submittedCount.decrementAndGet(); throw new RejectedExecutionException(&quot;Queue capacity is full.&quot;); &#125; &#125; catch (InterruptedException x) &#123; submittedCount.decrementAndGet(); Thread.interrupted(); throw new RejectedExecutionException(x); &#125; &#125; else &#123; submittedCount.decrementAndGet(); throw rx; &#125; &#125;&#125; TaskQueue.java 1234567public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; if ( parent.isShutdown() ) throw new RejectedExecutionException( &quot;Executor not running, can&#x27;t force a command into the queue&quot; ); return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task is rejected&#125; Connector 配置 配置项 默认值 说明 acceptorThreadCount 1 acceptor 线程数量 pollerThreadCount 1 poller 线程数量 minSpareThreads 10 核心线程数，即 corePoolSize maxThreads 200 最大线程数，即 maximumPoolSize executor - Executor 名称，用来引用下面的 Executor Executor 线程配置 配置项 默认值 说明 threadPriority 5 线程优先级 daemon true 是否守护线程 minSpareThreads 25 核心线程数，即 corePoolSize maxThreads 200 最大线程数，即 maximumPoolSize maxIdleTime 60000 线程生存时间，单位是毫秒，默认值即 1 分钟 maxQueueSize Integer.MAX_VALUE 队列长度 prestartminSpareThreads false 核心线程是否在服务器启动时启动 123456graph LRa(添加新任务) --&gt; b(提交任务 &lt; 核心线程)b --&gt;|是| c(加入队列)b --&gt; |否| d(提交任务 &lt; 最大线程)d --&gt; |是| e(创建急救线程)d --&gt; |否| c 1.3 Fork/Join(1) 概念Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解 Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 Fork/Join 默认会创建与 cpu 核心数大小相同的线程池 (2) 使用提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务 123456789101112131415161718192021222324252627@Slf4j(topic = &quot;c.AddTask&quot;)class AddTask1 extends RecursiveTask&lt;Integer&gt; &#123; int n; public AddTask1(int n) &#123; this.n = n; &#125; @Override public String toString() &#123; return &quot;&#123;&quot; + n + &#x27;&#125;&#x27;; &#125; @Override protected Integer compute() &#123; // 如果 n 已经为 1，可以求得结果了 if (n == 1) &#123; log.debug(&quot;join() &#123;&#125;&quot;, n); return n; &#125; // 将任务进行拆分(fork) AddTask1 t1 = new AddTask1(n - 1); t1.fork(); log.debug(&quot;fork() &#123;&#125; + &#123;&#125;&quot;, n, t1); // 合并(join)结果 int result = n + t1.join(); log.debug(&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, n, t1, result); return result; &#125;&#125; 然后提交给 ForkJoinPool 来执行 1234public static void main(String[] args) &#123; ForkJoinPool pool = new ForkJoinPool(4); System.out.println(pool.invoke(new AddTask1(5)));&#125; 结果 12345678910[ForkJoinPool-1-worker-0] - fork() 2 + &#123;1&#125;[ForkJoinPool-1-worker-1] - fork() 5 + &#123;4&#125;[ForkJoinPool-1-worker-0] - join() 1[ForkJoinPool-1-worker-0] - join() 2 + &#123;1&#125; = 3[ForkJoinPool-1-worker-2] - fork() 4 + &#123;3&#125;[ForkJoinPool-1-worker-3] - fork() 3 + &#123;2&#125;[ForkJoinPool-1-worker-3] - join() 3 + &#123;2&#125; = 6[ForkJoinPool-1-worker-2] - join() 4 + &#123;3&#125; = 10[ForkJoinPool-1-worker-1] - join() 5 + &#123;4&#125; = 1515 用图来表示 123456789101112131415graph LRt1(&quot;t1 5 + &#123;4&#125;&quot;)t2(&quot;t2 4 + &#123;3&#125;&quot;)t3(&quot;t3 3 + &#123;2&#125;&quot;)t00(&quot;t0 2 + &#123;1&#125;&quot;)t0(&quot;t0&quot;)t00 -- &quot;&#123;1&#125;&quot; --&gt; t0t0 -. &quot;1&quot; .-&gt; t00t3 -. &quot;&#123;2&#125;&quot; .-&gt; t00t00 -. &quot;3&quot; .-&gt; t3t2 -- &quot;&#123;3&#125;&quot; --&gt; t3t3 -. &quot;6&quot; .-&gt; t2t1 -- &quot;&#123;4&#125;&quot; --&gt; t2t2 -. &quot;10&quot; .-&gt; t1 改进 1234567891011121314151617181920212223242526272829303132333435class AddTask3 extends RecursiveTask&lt;Integer&gt; &#123; int begin; int end; public AddTask3(int begin, int end) &#123; this.begin = begin; this.end = end; &#125; @Override public String toString() &#123; return &quot;&#123;&quot; + begin + &quot;,&quot; + end + &#x27;&#125;&#x27;; &#125; @Override protected Integer compute() &#123; // 5, 5 if (begin == end) &#123; log.debug(&quot;join() &#123;&#125;&quot;, begin); return begin; &#125; // 4, 5 if (end - begin == 1) &#123; log.debug(&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, begin, end, end + begin); return end + begin; &#125; // 1 5 int mid = (end + begin) / 2; // 3 AddTask3 t1 = new AddTask3(begin, mid); // 1,3 t1.fork(); AddTask3 t2 = new AddTask3(mid + 1, end); // 4,5 t2.fork(); log.debug(&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;, t1, t2); int result = t1.join() + t2.join(); log.debug(&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, t1, t2, result); return result; &#125;&#125; 然后提交给 ForkJoinPool 来执行 1234public static void main(String[] args) &#123; ForkJoinPool pool = new ForkJoinPool(4); System.out.println(pool.invoke(new AddTask3(1, 10)));&#125; 结果 12345678[ForkJoinPool-1-worker-0] - join() 1 + 2 = 3[ForkJoinPool-1-worker-3] - join() 4 + 5 = 9[ForkJoinPool-1-worker-0] - join() 3[ForkJoinPool-1-worker-1] - fork() &#123;1,3&#125; + &#123;4,5&#125; = ?[ForkJoinPool-1-worker-2] - fork() &#123;1,2&#125; + &#123;3,3&#125; = ?[ForkJoinPool-1-worker-2] - join() &#123;1,2&#125; + &#123;3,3&#125; = 6[ForkJoinPool-1-worker-1] - join() &#123;1,3&#125; + &#123;4,5&#125; = 1515 用图来表示 12345678910111213141516graph LRt1(&quot;t1 &#123;1,3&#125; + &#123;4,5&#125;&quot;)t2(&quot;t2 &#123;1,2&#125;,&#123;3,3&#125;&quot;)t3(&quot;t3&quot;)t0(&quot;t0&quot;)t1 -- &quot;&#123;1,3&#125;&quot; --&gt; t2t1 -- &quot;&#123;4,5&#125;&quot; --&gt; t3t2 -- &quot;&#123;1,2&#125;&quot; --&gt; t0t2 -- &quot;&#123;3,3&#125;&quot; --&gt; t0t0 -. &quot;3&quot;.-&gt; t2t0 -. &quot;3&quot; .-&gt; t2t2 -. &quot;6&quot; .- t1t3 -. &quot;9&quot; .-&gt; t1t1 -. 15 .-&gt; 结果 2. J.U.C2.1 AQS 原理概述全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架 特点： 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 getState - 获取 state 状态 setState - 设置 state 状态 compareAndSetState - cas 机制设置 state 状态 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet 子类主要实现这样一些方法（默认抛出 UnsupportedOperationException） tryAcquire tryRelease tryAcquireShared tryReleaseShared isHeldExclusively 获取锁的姿势 1234// 如果获取锁失败if (!tryAcquire(arg)) &#123; // 入队, 可以选择阻塞当前线程 park unpark&#125; 释放锁的姿势 1234// 如果释放锁成功if (tryRelease(arg)) &#123; // 让阻塞线程恢复运行&#125; 实现不可重入锁自定义同步器12345678910111213141516171819202122232425262728293031final class MySync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int acquires) &#123; if (acquires == 1)&#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; &#125; return false; &#125; @Override protected boolean tryRelease(int acquires) &#123; if(acquires == 1) &#123; if(getState() == 0) &#123; throw new IllegalMonitorStateException(); &#125; setExclusiveOwnerThread(null); setState(0); return true; &#125; return false; &#125; protected Condition newCondition() &#123; return new ConditionObject(); &#125; @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125;&#125; 自定义锁有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁 123456789101112131415161718192021222324252627282930313233class MyLock implements Lock &#123; static MySync sync = new MySync(); @Override // 尝试，不成功，进入等待队列 public void lock() &#123; sync.acquire(1); &#125; @Override // 尝试，不成功，进入等待队列，可打断 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override // 尝试一次，不成功返回，不进入队列 public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; @Override // 尝试，不成功，进入等待队列，有时限 public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override // 释放锁 public void unlock() &#123; sync.release(1); &#125; @Override // 生成条件变量 public Condition newCondition() &#123; return sync.newCondition(); &#125;&#125; 测试一下 1234567891011121314151617181920MyLock lock = new MyLock();new Thread(() -&gt; &#123; lock.lock(); try &#123; log.debug(&quot;locking...&quot;); sleep(1); &#125; finally &#123; log.debug(&quot;unlocking...&quot;); lock.unlock(); &#125;&#125;,&quot;t1&quot;).start();new Thread(() -&gt; &#123; lock.lock(); try &#123; log.debug(&quot;locking...&quot;); &#125; finally &#123; log.debug(&quot;unlocking...&quot;); lock.unlock(); &#125;&#125;,&quot;t2&quot;).start(); 输出 123422:29:28.727 c.TestAqs [t1] - locking...22:29:29.732 c.TestAqs [t1] - unlocking...22:29:29.732 c.TestAqs [t2] - locking...22:29:29.732 c.TestAqs [t2] - unlocking... 不可重入测试 如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking） 1234lock.lock();log.debug(&quot;locking...&quot;);lock.lock();log.debug(&quot;locking...&quot;) 心得起源早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。 目标AQS 要实现的功能目标 阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire 获取锁超时机制 通过打断取消机制 独占机制及共享机制 条件不满足时的等待机制 要实现的性能目标 Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended. 设计AQS 的基本思想其实很简单 获取锁的逻辑 123456while(state 状态不允许获取) &#123; if(队列中还没有此进程) &#123; 入队并阻塞 &#125;&#125;当前线程出队 释放锁的逻辑 123if(state 状态允许了) &#123; 恢复阻塞的线程(s)&#125; 要点 原子维护 state 状态 阻塞及恢复线程 维护队列 1) state设计 tate 使用 volatile 配合 cas 保证其修改时的原子性 state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想 2) 阻塞恢复设计 早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume那么 suspend 将感知不到 解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark再park 也没问题 park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细 park 线程还可以通过 interrupt 打断 3) 队列设计 用了 FIFO 先入先出队列，并不支持优先级队列 设计时借鉴了 CLH 队列，它是一种单向无锁队列 1234567891011121314graph LRsubgraph 初始head1(head) --&gt; Dumy1(Dumy)tail1(tail) --&gt; Dumy1endsubgraph 新节点head2(head) --&gt; Dumy2(Dumy)tail2(tail) --&gt; NodeNode -- &quot;prev&quot; --&gt; Dumy2endstyle Dumy1 fill:#f9f,stroke:#333,stroke-width:2pxstyle Dumy2 fill:#f9f,stroke:#333,stroke-width:2px 队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态入队伪代码，只需要考虑 tail 赋值的原子性 12345do &#123; // 原来的 tail Node prev = tail; // 用 cas 在原来 tail 的基础上改为 node&#125; while(tail.compareAndSet(prev,node)) 出队伪代码 123456// prev 是上一个节点while (Node prev=node.prev).state != 唤醒状态) &#123; &#125;// 设置头结点head = node; CLH好处： 无锁，使用自旋 快速，无阻塞 AQS 在一些方面改进了CLH 1234567891011121314151617181920private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; // 队列中还没有元素 tail 为 null if (t == null) &#123; // 将 head 从 null -&gt; dummy if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 将 node 的 prev 设置为原来的 tail node.prev = t; // 将 tail 从原来的 tail 设置为 node if (compareAndSetTail(t, node)) &#123; // 原来 tail 的 next 设置为 node t.next = node; return t; &#125; &#125; &#125;&#125; 主要用到ASQ 的并发工具类 2.2 RenntrantLock 原理 非公平锁实现原理加锁解锁流程先从构造器开始看，默认为非公平锁实现 123public ReentrantLock() &#123; sync = new NonFairSync();&#125; NonfairSync继承自ASQ 没有竞争时 第出现时一个竞争 Thread-1 执行了 (1) CAS 尝试将 state 由 0 改为 1，结果失败 (2)进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 (3) 接下来进入 addWaiter 逻辑，构造 Node 队列 图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 Node 的创建是懒惰的 其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程 当前线程进入 acquireQueued 逻辑 (1) acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞(2) 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为1，失败(3) 进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false (4) shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败(5) 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true(6) 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示） 再次有多个线程经历上述过程竞争失败，变成这个样子 Thread-0 释放锁，进入 tryRelease 流程，如果成功 设置 exclusiveOwnerThread 为 null state = 0 当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程 找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1回到 Thread-1 的 acquireQueued 流程 如果加锁成功（没有竞争），会设置 exclusiveOwnerThread 为 Thread-1，state = 1 head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread 原本的 head 因为从链表断开，而可被垃圾回收 如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了 如果不巧又被 Thread-4 占了先 Thread-4 被设置为 exclusiveOwnerThread，state = 1 Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞 加锁源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// Sync 继承自 AQSstatic final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; // 加锁实现 final void lock() &#123; // 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // 如果尝试失败，进入 ㈠ acquire(1); &#125; // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquire(int arg) &#123; // ㈡ tryAcquire if ( !tryAcquire(arg) &amp;&amp; // 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤ acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) &#123; selfInterrupt(); &#125; &#125; // ㈡ 进入 ㈢ protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; // ㈢ Sync 继承过来的方法, 方便阅读, 放在此处 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); // 如果还没有获得锁 if (c == 0) &#123; // 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 else if (current == getExclusiveOwnerThread()) &#123; // state++ int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; // 获取失败, 回到调用处 return false; &#125; // ㈣ AQS 继承过来的方法, 方便阅读, 放在此处 private Node addWaiter(Node mode) &#123; // 将当前线程关联到一个 Node 对象上, 模式为独占模式 Node node = new Node(Thread.currentThread(), mode); // 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; // 双向链表 pred.next = node; return node; &#125; &#125; // 尝试将 Node 加入 AQS, 进入 ㈥ enq(node); return node; &#125; // ㈥ AQS 继承过来的方法, 方便阅读, 放在此处 private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0） if (compareAndSetHead(new Node())) &#123; tail = head; &#125; &#125; else &#123; // cas 尝试将 Node 对象加入 AQS 队列尾部 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; // ㈤ AQS 继承过来的方法, 方便阅读, 放在此处 final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); // 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 获取成功, 设置自己（当前线程对应的 node）为 head setHead(node); // 上一个节点 help GC p.next = null; failed = false; // 返回中断标记 false return interrupted; &#125; if ( // 判断是否应当 park, 进入 ㈦ shouldParkAfterFailedAcquire(p, node) &amp;&amp; // park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧ parkAndCheckInterrupt() ) &#123; interrupted = true; &#125; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; // ㈦ AQS 继承过来的方法, 方便阅读, 放在此处 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 获取上一个节点的状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) &#123; // 上一个节点都在阻塞, 那么自己也阻塞好了 return true; &#125; // &gt; 0 表示取消状态 if (ws &gt; 0) &#123; // 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 这次还没有阻塞 // 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; // ㈧ 阻塞当前线程 private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125;&#125; 注意 是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定 解锁源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Sync 继承自 AQSstatic final class NonfairSync extends Sync &#123; // 解锁实现 public void unlock() &#123; sync.release(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean release(int arg) &#123; // 尝试释放锁, 进入 ㈠ if (tryRelease(arg)) &#123; // 队列头节点 unpark Node h = head; if ( // 队列不为 null h != null &amp;&amp; // waitStatus == Node.SIGNAL 才需要 unpark h.waitStatus != 0 ) &#123; // unpark AQS 中等待的线程, 进入 ㈡ unparkSuccessor(h); &#125; return true; &#125; return false; &#125; // ㈠ Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryRelease(int releases) &#123; // state-- int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 支持锁重入, 只有 state 减为 0, 才释放成功 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处 private void unparkSuccessor(Node node) &#123; // 如果状态为 Node.SIGNAL 尝试重置状态为 0 // 不成功也可以 int ws = node.waitStatus; if (ws &lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; // 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的 Node s = node.next; // 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread); &#125;&#125; 可重入原理123456789101112131415161718192021222324252627282930313233343536373839static final class NonfairSync extends Sync &#123; // ... // Sync 继承过来的方法, 方便阅读, 放在此处 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 else if (current == getExclusiveOwnerThread()) &#123; // state++ int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryRelease(int releases) &#123; // state-- int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 支持锁重入, 只有 state 减为 0, 才释放成功 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125;&#125; 可打断原理不可打断模式在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Sync 继承自 AQSstatic final class NonfairSync extends Sync &#123; // ... private final boolean parkAndCheckInterrupt() &#123; // 如果打断标记已经是 true, 则 park 会失效 LockSupport.park(this); // interrupted 会清除打断标记 return Thread.interrupted(); &#125; final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; failed = false; // 还是需要获得锁后, 才能返回打断状态 return interrupted; &#125; if ( shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt() ) &#123; // 如果是因为 interrupt 被唤醒, 返回打断状态为 true interrupted = true; &#125; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; public final void acquire(int arg) &#123; if ( !tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) &#123; // 如果打断状态为 true selfInterrupt(); &#125; &#125; static void selfInterrupt() &#123; // 重新产生一次中断 Thread.currentThread().interrupt(); &#125;&#125; 打断模式12345678910111213141516171819202122232425262728293031323334static final class NonfairSync extends Sync &#123; public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 如果没有获得到锁, 进入 ㈠ if (!tryAcquire(arg)) doAcquireInterruptibly(arg); &#125; // ㈠ 可打断的获取锁流程 private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; // 在 park 过程中如果被 interrupt 会进入此 // 这时候抛出异常, 而不会再次进入 for (;;) throw new InterruptedException(); &#125; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;&#125; 公平锁实现原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquire(int arg) &#123; if ( !tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) &#123; selfInterrupt(); &#125; &#125; // 与非公平锁主要区别在于 tryAcquire 方法的实现 protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 先检查 AQS 队列中是否有前驱节点, 没有才去竞争 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; // h != t 时表示队列中有 Node return h != t &amp;&amp; ( // (s = h.next) == null 表示队列中还有没有老二 (s = h.next) == null || // 或者队列中老二线程不是此线程 s.thread != Thread.currentThread() ); &#125;&#125; 条件变量实现原理每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject await 流程开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部 接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁 unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功 signal 流程假设 Thread-1 要来唤醒 Thread-0 进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node firstWaiter就是第一个节点，而不是firstWaiter的nextWaiter，此时第一个节点脱离该链表结构，firstWaiter指向下一个 lastWaiter总是最后一个节点，直到没有节点firstWaiter和lastWaiter都指向null 执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1 如果 Node 节点这时被 取消，这Node 节点不会再 signal ，会重新去执行 在 ConditionObject中 的 firstWaiter的doSignal 流程 Thread-1 释放锁 如果 新加入的Node 的前一个节点 由于 被取消或者超时，会优先将 Node 节点 恢复为(调用unpark) 运行 其他情况按照 AQS 节点优先顺序 去 执行 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; // 第一个等待节点 private transient Node firstWaiter; // 最后一个等待节点 private transient Node lastWaiter; public ConditionObject() &#123; &#125; // ㈠ 添加一个 Node 至等待队列 private Node addConditionWaiter() &#123; Node t = lastWaiter; // 所有已取消的 Node 从队列链表删除, 见 ㈡ if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; // 创建一个关联当前线程的新 Node, 添加至队列尾部 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; &#125; // 唤醒 - 将没取消的第一个节点转移至 AQS 队列 private void doSignal(Node first) &#123; do &#123; // 已经是尾节点了 if ( (firstWaiter = first.nextWaiter) == null) &#123; lastWaiter = null; &#125; first.nextWaiter = null; &#125; while ( // 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢ !transferForSignal(first) &amp;&amp; // 队列还有节点 (first = firstWaiter) != null ); &#125; // 外部类方法, 方便阅读, 放在此处 // ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功 final boolean transferForSignal(Node node) &#123; // 如果状态已经不是 Node.CONDITION, 说明被取消了 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; // 加入 AQS 队列尾部 Node p = enq(node); int ws = p.waitStatus; if ( // 上一个节点被取消 ws &gt; 0 || // 上一个节点不能设置状态为 Node.SIGNAL !compareAndSetWaitStatus(p, ws, Node.SIGNAL) ) &#123; // unpark 取消阻塞, 让线程重新同步状态 LockSupport.unpark(node.thread); &#125; return true; &#125; // 全部唤醒 - 等待队列的所有节点转移至 AQS 队列 private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null); &#125; // ㈡ private void unlinkCancelledWaiters() &#123; // ... &#125; // 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁 public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); &#125; // 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁 public final void signalAll() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first); &#125; // 不可打断等待 - 直到被唤醒 public final void awaitUninterruptibly() &#123; // 添加一个 Node 至等待队列, 见 ㈠ Node node = addConditionWaiter(); // 释放节点持有的锁, 见 ㈣ int savedState = fullyRelease(node); boolean interrupted = false; // 如果该节点还没有转移至 AQS 队列, 阻塞 while (!isOnSyncQueue(node)) &#123; // park 阻塞 LockSupport.park(this); // 如果被打断, 仅设置打断状态 if (Thread.interrupted()) interrupted = true; &#125; // 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列 if (acquireQueued(node, savedState) || interrupted) selfInterrupt(); &#125; // 外部类方法, 方便阅读, 放在此处 // ㈣ 因为某线程可能重入，需要将 state 全部释放 final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125; &#125; // 打断模式 - 在退出等待时重新设置打断状态 private static final int REINTERRUPT = 1; // 打断模式 - 在退出等待时抛出异常 private static final int THROW_IE = -1; // 判断打断模式 private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; &#125; // ㈤ 应用打断模式 private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt(); &#125; // 等待 - 直到被唤醒或打断 public final void await() throws InterruptedException &#123; if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; // 添加一个 Node 至等待队列, 见 ㈠ Node node = addConditionWaiter(); // 释放节点持有的锁 int savedState = fullyRelease(node); int interruptMode = 0; // 如果该节点还没有转移至 AQS 队列, 阻塞 while (!isOnSyncQueue(node)) &#123; // park 阻塞 LockSupport.park(this); // 如果被打断, 退出等待队列 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; // 退出等待队列后, 还需要获得 AQS 队列的锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; // 所有已取消的 Node 从队列链表删除, 见 ㈡ if (node.nextWaiter != null) unlinkCancelledWaiters(); // 应用打断模式, 见 ㈤ if (interruptMode != 0) reportInterruptAfterWait(interruptMode); &#125; // 等待 - 直到被唤醒或打断或超时 public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; // 添加一个 Node 至等待队列, 见 ㈠ Node node = addConditionWaiter(); // 释放节点持有的锁 int savedState = fullyRelease(node); // 获得最后期限 final long deadline = System.nanoTime() + nanosTimeout; int interruptMode = 0; // 如果该节点还没有转移至 AQS 队列, 阻塞 while (!isOnSyncQueue(node)) &#123; // 已超时, 退出等待队列 if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; // park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // 如果被打断, 退出等待队列 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; // 退出等待队列后, 还需要获得 AQS 队列的锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; // 所有已取消的 Node 从队列链表删除, 见 ㈡ if (node.nextWaiter != null) unlinkCancelledWaiters(); // 应用打断模式, 见 ㈤ if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime(); &#125; // 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos public final boolean awaitUntil(Date deadline) throws InterruptedException &#123; // ... &#125; // 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos public final boolean await(long time, TimeUnit unit) throws InterruptedException &#123; // ... &#125; // 工具方法 省略 ...&#125; 2.3 读写锁ReentrantReadWriteLock当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select ... from ... lock in share mode 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法 1234567891011121314151617181920212223242526272829class DataContainer &#123; private Object data; private ReentrantReadWriteLock rw = new ReentrantReadWriteLock(); private ReentrantReadWriteLock.ReadLock r = rw.readLock(); private ReentrantReadWriteLock.WriteLock w = rw.writeLock(); public Object read() &#123; log.debug(&quot;获取读锁...&quot;); r.lock(); try &#123; log.debug(&quot;读取&quot;); sleep(1); return data; &#125; finally &#123; log.debug(&quot;释放读锁...&quot;); r.unlock(); &#125; &#125; public void write() &#123; log.debug(&quot;获取写锁...&quot;); w.lock(); try &#123; log.debug(&quot;写入&quot;); sleep(1); &#125; finally &#123; log.debug(&quot;释放写锁...&quot;); w.unlock(); &#125; &#125;&#125; 测试 读锁-读锁 可以并发 1234567DataContainer dataContainer = new DataContainer();new Thread(() -&gt; &#123; dataContainer.read();&#125;, &quot;t1&quot;).start();new Thread(() -&gt; &#123; dataContainer.read();&#125;, &quot;t2&quot;).start() 输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响 12345614:05:14.341 c.DataContainer [t2] - 获取读锁...14:05:14.341 c.DataContainer [t1] - 获取读锁...14:05:14.345 c.DataContainer [t1] - 读取14:05:14.345 c.DataContainer [t2] - 读取14:05:15.365 c.DataContainer [t2] - 释放读锁...14:05:15.386 c.DataContainer [t1] - 释放读锁... 测试 读锁-写锁 相互阻塞 12345678DataContainer dataContainer = new DataContainer();new Thread(() -&gt; &#123; dataContainer.read();&#125;, &quot;t1&quot;).start();Thread.sleep(100);new Thread(() -&gt; &#123; dataContainer.write();&#125;, &quot;t2&quot;).start(); 输出结果 12345614:04:21.838 c.DataContainer [t1] - 获取读锁...14:04:21.838 c.DataContainer [t2] - 获取写锁...14:04:21.841 c.DataContainer [t2] - 写入14:04:22.843 c.DataContainer [t2] - 释放写锁...14:04:22.843 c.DataContainer [t1] - 读取14:04:23.843 c.DataContainer [t1] - 释放读锁... 写锁-写锁 也是相互阻塞的，这里就不测试了 注意事项 读锁不支持条件变量 重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待 123456789101112r.lock();try &#123;// ...w.lock();try &#123;// ...&#125; finally&#123;w.unlock();&#125;&#125; finally&#123;r.unlock();&#125; 重入时降级支持：即持有写锁的情况下去获取读锁 12345678910111213141516171819202122232425262728293031class CachedData &#123; Object data; // 是否有效，如果失效，需要重新计算 data volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // 获取写锁前必须释放读锁 rwl.readLock().unlock(); rwl.writeLock().lock(); try &#123; // 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新 if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存 rwl.readLock().lock(); &#125; finally &#123; rwl.writeLock().unlock(); &#125; &#125; // 自己用完数据, 释放读锁 try &#123; use(data); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125;&#125; 应用之缓存缓存更新策略更新时，是先清缓存还是先更新数据库 先清缓存 先更新数据库 补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询 这种情况的出现几率非常小，见 facebook 论文 读写锁一致性缓存使用读写锁实现一个简单的按需加载缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class GenericCachedDao&lt;T&gt; &#123; // HashMap 作为缓存非线程安全, 需要保护 HashMap&lt;SqlPair, T&gt; map = new HashMap&lt;&gt;(); ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); GenericDao genericDao = new GenericDao(); public int update(String sql, Object... params) &#123; SqlPair key = new SqlPair(sql, params); // 加写锁, 防止其它线程对缓存读取和更改 lock.writeLock().lock(); try &#123; int rows = genericDao.update(sql, params); map.clear(); return rows; &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; public T queryOne(Class&lt;T&gt; beanClass, String sql, Object... params) &#123; SqlPair key = new SqlPair(sql, params); // 加读锁, 防止其它线程对缓存更改 lock.readLock().lock(); try &#123; T value = map.get(key); if (value != null) &#123; return value; &#125; &#125; finally &#123; lock.readLock().unlock(); &#125; // 加写锁, 防止其它线程对缓存读取和更改 lock.writeLock().lock(); try &#123; // get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据 // 为防止重复查询数据库, 再次验证 T value = map.get(key); if (value == null) &#123; // 如果没有, 查询数据库 value = genericDao.queryOne(beanClass, sql, params); map.put(key, value); &#125; return value; &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; // 作为 key 保证其是不可变的 class SqlPair &#123; private String sql; private Object[] params; public SqlPair(String sql, Object[] params) &#123; this.sql = sql; this.params = params; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; SqlPair sqlPair = (SqlPair) o; return sql.equals(sqlPair.sql) &amp;&amp; Arrays.equals(params, sqlPair.params); &#125; @Override public int hashCode() &#123; int result = Objects.hash(sql); result = 31 * result + Arrays.hashCode(params); return result; &#125; &#125;&#125; 注意 以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑 适合读多写少，如果写操作比较频繁，以上实现性能低 没有考虑缓存容量 没有考虑缓存过期 只适合单机 并发性还是低，目前只会用一把锁 更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key） 乐观锁实现：用 CAS 去更新 读写锁原理(1) 图解流程读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个 t1 w.lock，t2 r.lock(1) t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位 (2) t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败 tryAcquireShared 返回值表示 -1 表示失败 0 表示成功，但后继节点不会继续唤醒 正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1 (3) 这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态 (4) t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁 (5) 如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，(总共尝试了三次tryAcquireShared) 那么在 parkAndCheckInterrupt() 处 park t3 r.lock，t4 w.lock这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子 1 w.unlock这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子 接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一 这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点 事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一 这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点 下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点 t2 r.unlock，t3 r.unlockt2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零 t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即 之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束 (2) 源码分析写锁上锁流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static final class NonfairSync extends Sync &#123; // ... 省略无关代码 // 外部类 WriteLock 方法, 方便阅读, 放在此处 public void lock() &#123; sync.acquire(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquire(int arg) &#123; if ( // 尝试获得写锁失败 !tryAcquire(arg) &amp;&amp; // 将当前线程关联到一个 Node 对象上, 模式为独占模式 // 进入 AQS 队列阻塞 acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) &#123; selfInterrupt(); &#125; &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryAcquire(int acquires) &#123; // 获得低 16 位, 代表写锁的 state 计数 Thread current = Thread.currentThread(); int c = getState(); int w = exclusiveCount(c); if (c != 0) &#123; if ( // c != 0 and w == 0 表示有读锁, 或者 w == 0 || // 如果 exclusiveOwnerThread 不是自己 current != getExclusiveOwnerThread() ) &#123; // 获得锁失败 return false; &#125; // 写锁计数超过低 16 位, 报异常 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(&quot;Maximum lock count exceeded&quot;); // 写锁重入, 获得锁成功 setState(c + acquires); return true; &#125; if ( // 判断写锁是否该阻塞, 或者 writerShouldBlock() || // 尝试更改计数失败 !compareAndSetState(c, c + acquires) ) &#123; // 获得锁失败 return false; &#125; // 获得锁成功 setExclusiveOwnerThread(current); return true; &#125; // 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞 final boolean writerShouldBlock() &#123; return false; &#125;&#125; 写锁释放流程1234567891011121314151617181920212223242526272829303132static final class NonfairSync extends Sync &#123; // ... 省略无关代码 // WriteLock 方法, 方便阅读, 放在此处 public void unlock() &#123; sync.release(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean release(int arg) &#123; // 尝试释放写锁成功 if (tryRelease(arg)) &#123; // unpark AQS 中等待的线程 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryRelease(int releases) &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; // 因为可重入的原因, 写锁计数为 0, 才算释放成功 boolean free = exclusiveCount(nextc) == 0; if (free) &#123; setExclusiveOwnerThread(null); &#125; setState(nextc); return free; &#125;&#125; 读锁上锁流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144static final class NonfairSync extends Sync &#123; // ReadLock 方法, 方便阅读, 放在此处 public void lock() &#123; sync.acquireShared(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquireShared(int arg) &#123; // tryAcquireShared 返回负数, 表示获取读锁失败 if (tryAcquireShared(arg) &lt; 0) &#123; doAcquireShared(arg); &#125; &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); // 如果是其它线程持有写锁, 获取读锁失败 if ( exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current ) &#123; return -1; &#125; int r = sharedCount(c); if ( // 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且 !readerShouldBlock() &amp;&amp; // 小于读锁计数, 并且 r &lt; MAX_COUNT &amp;&amp; // 尝试增加计数成功 compareAndSetState(c, c + SHARED_UNIT) ) &#123; // ... 省略不重要的代码 return 1; &#125; return fullTryAcquireShared(current); &#125; // 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁 // true 则该阻塞, false 则不阻塞 final boolean readerShouldBlock() &#123; return apparentlyFirstQueuedIsExclusive(); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 // 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞 final int fullTryAcquireShared(Thread current) &#123; HoldCounter rh = null; for (;;) &#123; int c = getState(); if (exclusiveCount(c) != 0) &#123; if (getExclusiveOwnerThread() != current) return -1; &#125; else if (readerShouldBlock()) &#123; // ... 省略不重要的代码 &#125; if (sharedCount(c) == MAX_COUNT) throw new Error(&quot;Maximum lock count exceeded&quot;); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // ... 省略不重要的代码 return 1; &#125; &#125; &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 private void doAcquireShared(int arg) &#123; // 将当前线程关联到一个 Node 对象上, 模式为共享模式 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // 再一次尝试获取读锁 int r = tryAcquireShared(arg); // 成功 if (r &gt;= 0) &#123; // ㈠ // r 表示可用资源数, 在这里总是 1 允许传播 //（唤醒 AQS 中下一个 Share 节点） setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if ( // 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL） shouldParkAfterFailedAcquire(p, node) &amp;&amp; // park 当前线程 parkAndCheckInterrupt() ) &#123; interrupted = true; &#125; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处 private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below // 设置自己为 head setHead(node); // propagate 表示有共享资源（例如共享读锁或信号量） // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 如果是最后一个节点或者是等待共享读锁的节点 if (s == null || s.isShared()) &#123; // 进入 ㈡ doReleaseShared(); &#125; &#125; &#125; // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处 private void doReleaseShared() &#123; // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析 for (;;) &#123; Node h = head; // 队列还有节点 if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 下一个节点 unpark 如果成功获取读锁 // 并且下下个节点还是 shared, 继续 doReleaseShared unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125;&#125; 读锁释放流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static final class NonfairSync extends Sync &#123; // ReadLock 方法, 方便阅读, 放在此处 public void unlock() &#123; sync.releaseShared(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryReleaseShared(int unused) &#123; // ... 省略不重要的代码 for (;;) &#123; int c = getState(); int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) &#123; // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程 // 计数为 0 才是真正释放 return nextc == 0; &#125; &#125; &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 private void doReleaseShared() &#123; // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; // 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0 // 防止 unparkSuccessor 被多次执行 if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; // 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125;&#125; StampedLock该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用加解读锁 12long stamp = lock.readLock();lock.unlockRead(stamp); 加解写锁 12long stamp = lock.writeLock();lock.unlockWrite(stamp); 乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。 12345long stamp = lock.tryOptimisticRead();// 验戳if(!lock.validate(stamp))&#123; // 锁升级&#125; 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法 123456789101112131415161718192021222324252627282930313233343536373839class DataContainerStamped &#123; private int data; private final StampedLock lock = new StampedLock(); public DataContainerStamped(int data) &#123; this.data = data; &#125; public int read(int readTime) &#123; long stamp = lock.tryOptimisticRead(); log.debug(&quot;optimistic read locking...&#123;&#125;&quot;, stamp); sleep(readTime); if (lock.validate(stamp)) &#123; log.debug(&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;, stamp, data); return data; &#125; // 锁升级 - 读锁 log.debug(&quot;updating to read lock... &#123;&#125;&quot;, stamp); try &#123; stamp = lock.readLock(); log.debug(&quot;read lock &#123;&#125;&quot;, stamp); sleep(readTime); log.debug(&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;, stamp, data); return data; &#125; finally &#123; log.debug(&quot;read unlock &#123;&#125;&quot;, stamp); lock.unlockRead(stamp); &#125; &#125; public void write(int newData) &#123; long stamp = lock.writeLock(); log.debug(&quot;write lock &#123;&#125;&quot;, stamp); try &#123; sleep(2); this.data = newData; &#125; finally &#123; log.debug(&quot;write unlock &#123;&#125;&quot;, stamp); lock.unlockWrite(stamp); &#125; &#125;&#125; 测试 读-读 可以优化 12345678910public static void main(String[] args) &#123; DataContainerStamped dataContainer = new DataContainerStamped(1); new Thread(() -&gt; &#123; dataContainer.read(1); &#125;, &quot;t1&quot;).start(); sleep(0.5); new Thread(() -&gt; &#123; dataContainer.read(0); &#125;, &quot;t2&quot;).start();&#125; 输出结果，可以看到实际没有加读锁 123415:58:50.217 c.DataContainerStamped [t1] - optimistic read locking...25615:58:50.717 c.DataContainerStamped [t2] - optimistic read locking...25615:58:50.717 c.DataContainerStamped [t2] - read finish...256, data:115:58:51.220 c.DataContainerStamped [t1] - read finish...256, data:1 测试 读-写 时优化读补加读锁 12345678910public static void main(String[] args) &#123; DataContainerStamped dataContainer = new DataContainerStamped(1); new Thread(() -&gt; &#123; dataContainer.read(1); &#125;, &quot;t1&quot;).start(); sleep(0.5); new Thread(() -&gt; &#123; dataContainer.write(100); &#125;, &quot;t2&quot;).start();&#125; 输出结果 123456715:57:00.219 c.DataContainerStamped [t1] - optimistic read locking...25615:57:00.717 c.DataContainerStamped [t2] - write lock 38415:57:01.225 c.DataContainerStamped [t1] - updating to read lock... 25615:57:02.719 c.DataContainerStamped [t2] - write unlock 38415:57:02.719 c.DataContainerStamped [t1] - read lock 51315:57:03.719 c.DataContainerStamped [t1] - read finish...513, data:100015:57:03.719 c.DataContainerStamped [t1] - read unlock 513 注意 StampedLock 不支持条件变量 StampedLock 不支持可重入 2.4 Semaphore基本使用[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限 1234567891011121314151617181920212223public static void main(String[] args) &#123; // 1. 创建 semaphore 对象 Semaphore semaphore = new Semaphore(3); // 2. 10个线程同时运行 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; // 3. 获取许可 try &#123; semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; log.debug(&quot;running...&quot;); sleep(1); log.debug(&quot;end...&quot;); &#125; finally &#123; // 4. 释放许可 semaphore.release(); &#125; &#125;).start(); &#125;&#125; 输出 123456789101112131415161718192007:35:15.485 c.TestSemaphore [Thread-2] - running...07:35:15.485 c.TestSemaphore [Thread-1] - running...07:35:15.485 c.TestSemaphore [Thread-0] - running...07:35:16.490 c.TestSemaphore [Thread-2] - end...07:35:16.490 c.TestSemaphore [Thread-0] - end...07:35:16.490 c.TestSemaphore [Thread-1] - end...07:35:16.490 c.TestSemaphore [Thread-3] - running...07:35:16.490 c.TestSemaphore [Thread-5] - running...07:35:16.490 c.TestSemaphore [Thread-4] - running...07:35:17.490 c.TestSemaphore [Thread-5] - end...07:35:17.490 c.TestSemaphore [Thread-4] - end...07:35:17.490 c.TestSemaphore [Thread-3] - end...07:35:17.490 c.TestSemaphore [Thread-6] - running...07:35:17.490 c.TestSemaphore [Thread-7] - running...07:35:17.490 c.TestSemaphore [Thread-9] - running...07:35:18.491 c.TestSemaphore [Thread-6] - end...07:35:18.491 c.TestSemaphore [Thread-7] - end...07:35:18.491 c.TestSemaphore [Thread-9] - end...07:35:18.491 c.TestSemaphore [Thread-8] - running...07:35:19.492 c.TestSemaphore [Thread-8] - end... 应用限制对共享资源的使用semaphore 实现 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现） 用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Slf4j(topic = &quot;c.Pool&quot;)class Pool &#123; // 1. 连接池大小 private final int poolSize; // 2. 连接对象数组 private Connection[] connections; // 3. 连接状态数组 0 表示空闲， 1 表示繁忙 private AtomicIntegerArray states; private Semaphore semaphore; // 4. 构造方法初始化 public Pool(int poolSize) &#123; this.poolSize = poolSize; // 让许可数与资源数一致 this.semaphore = new Semaphore(poolSize); this.connections = new Connection[poolSize]; this.states = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &lt; poolSize; i++) &#123; connections[i] = new MockConnection(&quot;连接&quot; + (i+1)); &#125; &#125; // 5. 借连接 public Connection borrow() &#123;// t1, t2, t3 // 获取许可 try &#123; semaphore.acquire(); // 没有许可的线程，在此等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; poolSize; i++) &#123; // 获取空闲连接 if(states.get(i) == 0) &#123; if (states.compareAndSet(i, 0, 1)) &#123; log.debug(&quot;borrow &#123;&#125;&quot;, connections[i]); return connections[i]; &#125; &#125; &#125; // 不会执行到这里 return null; &#125; // 6. 归还连接 public void free(Connection conn) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (connections[i] == conn) &#123; states.set(i, 0); log.debug(&quot;free &#123;&#125;&quot;, conn); semaphore.release(); break; &#125; &#125; &#125;&#125; 原理加锁解锁流程Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减 刚开始，permits（state）为 3，这时 5 个线程来获取资源 假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞 这时 Thread-4 释放了 permits，状态如下 接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态 被唤醒的节点会去唤醒它接下来的节点 队列中有些节点因为被用户中断而节点状态被设置为了1，中断后的节点自己会除去该节点（可中断模式） 被唤醒的节点，不会存在被用户中断的可能（取消还没完成，节点还没去除），因为唤醒 (release) 是找到离head最近的一个 状态为-1，被中断为1 的不会去唤醒(unpark) 源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; // permits 即 state super(permits); &#125; // Semaphore 方法, 方便阅读, 放在此处 public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); &#125; // 尝试获得共享锁 protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if ( // 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly remaining &lt; 0 || // 如果 cas 重试成功, 返回正数, 表示获取成功 compareAndSetState(available, remaining) ) &#123; return remaining; &#125; &#125; &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // 再次尝试获取许可 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 成功后本线程出队（AQS）, 所在 Node设置为 head // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE // r 表示可用资源数, 为 0 则不会继续传播 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; // Semaphore 方法, 方便阅读, 放在此处 public void release() &#123; sync.releaseShared(1); &#125; // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); if (compareAndSetState(current, next)) return true; &#125; &#125;&#125; 为什么要有 PROPAGATE早期有 bug releaseShared 方法 123456789public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; doAcquireShared 方法 12345678910111213141516171819202122232425262728private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 这里会有空档 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; setHeadAndPropagate 方法 12345678910111213141516171819202122232425262728private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 这里会有空档 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; setHeadAndPropagate 方法 12345678910private void setHeadAndPropagate(Node node, int propagate) &#123; setHead(node); // 有空闲资源 if (propagate &gt; 0 &amp;&amp; node.waitStatus != 0) &#123; Node s = node.next; // 下一个 if (s == null || s.isShared()) unparkSuccessor(node); &#125;&#125; 假设存在某次循环中队列里排队的结点情况为 head(-1)-&gt;t1(-1)-&gt;t2(-1) 假设存在将要信号量释放的 T3 和 T4，释放顺序为先 T3 后 T4 (1) 正常流程 (2) 产生 bug 的情况 修复前版本执行流程(1) T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head 的等待状态从 -1 变为 0 (2) T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，假设返回值为 0（获取锁成功，但没有剩余资源量） (3) T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个head），不满足条件，因此不调用 unpark-Successor(head) (4) T1 获取信号量成功，调用 setHeadAndPropagate 时，因为不满足 propagate &gt; 0（2 的返回值也就是 propagate（剩余资源量）== 0），从而不会唤醒后继结点， T2 线程得不到唤醒 (3) bug 修复后123456789101112131415161718192021222324252627282930313233343536private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below // 设置自己为 head setHead(node); // propagate 表示有共享资源（例如共享读锁或信号量） // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 如果是最后一个节点或者是等待共享读锁的节点 if (s == null || s.isShared()) &#123; doReleaseShared(); &#125; &#125;&#125;private void doReleaseShared() &#123; // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; (1) T3 调用 releaseShared()，直接调用了 unparkSuccessor(head)，head 的等待状态从 -1 变为 0 (2) T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，假设返回值为 0（获取锁成功，但没有剩余资源量） (3) T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 *PROPAGATE***（-3） (4) T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus &lt; 0，从而调用 doReleaseShared() 唤醒 T2 2.5 CountdownLatch 用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一 123456789101112131415161718192021222324public static void main(String[] args) throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(3); new Thread(() -&gt; &#123; log.debug(&quot;begin...&quot;); sleep(1); latch.countDown(); log.debug(&quot;end...&#123;&#125;&quot;, latch.getCount()); &#125;).start(); new Thread(() -&gt; &#123; log.debug(&quot;begin...&quot;); sleep(2); latch.countDown(); log.debug(&quot;end...&#123;&#125;&quot;, latch.getCount()); &#125;).start(); new Thread(() -&gt; &#123; log.debug(&quot;begin...&quot;); sleep(1.5); latch.countDown(); log.debug(&quot;end...&#123;&#125;&quot;, latch.getCount()); &#125;).start(); log.debug(&quot;waiting...&quot;); latch.await(); log.debug(&quot;wait end...&quot;);&#125; 输出 1234567818:44:00.778 c.TestCountDownLatch [main] - waiting...18:44:00.778 c.TestCountDownLatch [Thread-2] - begin...18:44:00.778 c.TestCountDownLatch [Thread-0] - begin...18:44:00.778 c.TestCountDownLatch [Thread-1] - begin...18:44:01.782 c.TestCountDownLatch [Thread-0] - end...218:44:02.283 c.TestCountDownLatch [Thread-2] - end...118:44:02.782 c.TestCountDownLatch [Thread-1] - end...018:44:02.782 c.TestCountDownLatch [main] - wait end... 可以配合线程池使用，改进如下 12345678910111213141516171819202122232425262728293031public static void main(String[] args) throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(3); ExecutorService service = Executors.newFixedThreadPool(4); service.submit(() -&gt; &#123; log.debug(&quot;begin...&quot;); sleep(1); latch.countDown(); log.debug(&quot;end...&#123;&#125;&quot;, latch.getCount()); &#125;); service.submit(() -&gt; &#123; log.debug(&quot;begin...&quot;); sleep(1.5); latch.countDown(); log.debug(&quot;end...&#123;&#125;&quot;, latch.getCount()); &#125;); service.submit(() -&gt; &#123; log.debug(&quot;begin...&quot;); sleep(2); latch.countDown(); log.debug(&quot;end...&#123;&#125;&quot;, latch.getCount()); &#125;); service.submit(()-&gt;&#123; try &#123; log.debug(&quot;waiting...&quot;); latch.await(); log.debug(&quot;wait end...&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125; 输出 1234567818:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin...18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin...18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin...18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting...18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...218:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...118:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...018:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end... 应用之同步等待多线程准备完毕123456789101112131415161718192021222324AtomicInteger num = new AtomicInteger(0);ExecutorService service = Executors.newFixedThreadPool(10, (r) -&gt; &#123; return new Thread(r, &quot;t&quot; + num.getAndIncrement());&#125;);CountDownLatch latch = new CountDownLatch(10);String[] all = new String[10];Random r = new Random();for (int j = 0; j &lt; 10; j++) &#123; int x = j; service.submit(() -&gt; &#123; for (int i = 0; i &lt;= 100; i++) &#123; try &#123; Thread.sleep(r.nextInt(100)); &#125; catch (InterruptedException e) &#123; &#125; all[x] = Thread.currentThread().getName() + &quot;(&quot; + (i + &quot;%&quot;) + &quot;)&quot;; System.out.print(&quot;\\r&quot; + Arrays.toString(all)); &#125; latch.countDown(); &#125;);&#125;latch.await();System.out.println(&quot;\\n游戏开始...&quot;);service.shutdown(); 中间输出 1[t0(52%), t1(47%), t2(51%), t3(40%), t4(49%), t5(44%), t6(49%), t7(52%), t8(46%), t9(46%)] 最后输出 123[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%),t9(100%)]游戏开始... 应用之同步等待多个远程调用结束12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class TestCountDownlatchController &#123; @GetMapping(&quot;/order/&#123;id&#125;&quot;) public Map&lt;String, Object&gt; order(@PathVariable int id) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;, id); map.put(&quot;total&quot;, &quot;2300.00&quot;); sleep(2000); return map; &#125; @GetMapping(&quot;/product/&#123;id&#125;&quot;) public Map&lt;String, Object&gt; product(@PathVariable int id) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (id == 1) &#123; map.put(&quot;name&quot;, &quot;小爱音箱&quot;); map.put(&quot;price&quot;, 300); &#125; else if (id == 2) &#123; map.put(&quot;name&quot;, &quot;小米手机&quot;); map.put(&quot;price&quot;, 2000); &#125; map.put(&quot;id&quot;, id); sleep(1000); return map; &#125; @GetMapping(&quot;/logistics/&#123;id&#125;&quot;) public Map&lt;String, Object&gt; logistics(@PathVariable int id) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;, id); map.put(&quot;name&quot;, &quot;中通快递&quot;); sleep(2500); return map; &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; rest 远程调用 123456789101112131415161718192021222324252627282930RestTemplate restTemplate = new RestTemplate();log.debug(&quot;begin&quot;);ExecutorService service = Executors.newCachedThreadPool();CountDownLatch latch = new CountDownLatch(4);Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123; Map&lt;String, Object&gt; r = restTemplate.getForObject(&quot;http://localhost:8080/order/&#123;1&#125;&quot;, Map.class, 1); return r;&#125;);Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123; Map&lt;String, Object&gt; r = restTemplate.getForObject(&quot;http://localhost:8080/product/&#123;1&#125;&quot;, Map.class, 1); return r;&#125;);Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123; Map&lt;String, Object&gt; r = restTemplate.getForObject(&quot;http://localhost:8080/product/&#123;1&#125;&quot;, Map.class, 2); return r;&#125;);Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123; Map&lt;String, Object&gt; r = restTemplate.getForObject(&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;, Map.class, 1); return r;&#125;);System.out.println(f1.get());System.out.println(f2.get());System.out.println(f3.get());System.out.println(f4.get());log.debug(&quot;执行完毕&quot;);service.shutdown(); 执行结果 12345619:51:39.711 c.TestCountDownLatch [main] - begin&#123;total=2300.00, id=1&#125;&#123;price=300, name=小爱音箱, id=1&#125;&#123;price=2000, name=小米手机, id=2&#125;&#123;name=中通快递, id=1&#125;19:51:42.407 c.TestCountDownLatch [main] - 执行完毕 2.6 CydicBarrier[ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行 1234567891011121314151617181920CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行new Thread(()-&gt;&#123; System.out.println(&quot;线程1开始..&quot;+new Date()); try &#123; cb.await(); // 当个数不足时，等待 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程1继续向下运行...&quot;+new Date());&#125;).start();new Thread(()-&gt;&#123; System.out.println(&quot;线程2开始..&quot;+new Date()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; try &#123; cb.await(); // 2 秒后，线程个数够2，继续运行 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程2继续向下运行...&quot;+new Date());&#125;).start(); 注意 CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比喻为『人满发车』 2.7 线程安全集合类概述 线程安全集合类可以分为三大类： 遗留的线程安全集合如 Hashtable ， Vector 使用 Collections 装饰的线程安全集合，如： Collections.synchronizedCollection Collections.synchronizedList Collections.synchronizedMap Collections.synchronizedSet Collections.synchronizedNavigableMap Collections.synchronizedNavigableSet Collections.synchronizedSortedMap Collections.synchronizedSortedSet java.util.concurrent.*重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent Blocking 大部分实现基于锁，并提供用来阻塞的方法 CopyOnWrite 之类容器修改开销相对较重 Concurrent 类型的容器 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 弱一致性 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 求大小弱一致性，size 操作未必是 100% 准确 读取弱一致性 遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历 2.8 ConcurrentHashMap练习：单词计数生成测试数据 1234567891011121314151617181920212223static final String ALPHA = &quot;abcedfghijklmnopqrstuvwxyz&quot;;public static void main(String[] args) &#123; int length = ALPHA.length(); int count = 200; List&lt;String&gt; list = new ArrayList&lt;&gt;(length * count); for (int i = 0; i &lt; length; i++) &#123; char ch = ALPHA.charAt(i); for (int j = 0; j &lt; count; j++) &#123; list.add(String.valueOf(ch)); &#125; &#125; Collections.shuffle(list); for (int i = 0; i &lt; 26; i++) &#123; try (PrintWriter out = new PrintWriter( new OutputStreamWriter( new FileOutputStream(&quot;tmp/&quot; + (i+1) + &quot;.txt&quot;)))) &#123; String collect = list.subList(i * count, (i + 1) * count).stream() .collect(Collectors.joining(&quot;\\n&quot;)); out.print(collect); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 模版代码，模版代码中封装了多线程读取文件的代码 1234567891011121314151617181920212223242526272829303132333435363738private static &lt;V&gt; void demo(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, BiConsumer&lt;Map&lt;String,V&gt;,List&lt;String&gt;&gt; consumer) &#123; Map&lt;String, V&gt; counterMap = supplier.get(); List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 26; i++) &#123; int idx = i; Thread thread = new Thread(() -&gt; &#123; List&lt;String&gt; words = readFromFile(idx); consumer.accept(counterMap, words); &#125;); ts.add(thread); &#125; ts.forEach(t-&gt;t.start()); ts.forEach(t-&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(counterMap);&#125;public static List&lt;String&gt; readFromFile(int i) &#123; ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;tmp/&quot; + i +&quot;.txt&quot;)))) &#123; while(true) &#123; String word = in.readLine(); if(word == null) &#123; break; &#125; words.add(word); &#125; return words; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 你要做的是实现两个参数 一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数 二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List 正确结果输出应该是每个单词出现 200 次 12&#123;a=200, b=200, c=200, d=200, e=200, f=200, g=200, h=200, i=200, j=200, k=200, l=200, m=200,n=200, o=200, p=200, q=200, r=200, s=200, t=200, u=200, v=200, w=200, x=200, y=200, z=200&#125; 下面的实现为： 12345678910111213demo( // 创建 map 集合 // 创建 ConcurrentHashMap 对不对？ () -&gt; new HashMap&lt;String, Integer&gt;(), // 进行计数 (map, words) -&gt; &#123; for (String word : words) &#123; Integer counter = map.get(word); int newValue = counter == null ? 1 : counter + 1; map.put(word, newValue); &#125; &#125;); 有没有问题？请改进 参考解答1 123456789demo( () -&gt; new ConcurrentHashMap&lt;String, LongAdder&gt;(), (map, words) -&gt; &#123; for (String word : words) &#123; // 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null map.computeIfAbsent(word, (key) -&gt; new LongAdder()).increment(); &#125; &#125;); 参考解答2 123456789demo( () -&gt; new ConcurrentHashMap&lt;String, Integer&gt;(), (map, words) -&gt; &#123; for (String word : words) &#123; // 函数式编程，无需原子变量 map.merge(word, 1, Integer::sum); &#125; &#125;); ConcurrentHashMap 原理JDK 7 HashMap 并发死链(1) 测试代码注意 要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了 以下测试代码是精心准备的，不要随便改动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args) &#123; // 测试 java 7 中哪些数字的 hash 结果相等 System.out.println(&quot;长度为16时，桶下标为1的key&quot;); for (int i = 0; i &lt; 64; i++) &#123; if (hash(i) % 16 == 1) &#123; System.out.println(i); &#125; &#125; System.out.println(&quot;长度为32时，桶下标为1的key&quot;); for (int i = 0; i &lt; 64; i++) &#123; if (hash(i) % 32 == 1) &#123; System.out.println(i); &#125; &#125; // 1, 35, 16, 50 当大小为16时，它们在一个桶内 final HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); // 放 12 个元素 map.put(2, null); map.put(3, null); map.put(4, null); map.put(5, null); map.put(6, null); map.put(7, null); map.put(8, null); map.put(9, null); map.put(10, null); map.put(16, null); map.put(35, null); map.put(1, null); System.out.println(&quot;扩容前大小[main]:&quot;+map.size()); new Thread() &#123; @Override public void run() &#123; // 放第 13 个元素, 发生扩容 map.put(50, null); System.out.println(&quot;扩容后大小[Thread-0]:&quot;+map.size()); &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; // 放第 13 个元素, 发生扩容 map.put(50, null); System.out.println(&quot;扩容后大小[Thread-1]:&quot;+map.size()); &#125; &#125;.start();&#125;final static int hash(Object k) &#123; int h = 0; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; (2) 死锁复现调试工具使用 idea 在 HashMap 源码 590 行加断点 1int newCapacity = newTable.length; 断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来 12345newTable.length==32 &amp;&amp; ( Thread.currentThread().getName().equals(&quot;Thread-0&quot;)|| Thread.currentThread().getName().equals(&quot;Thread-1&quot;)) 断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行 运行代码，程序在预料的断点位置停了下来，输出 123456789长度为16时，桶下标为1的key1163550长度为32时，桶下标为1的key135扩容前大小[main]:12 接下来进入扩容流程调试 在 HashMap 源码 594 行加断点 123Entry&lt;K,V&gt; next = e.next; // 593if (rehash) // 594 // ... 这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件Thread.currentThread().getName().equals(“Thread-0”)） 这时可以在 Variables 面板观察到 e 和 next 变量，使用 view as -&gt; Object 查看节点状态 12e (1)-&gt;(35)-&gt;(16)-&gt;nullnext (35)-&gt;(16)-&gt;null 在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成 12newTable[1] (35)-&gt;(1)-&gt;null扩容后大小:13 这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为 12e (1)-&gt;nullnext (35)-&gt;(1)-&gt;null 为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结果正确，但它结束后 Thread-0 还要继续运行 接下来就可以单步调试（F8）观察死链的产生了 下一轮循环到 594，将 e 搬迁到 newTable 链表头 123newTable[1] (1)-&gt;nulle (35)-&gt;(1)-&gt;nullnext (1)-&gt;null 下一轮循环到 594，将 e 搬迁到 newTable 链表头 123newTable[1] (35)-&gt;(1)-&gt;nulle (1)-&gt;nullnext null 再看看源码 1234567e.next = newTable[1];// 这时 e (1,35)// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象newTable[1] = e;// 再尝试将 e 作为链表头, 死链已成e = next;// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了 (3) 源码分析HashMap 的并发死链发生在扩容时 12345678910111213141516171819// 将 table 迁移至 newTablevoid transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; // 1 处 if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); // 2 处 // 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 假设 map 中初始元素是 1234567891011121314151617181920原始链表，格式：[下标] (key,next)[1] (1,35)-&gt;(35,16)-&gt;(16,null)线程 a 执行到 1 处 ，此时局部变量 e 为 (1,35)，而局部变量 next 为 (35,16) 线程 a 挂起线程 b 开始执行第一次循环[1] (1,null)第二次循环[1] (35,1)-&gt;(1,null)第三次循环[1] (35,1)-&gt;(1,null)[17] (16,null)切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (1,null)，而 next 的内容被改为 (35,1) 并链向 (1,null)第一次循环[1] (1,null)第二次循环，注意这时 e 是 (35,1) 并链向 (1,null) 所以 next 又是 (1,null)[1] (35,1)-&gt;(1,null)第三次循环，e 是 (1,null)，而 next 是 null，但 e 被放入链表头，这样 e.next 变成了 35 （2 处）[1] (1,35)-&gt;(35,1)-&gt;(1,35)已经是死链了 (4) 小结 究其原因，是因为在多线程环境下使用了非线程安全的 map 集合 JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据） JDK 8 ConcurrentHashMap(1) 重要属性和内部类12345678910111213141516171819// 默认为 0// 当初始化时, 为 -1// 当扩容时, 为 -(1 + 扩容线程数)// 当初始化或扩容完成后，为 下一次的扩容的阈值大小private transient volatile int sizeCtl;// 整个 ConcurrentHashMap 就是一个 Node[]static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;// hash 表transient volatile Node&lt;K,V&gt;[] table;// 扩容时的 新 hash 表private transient volatile Node&lt;K,V&gt;[] nextTable;// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Nodestatic final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 作为 treebin 的头节点, 存储 root 和 firststatic final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 作为 treebin 的节点, 存储 parent, left, rightstatic final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125; (2) 重要方法123456// 获取 Node[] 中第 i 个 Nodestatic final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) (3) 构造器分析可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建 1234567891011public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); // tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap;&#125; (4) get流程1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; // spread 方法能确保返回结果是正数 int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; // 如果头结点已经是要查找的 key if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; // hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找 else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; // 正常遍历链表, 用 equals 比较 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; (5) put流程以下数组简称（table），链表简称（bin） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public V put(K key, V value) &#123; return putVal(key, value, false);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); // 其中 spread 方法会综合高位低位, 具有更好的 hash 性 int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; // f 是链表头节点 // fh 是链表头结点的 hash // i 是链表在 table 中的下标 Node&lt;K,V&gt; f; int n, i, fh; // 要创建 table if (tab == null || (n = tab.length) == 0) // 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环 tab = initTable(); // 要创建链表头节点 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 添加链表头使用了 cas, 无需 synchronized if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; &#125; // 帮忙扩容 else if ((fh = f.hash) == MOVED) // 帮忙之后, 进入下一轮循环 tab = helpTransfer(tab, f); else &#123; V oldVal = null; // 锁住链表头节点 synchronized (f) &#123; // 再次确认链表头节点没有被移动 if (tabAt(tab, i) == f) &#123; // 链表 if (fh &gt;= 0) &#123; binCount = 1; // 遍历链表 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; // 找到相同的 key if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; // 更新 if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; // 已经是最后的节点了, 新增 Node, 追加至链表尾 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 红黑树 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; // putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; // 释放链表头节点的锁 &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) // 如果链表长度 &gt;= 树化阈值(8), 进行链表转为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; // 增加 size 计数 addCount(1L, binCount); return null;&#125;private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0) Thread.yield(); // 尝试将 sizeCtl 设置为 -1（表示初始化 table） else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; // 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建 try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125;// check 是之前 binCount 的个数private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; if ( // 已经有了 counterCells, 向 cell 累加 (as = counterCells) != null || // 还没有, 向 baseCount 累加 !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) ) &#123; CounterCell a; long v; int m; boolean uncontended = true; if ( // 还没有 counterCells as == null || (m = as.length - 1) &lt; 0 || // 还没有 cell (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || // cell cas 增加计数失败 !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)) ) &#123; // 创建累加单元数组和cell, 累加重试 fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; // 获取元素个数 s = sumCount(); &#125; if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; // newtable 已经创建了，帮忙扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; // 需要扩容，这时 newtable 未创建 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125;&#125; (6) size 计算流程size 计算实际发生在 put，remove 改变集合元素的操作之中 没有竞争发生，向 baseCount 累加计数 有竞争发生，新建 counterCells，向其中的一个 cell 累加计数 counterCells 初始有两个 cell 如果计数竞争比较激烈，会创建新的 cell 来累加计数 123456789101112131415161718public int size() &#123; long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);&#125;final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; // 将 baseCount 计数与所有 cell 计数累加 long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; Java 8 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin） 初始化，使用 cas 来保证并发安全，懒惰初始化 table 树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头 put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部 get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索 扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中 size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可 源码分析 http://www.importnew.com/28263.html 其它实现 Cliff Click’s high scale lib JDK 7 ConcurrentHashMap它维护了一个 segment 数组，每个 segment 对应一把锁 优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的 缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化 (1) 构造器分析1234567891011121314151617181920212223242526272829303132public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小 int sshift = 0; int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; // segmentShift 默认是 32 - 4 = 28 this.segmentShift = 32 - sshift; // segmentMask 默认是 15 即 0000 0000 0000 1111 this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // 创建 segments and segments[0] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss;&#125; 构造完成，如下图所示 可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好 其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment 例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位 (2) put流程1234567891011121314151617public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); // 计算出 segment 下标 int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // 获得 segment 对象, 判断是否为 null, 是则创建该 segment if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) &#123; // 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null, // 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性 s = ensureSegment(j); &#125; // 进入 segment 的put 流程 return s.put(key, hash, value, false);&#125; segment 继承了可重入锁（ReentrantLock），它的 put 方法为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 尝试加锁 HashEntry&lt;K,V&gt; node = tryLock() ? null : // 如果不成功, 进入 scanAndLockForPut 流程 // 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程 // 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来 scanAndLockForPut(key, hash, value); // 执行到这里 segment 已经被成功加锁, 可以安全执行 V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; // 更新 K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; // 新增 // 1) 之前等待锁时, node 已经被创建, next 指向链表头 if (node != null) node.setNext(first); else // 2) 创建新 node node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 3) 扩容 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else // 将 node 作为链表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; (3) rehash流程发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void rehash(HashEntry&lt;K,V&gt; node) &#123; HashEntry&lt;K,V&gt;[] oldTable = table; int oldCapacity = oldTable.length; int newCapacity = oldCapacity &lt;&lt; 1; threshold = (int)(newCapacity * loadFactor); HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1; for (int i = 0; i &lt; oldCapacity ; i++) &#123; HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) &#123; HashEntry&lt;K,V&gt; next = e.next; int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list newTable[idx] = e; else &#123; // Reuse consecutive sequence at same slot HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; // 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用 for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123; int k = last.hash &amp; sizeMask; if (k != lastIdx) &#123; lastIdx = k; lastRun = last; &#125; &#125; newTable[lastIdx] = lastRun; // 剩余节点需要新建 for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123; V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); &#125; &#125; &#125; &#125; // 扩容完成, 才加入新的节点 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; // 替换为新的 HashEntry table table = newTable;&#125; 附，调试代码 12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) &#123; ConcurrentHashMap&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; int hash = hash(i); int segmentIndex = (hash &gt;&gt;&gt; 28) &amp; 15; if (segmentIndex == 4 &amp;&amp; hash % 8 == 2) &#123; System.out.println(i + &quot;\\t&quot; + segmentIndex + &quot;\\t&quot; + hash % 2 + &quot;\\t&quot; + hash % 4 + &quot;\\t&quot; + hash % 8); &#125; &#125; map.put(1, &quot;value&quot;); map.put(15, &quot;value&quot;); // 2 扩容为 4 15 的 hash%8 与其他不同 map.put(169, &quot;value&quot;); map.put(197, &quot;value&quot;); // 4 扩容为 8 map.put(341, &quot;value&quot;); map.put(484, &quot;value&quot;); map.put(545, &quot;value&quot;); // 8 扩容为 16 map.put(912, &quot;value&quot;); map.put(941, &quot;value&quot;); System.out.println(&quot;ok&quot;);&#125;private static int hash(Object k) &#123; int h = 0; if ((0 != h) &amp;&amp; (k instanceof String)) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); int v = h ^ (h &gt;&gt;&gt; 16); return v;&#125; (4) get流程get 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新表取内容 12345678910111213141516171819public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); // u 为 segment 对象在数组中的偏移量 long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // s 即为 segment if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; (5) size 计算流程 计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回 如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回 12345678910111213141516171819202122232425262728293031323334353637383940public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn&#x27;t retry try &#123; for (;;) &#123; if (retries++ == RETRIES_BEFORE_LOCK) &#123; // 超过重试次数, 需要创建所有 segment 并加锁 for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 2.9 BlockingQueue基本的入队出队1234567891011121314public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; static class Node&lt;E&gt; &#123; E item; /*** 下列三种情况之一* - 真正的后继节点* - 自己, 发生在出队时* - null, 表示是没有后继节点, 是最后了*/ Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125; &#125;&#125; 初始化链表 last = head = new Node&lt;E&gt;(null); Dummy 节点用来占位，item 为 null 当一个节点入队 `last = last.next = node; 再来一个节点入队 last = last.next = node; 出队 123456Node&lt;E&gt; h = head;Node&lt;E&gt; first = h.next;h.next = h; // help GCE x = first.item;first.item = null;return x; h = head first = h.next h.next = h head = first 123E x = first.item;first.item = null;return x; 加锁分析==高明之处==在于用了两把锁和 dummy 节点 用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行 用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 消费者与消费者线程仍然串行 生产者与生产者线程仍然串行 线程安全分析 当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争 当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争 当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞 1234// 用于 put(阻塞) offer(非阻塞)private final ReentrantLock putLock = new ReentrantLock();// 用户 take(阻塞) poll(非阻塞)private final ReentrantLock takeLock = new ReentrantLock(); put 操作 12345678910111213141516171819202122232425262728public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; // count 用来维护元素计数 final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; // 满了等待 while (count.get() == capacity) &#123; // 倒过来读就好: 等待 notFull notFull.await(); &#125; // 有空位, 入队且计数加一 enqueue(node); c = count.getAndIncrement(); // 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程 if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; // 如果队列中有一个元素, 叫醒 take 线程 if (c == 0) // 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争 signalNotEmpty();&#125; take 操作 123456789101112131415161718192021222324public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; // 如果队列中只有一个空位时, 叫醒 put 线程 // 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity if (c == capacity) // 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争 signalNotFull(); return x;&#125; 由 put 唤醒 put 是为了避免信号不足 性能比较主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较 Linked 支持有界，Array 强制有界 Linked 实现是链表，Array 实现是数组 Linked 是懒惰的，而 Array 需要提前初始化 Node 数组 Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的 Linked 两把锁，Array 一把锁 2.10 ConcurrentLinkQueueConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争 只是这【锁】使用了 cas 来实现 事实上，ConcurrentLinkedQueue 应用还是非常广泛的 例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了 ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用 模仿 ConcurrentLinkedQueue初始代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package cn.itcast.concurrent.thirdpart.test;import java.util.Collection;import java.util.Iterator;import java.util.Queue;import java.util.concurrent.atomic.AtomicReference;public class Test3 &#123; public static void main(String[] args) &#123; MyQueue&lt;String&gt; queue = new MyQueue&lt;&gt;(); queue.offer(&quot;1&quot;); queue.offer(&quot;2&quot;); queue.offer(&quot;3&quot;); System.out.println(queue); &#125;&#125;class MyQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); for (Node&lt;E&gt; p = head; p != null; p = p.next.get()) &#123; E item = p.item; if (item != null) &#123; sb.append(item).append(&quot;-&gt;&quot;); &#125; &#125; sb.append(&quot;null&quot;); return sb.toString(); &#125; @Override public int size() &#123; return 0; &#125; @Override public boolean isEmpty() &#123; return false; &#125; @Override public boolean contains(Object o) &#123; return false; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return null; &#125; @Override public Object[] toArray() &#123; return new Object[0]; &#125; @Override public &lt;T&gt; T[] toArray(T[] a) &#123; return null; &#125; @Override public boolean add(E e) &#123; return false; &#125; @Override public boolean remove(Object o) &#123; return false; &#125; @Override public boolean containsAll(Collection&lt;?&gt; c) &#123; return false; &#125; @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return false; &#125; @Override public boolean removeAll(Collection&lt;?&gt; c) &#123; return false; &#125; @Override public boolean retainAll(Collection&lt;?&gt; c) &#123; return false; &#125; @Override public void clear() &#123; &#125; @Override public E remove() &#123; return null; &#125; @Override public E element() &#123; return null; &#125; @Override public E peek() &#123; return null; &#125; public MyQueue() &#123; head = last = new Node&lt;&gt;(null, null); &#125; private volatile Node&lt;E&gt; last; private volatile Node&lt;E&gt; head; private E dequeue() &#123; /*Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; head = first; E x = first.item; first.item = null; return x;*/ return null; &#125; @Override public E poll() &#123; return null; &#125; @Override public boolean offer(E e) &#123; return true; &#125; static class Node&lt;E&gt; &#123; volatile E item; public Node(E item, Node&lt;E&gt; next) &#123; this.item = item; this.next = new AtomicReference&lt;&gt;(next); &#125; AtomicReference&lt;Node&lt;E&gt;&gt; next; &#125;&#125; offer 1234567891011121314public boolean offer(E e) &#123; Node&lt;E&gt; n = new Node&lt;&gt;(e, null); while(true) &#123; // 获取尾节点 AtomicReference&lt;Node&lt;E&gt;&gt; next = last.next; // S1: 真正尾节点的 next 是 null, cas 从 null 到新节点 if(next.compareAndSet(null, n)) &#123; // 这时的 last 已经是倒数第二, next 不为空了, 其它线程的 cas 肯定失败 // S2: 更新 last 为倒数第一的节点 last = n; return true; &#125; &#125;&#125; 2.11 CopyOnWriteArrayListCopyOnWriteArraySet 是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其它线程的并发读，读写分离。 以新增为例： 1234567891011121314public boolean add(E e) &#123; synchronized (lock) &#123; // 获取旧的数组 Object[] es = getArray(); int len = es.length; // 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程） es = Arrays.copyOf(es, len + 1); // 添加新元素 es[len] = e; // 替换旧的数组 setArray(es); return true; &#125;&#125; 这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized 其它读操作并未加锁，例如： get 弱一致性 时间点 操作 1 Thread-0 getArray() 2 Thread-1 getArray() 3 Thread-1 setArray(arrayCopy) 4 Thread-0 array[index] 不容易测试，但问题确实存在 迭代器弱一致性12345678910111213CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);Iterator&lt;Integer&gt; iter = list.iterator();new Thread(() -&gt; &#123; list.remove(0); System.out.println(list);&#125;).start();sleep1s();while (iter.hasNext()) &#123; System.out.println(iter.next());&#125; 不要觉得弱一致性就不好 数据库的 MVCC 都是弱一致性的表现 并发高和一致性是矛盾的，需要权衡","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"juc","slug":"juc","permalink":"http://fyupeng.github.io/tags/juc/"}],"author":"fyupeng"},{"title":"jvm内存机制","slug":"JVM内存机制","date":"2022-06-25T07:17:22.000Z","updated":"2022-06-25T07:22:52.101Z","comments":true,"path":"2022/06/25/JVM内存机制/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/JVM%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"typora-root-url: img一、引言1. 什么是JVM?定义：Java Virtual Machine -java 程序的运行环境（java二进制字节码的运行环境） 好处： 一次编程，到处运行 自动内存管理，垃圾回收功能 数组下标越界越查检查 多态 比较： jvm jre jdk 2. 学习JVM有什么用？ 面试 理解底层的实现原理 中高级程序员的必备技能 3. 常见的JVM 4. 学习路线 二、内存结构1. 程序计数器 定义：Program Counter Register 程序计数器（寄存器） 作用，是记住下一条jvm指令的执行地址 特点 是线程私有的 不会存在内存溢出 作用:1234567891011121314151617180: getstatic #20 // PrintStream out = System.out;3: astore_1 // --4: aload_1 // out.println(1);5: iconst_1 // --6: invokevirtual #26 // --9: aload_1 // out.println(2);10: iconst_2 // --11: invokevirtual #26 // --14: aload_1 // out.println(3);15: iconst_3 // --16: invokevirtual #26 // --19: aload_1 // out.println(4);20: iconst_4 // --21: invokevirtual #26 // --24: aload_1 // out.println(5);25: iconst_5 // --26: invokevirtual #26 // --29: return 2. 虚拟机栈 定义：java Virtual Machine Stacks （Java 虚拟机栈） 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题辨析 垃圾回收是否涉及栈内存？ 栈内存分配越大越好吗？【栈内存分配越大，线程数分配就越少】 方法内的局部量是否线程安全？ 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 栈内存溢出（StackOverFlow）: 栈帧过多导致栈内存溢出 栈帧过大导致栈内存溢出 线程运行诊断：案例1： cpu 占用过多定位 用top定位哪个进程对cpu的占用过高 ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） jstack 进程id 可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号 案例2：程序运行很长时间没有结果 3. 本地方法栈 4. 堆 定义：Heap 堆 通过 new 关键字，创建对象都会使用堆内存 特点 它是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 堆内存溢出：堆内存诊断： jps 工具 查看当前系统中有哪些 java 进程 jmap 工具 查看堆内存占用情况 jmap - heap 进程id jconsole 工具 图形界面的，多功能的监测工具，可以连续监测 案例 垃圾回收后，内存占用仍然很高 5. 方法区 定义：JVM规范-方法区定义 组成： 方法区内存溢出1.8 以前会导致永久代内存溢出 12* 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space* -XX:MaxPermSize=8m 1.8 之后会导致元空间内存溢出 12* 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace* -XX:MaxMetaspaceSize=8m 场景 spring mybatis 运行时常量池 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 String Table先看几道面试题： 123456789101112131415String s1 = &quot;a&quot;;String s2 = &quot;b&quot;;String s3 = &quot;a&quot; + &quot;b&quot;;String s4 = s1 + s2;String s5 = &quot;ab&quot;;String s6 = s4.intern();// 问System.out.println(s3 == s4);System.out.println(s3 == s5);System.out.println(s3 == s6);String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;);String x1 = &quot;cd&quot;;x2.intern();// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢System.out.println(x1 == x2); String Table 特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder （1.8） 字符串常量拼接的原理是编译期优化 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回 String Table 位置123456789101112131415161718192021222324252627package cn.itcast.jvm.t1.stringtable;import java.util.ArrayList;import java.util.List;/** * 演示 StringTable 位置 * 在jdk8下设置 -Xmx10m(对堆的调优参数) -XX:-UseGCOverheadLimit(使用GC垃圾回收上限，以避免过多花费说收集少量的堆) * 在jdk6下设置 -XX:MaxPermSize=10m(非堆区分配的内存的最大上限) */public class Demo1_6 &#123; public static void main(String[] args) throws InterruptedException &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; try &#123; for (int j = 0; j &lt; 260000; j++) &#123; list.add(String.valueOf(j).intern()); i++; &#125; &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(i); &#125; &#125;&#125; String Table 垃圾回收12345678910111213141516171819202122232425package cn.itcast.jvm.t1.stringtable;import java.util.ArrayList;import java.util.List;/** * 演示 StringTable 垃圾回收 * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc */public class Demo1_7 &#123; public static void main(String[] args) throws InterruptedException &#123; int i = 0; try &#123; for (int j = 0; j &lt; 100000; j++) &#123; // j=100, j=10000 String.valueOf(j).intern(); i++; &#125; &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(i); &#125; &#125;&#125; String Table 性能调优演示串池大小对性能的影响 123456789101112131415161718192021222324252627282930package cn.itcast.jvm.t1.stringtable;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;/** * 演示串池大小对性能的影响 * -Xms500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=1009 */public class Demo1_24 &#123; public static void main(String[] args) throws IOException &#123; try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;linux.words&quot;), &quot;utf-8&quot;))) &#123; String line = null; long start = System.nanoTime(); while (true) &#123; line = reader.readLine(); if (line == null) &#123; break; &#125; line.intern(); &#125; System.out.println(&quot;cost:&quot; + (System.nanoTime() - start) / 1000000); &#125; &#125;&#125; 演示 intern 减少内存占用 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast.jvm.t1.stringtable;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.List;/** * 演示 intern 减少内存占用 * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000 */public class Demo1_25 &#123; public static void main(String[] args) throws IOException &#123; List&lt;String&gt; address = new ArrayList&lt;&gt;(); System.in.read(); for (int i = 0; i &lt; 10; i++) &#123; try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;linux.words&quot;), &quot;utf-8&quot;))) &#123; String line = null; long start = System.nanoTime(); while (true) &#123; line = reader.readLine(); if(line == null) &#123; break; &#125; address.add(line.intern()); &#125; System.out.println(&quot;cost:&quot; +(System.nanoTime()-start)/1000000); &#125; &#125; System.in.read(); &#125;&#125; 调整 -XX:StringTableSize=桶个数 字符串重复可使用intern()方法入串池 6. 直接内存定义：Direct Memory 常见于 NIO 操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受 JVM 内存回收管理 演示 ByteBuffer 作用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.itcast.jvm.t1.direct;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * 演示 ByteBuffer 作用 */public class Demo1_9 &#123; static final String FROM = &quot;E:\\\\编程资料\\\\第三方教学视频\\\\youtube\\\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&quot;; static final String TO = &quot;E:\\\\a.mp4&quot;; static final int _1Mb = 1024 * 1024; public static void main(String[] args) &#123; io(); // io 用时：1535.586957 1766.963399 1359.240226 directBuffer(); // directBuffer 用时：479.295165 702.291454 562.56592 &#125; private static void directBuffer() &#123; long start = System.nanoTime(); try (FileChannel from = new FileInputStream(FROM).getChannel(); FileChannel to = new FileOutputStream(TO).getChannel(); ) &#123; ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb); while (true) &#123; int len = from.read(bb); if (len == -1) &#123; break; &#125; bb.flip(); to.write(bb); bb.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; long end = System.nanoTime(); System.out.println(&quot;directBuffer 用时：&quot; + (end - start) / 1000_000.0); &#125; private static void io() &#123; long start = System.nanoTime(); try (FileInputStream from = new FileInputStream(FROM); FileOutputStream to = new FileOutputStream(TO); ) &#123; byte[] buf = new byte[_1Mb]; while (true) &#123; int len = from.read(buf); if (len == -1) &#123; break; &#125; to.write(buf, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; long end = System.nanoTime(); System.out.println(&quot;io 用时：&quot; + (end - start) / 1000_000.0); &#125;&#125; 演示直接内存溢出 1234567891011121314151617181920212223242526272829package cn.itcast.jvm.t1.direct;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.List;/** * 演示直接内存溢出 */public class Demo1_10 &#123; static int _100Mb = 1024 * 1024 * 100; public static void main(String[] args) &#123; List&lt;ByteBuffer&gt; list = new ArrayList&lt;&gt;(); int i = 0; try &#123; while (true) &#123; ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb); list.add(byteBuffer); i++; &#125; &#125; finally &#123; System.out.println(i); &#125; // 方法区是jvm规范， jdk6 中对方法区的实现称为永久代 // jdk8 对方法区的实现称为元空间 &#125;&#125; 禁用显式回收对直接内存的影响 123456789101112131415161718192021222324package cn.itcast.jvm.t1.direct;import java.io.IOException;import java.nio.ByteBuffer;/** * 禁用显式回收对直接内存的影响 */public class Demo1_26 &#123; static int _1Gb = 1024 * 1024 * 1024; /* * -XX:+DisableExplicitGC 显式的 */ public static void main(String[] args) throws IOException &#123; ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb); System.out.println(&quot;分配完毕...&quot;); System.in.read(); System.out.println(&quot;开始释放...&quot;); byteBuffer = null; System.gc(); // 显式的垃圾回收，Full GC System.in.read(); &#125;&#125; 直接内存分配的底层原理：Unsafe 123456789101112131415161718192021222324252627282930313233343536 package cn.itcast.jvm.t1.direct;import sun.misc.Unsafe;import java.io.IOException;import java.lang.reflect.Field;/** * 直接内存分配的底层原理：Unsafe */public class Demo1_27 &#123; static int _1Gb = 1024 * 1024 * 1024; public static void main(String[] args) throws IOException &#123; Unsafe unsafe = getUnsafe(); // 分配内存 long base = unsafe.allocateMemory(_1Gb); unsafe.setMemory(base, _1Gb, (byte) 0); System.in.read(); // 释放内存 unsafe.freeMemory(base); System.in.read(); &#125; public static Unsafe getUnsafe() &#123; try &#123; Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); f.setAccessible(true); Unsafe unsafe = (Unsafe) f.get(null); return unsafe; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 分配和回收原理 使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存 三、垃圾回收1. 如何判断对象可以回收引用计数法 可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收 哪些对象可以作为 GC Root ? 四种引用 强引用 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收 软引用（SoftReference） 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象 可以配合引用队列来释放软引用自身 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.jvm.t2;import java.io.IOException;import java.lang.ref.SoftReference;import java.util.ArrayList;import java.util.List;/** * 演示软引用 * -Xmx20m -XX:+PrintGCDetails -verbose:gc */public class Demo2_3 &#123; private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) throws IOException &#123; /*List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; list.add(new byte[_4MB]); &#125; System.in.read();*/ soft(); &#125; public static void soft() &#123; // list --&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]); System.out.println(ref.get()); list.add(ref); System.out.println(list.size()); &#125; System.out.println(&quot;循环结束：&quot; + list.size()); for (SoftReference&lt;byte[]&gt; ref : list) &#123; System.out.println(ref.get()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.jvm.t2;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;import java.lang.ref.SoftReference;import java.util.ArrayList;import java.util.List;/** * 演示软引用, 配合引用队列 */public class Demo2_4 &#123; private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) &#123; List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); // 引用队列 ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去 SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue); System.out.println(ref.get()); list.add(ref); System.out.println(list.size()); &#125; // 从队列中获取无用的 软引用对象，并移除 Reference&lt;? extends byte[]&gt; poll = queue.poll(); while( poll != null) &#123; list.remove(poll); poll = queue.poll(); &#125; System.out.println(&quot;===========================&quot;); for (SoftReference&lt;byte[]&gt; reference : list) &#123; System.out.println(reference.get()); &#125; &#125;&#125; 弱引用（WeakReference） 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 可以配合引用队列来释放弱引用自身 12345678910111213141516171819202122232425262728293031package cn.itcast.jvm.t2;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;import java.lang.ref.SoftReference;import java.lang.ref.WeakReference;import java.util.ArrayList;import java.util.List;/** * 演示弱引用 * -Xmx20m -XX:+PrintGCDetails -verbose:gc */public class Demo2_5 &#123; private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) &#123; // list --&gt; WeakReference --&gt; byte[] List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]); list.add(ref); for (WeakReference&lt;byte[]&gt; w : list) &#123; System.out.print(w.get()+&quot; &quot;); &#125; System.out.println(); &#125; System.out.println(&quot;循环结束：&quot; + list.size()); &#125;&#125; 虚引用（PhantomReference） 必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存 终结器引用（FinalReference） 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象 2. 垃圾回收算法标记清除定义： Mark Sweep 速度较快 有内存碎片 标记整理定义：Mark Compact 速度慢 无内存碎片 复制定义：Copy 不会有内存碎片 需要占用双倍内存空间 3. 分代垃圾回收 对象首先分`配在伊甸园区域 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长 相关VM参数 堆初始大小 -Xms 堆最大大小 -Xmx 或 -XX:MaxHeapSize=size 新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC 4. 垃圾回收器 串行 单线程 堆内存较小，适合个人电脑 吞吐量优先 让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高 响应时间优先 多线程 堆内存较大，多核 cpu 尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5 串行-XX:+UseSerialGC = Serial + SerialOld 吞吐量优先-XX:+UseParallelGC ~ -XX:+UseParallelOldGC (开启一个，另一个也会开启) -XX:GCTimeRatio=ratio -XX:MaxGCPauseMillis=ms -XX:ParallelGCThreads=n 响应时间优先-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads -XX:CMSInitiatingOccupancyFraction=percent -XX:+CMSScavengeBeforeRemark GI定义：Garbage First 2004 论文发布 2009 JDK 6u14 体验 2012 JDK 7u4 官方支持 2017 JDK 9 默认 适用场景 同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms 超大堆内存，会将堆划分为多个大小相等的 Region 整体上是 标记+整理 算法，两个区域之间是 复制 算法 相关 JVM 参数 -XX:+UseG1GC -XX:G1HeapRegionSize=size -XX:MaxGCPauseMillis=time G1垃圾回收阶段 Young Collection 会STW Young Collection + CM 在 Young GC 时会进行 GC Root 的初始标记 老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定 Mixed Collection会对 E、S、O 进行全面垃圾回收 最终标记（Remark）会 STW 拷贝存活（Evacuation）会 STW-XX:MaxGCPauseMillis=ms Full GC SerialGC 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc ParallelGC 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc CMS 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足 G1 新生代内存不足 发生的垃圾收集 - minor gc 老年代内存不足 Young Collection 跨代引用新生代回收的跨代引用（老年代引用新生代）问题 Remarkpre-write barrier + satb_mark_queue JDK 8u20字符串去重 优点：节省大量内存 缺点：略微多占用了 cpu 时间，新生代回收时间略微增加-XX:+UseStringDeduplication 12String s1 = new String(&quot;hello&quot;); // char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;String s2 = new String(&quot;hello&quot;); // char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125; 将所有新分配的字符串放入一个队列 当新生代回收时，G1并发检查是否有字符串重复 如果它们值一样，让它们引用同一个 char[] 注意，与 String.intern() 不一样 String.intern() 关注的是字符串对象 而字符串去重关注的是 char[] 在 JVM 内部，使用了不同的字符串表 JDK 8u40 并发标记类卸载所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用 JDK 8060 回收巨型对象 一个对象大于 region 的一半时，称之为巨型对象 G1 不会对巨型对象进行拷贝 回收时被优先考虑 G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉 JDK9并发标记起始时间的调整 并发标记必须在堆空间占满前完成，否则退化为 FullGC JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent JDK 9 可以动态调整 -XX:InitiatingHeapOccupancyPercent 用来设置初始值 进行数据采样并动态调整 总会添加一个安全的空档空间 JDK 9 更高效的回收 250+增强 180+bug修复 https://docs.oracle.com/en/java/javase/12/gctuning 5. 垃圾回收调优预备知识 掌握 GC 相关的 VM 参数，会基本的空间调整 1java -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot; 掌握相关工具 明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则 调优领域 内存 锁竞争 cpu 占用 io 确定目标 【低延迟】还是【高吞吐量】，选择合适的回收器 CMS，G1，ZGC ParallelGC Zing 最快的GC答案是不发生 GC 查看 FullGC 前后的内存占用，考虑下面几个问题 数据是不是太多？ resultSet = statement.executeQuery(“select * from 大表 limit n”) 数据表示是否太臃肿？ 对象图 对象大小 16 Integer 24 int 4 是否存在内存泄漏？ static Map map = 软 弱 第三方缓存实现 新生代调优 新生代的特点 所有的 new 操作的内存分配非常廉价 TLAB thread-local allocation buffer 死亡对象的回收代价是零 大部分对象用过即死 Minor GC 的时间远远低于 Full GC 越大越好吗？ 1-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the younggeneration is too small, then a lot of minor garbage collections are performed. If the size is toolarge, then only full garbage collections are performed, which can take a long time to complete.Oracle recommends that you keep the size for the young generation greater than 25% and lessthan 50% of the overall heap size. 新生代能容纳所有【并发量 * (请求-响应)】的数据 幸存区大到能保留【当前活跃对象+需要晋升对象】 晋升阈值配置得当，让长时间存活对象尽快晋升 -XX:MaxTenuringThreshold=threshold -XX:+PrintTenuringDistribution 12345Desired survivor size 48286924 bytes, new threshold 10 (max 10)- age 1: 28992024 bytes, 28992024 total- age 2: 1366864 bytes, 30358888 total- age 3: 1425912 bytes, 31784800 total... 老年代调优以 CMS 为例 CMS 的老年代内存越大越好 先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代 观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3 -XX:CMSInitiatingOccupancyFraction=percent 案例 案例1 Full GC 和 Minor GC频繁 案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS） 案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7） 四、类加载与字节码技术1. 类文件结构魔数0~3 字节，表示它是否是【class】类型的文件0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 版本4~7 字节，表示类的版本 00 34（52） 表示是 Java 80000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 常量池 CONSTANT_Class 7 CONSTANT_Fieldref 9 CONSTANT_Methodref 10 CONSTANT_InterfaceMethodref 11 CONSTANT_String 8 CONSTANT_Integer 3 CONSTANT_Float 4 CONSTANT_Long 5 CONSTANT_Double 6 CONSTANT_NameAndType 12 CONSTANT_Utf8 1 CONSTANT_MethodHandle 15 CONSTANT_MethodType 16 CONSTANT_InvokeDynamic 89 字节，表示常量池长度，00 23 （35） 表示常量池有 #1#34项，注意 #0 项不计入，也没有值0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 090000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26项来获得这个方法的【所属类】和【方法名】0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 070000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 】0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 290000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65是【LineNumberTable】0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 6162 6c 65是【LocalVariableTable】0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 630000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 010000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 630000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 160000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 720000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 610000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 460000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 0000360 2e 6a 61 76 61 0c 00 07 00 08 0700 1d 0c 00 1e 第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 740000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 610000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 610000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 720000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 760000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 访问标识与继承信息21 表示该 class 是一个类，公共的0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 05 表示根据常量池中 #5 找到本类全限定名0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 06 表示根据常量池中 #6 找到父类全限定名0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 表示接口的数量，本类为 00000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 Flag Name Value Interpretation ACC_PUBLIC 0x0001 Declared public ; may be accessed from outside its package. ACC_FINAL 0x0010 Declared final ; no subclasses allowed. ACC_SUPER 0x0020 Treat superclass methods specially when invoked by the invokespecial instruction. ACC_INTERFACE 0x0200 Is an interface, not a class. ACC_ABSTRACT 0x0400 Declared abstract ; must not be instantiated. ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code. ACC_ANNOTATION 0x2000 Declared as an annotation type. ACC_ENUM 0x4000 Declared as an enum type. Field 信息表示成员变量数量，本类为 00000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 FieldType Type Interpretation B byte signed byte C char Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 D double double-precision floating-point value F float single-precision floating-point value I int integer J long long integer L ClassName ; reference an instance of class ClassName S short signed short Z boolean true or false [ reference one array dimension Method 信息表示方法数量，本类为 20000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成 红色代表访问修饰符（本类中是 public） 蓝色代表引用了常量池 #07 项作为方法名称 绿色代表引用了常量池 #08 项作为方法参数描述 黄色代表方法属性数量，本方法是 1 红色代表方法属性 00 09 表示引用了常量池 #09 项，发现是【Code】属性 00 00 00 2f 表示此属性的长度是 47 00 01 表示【操作数栈】最大深度 00 01 表示【局部变量表】最大槽（slot）数 2a b7 00 01 b1 是字节码指令 00 00 00 02 表示方法细节属性数量，本例是 2 00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性 00 00 00 06 表示此属性的总长度，本例是 6 00 01 表示【LineNumberTable】长度 00 00 表示【字节码】行号 00 04 表示【java 源码】行号 00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性 00 00 00 0c 表示此属性的总长度，本例是 12 00 01 表示【LocalVariableTable】长度 00 00 表示局部变量生命周期开始，相对于字节码的偏移量 00 05 表示局部变量覆盖的范围长度 00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】 00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是【Lcn/itcast/jvm/t5/HelloWorld;】 00 00 表示局部变量占有的槽位（slot）编号，本例是 0 红色代表访问修饰符（本类中是 public static） 蓝色代表引用了常量池 #14 项作为方法名称 绿色代表引用了常量池 #15 项作为方法参数描述 黄色代表方法属性数量，本方法是 2 红色代表方法属性（属性1） 00 09 表示引用了常量池 #09 项，发现是【Code】属性 00 00 00 37 表示此属性的长度是 55 00 02 表示【操作数栈】最大深度 00 01 表示【局部变量表】最大槽（slot）数 00 00 00 05 表示字节码长度，本例是 9 b2 00 02 12 03 b6 00 04 b1 是字节码指令 00 00 00 02 表示方法细节属性数量，本例是 2 00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性 00 00 00 0a 表示此属性的总长度，本例是 10 00 02 表示【LineNumberTable】长度 00 00 表示【字节码】行号 00 06 表示【java 源码】行号 00 08 表示【字节码】行号 00 07 表示【java 源码】行号 00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性 00 00 00 0c 表示此属性的总长度，本例是 12 00 01 表示【LocalVariableTable】长度 00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】 00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】 00 00 表示局部变量占有的槽位（slot）编号，本例是 0 红色代表方法属性（属性2） 00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性 00 00 00 05 表示此属性的总长度，本例是 5 01 参数数量 00 10 表示引用了常量池 #16 项，是【args】 00 00 访问修饰符 ​ 附加属性 00 01 表示附加属性数量 00 13 表示引用了常量池 #19 项，即【SourceFile】 00 00 00 02 表示此属性的长度 00 14 表示引用了常量池 #20 项，即【HelloWorld.java】 参考文献https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html 2. 字节码指令入门接着上一节，研究一下两组字节码指令，一个是public cn.itcast.jvm.t5.HelloWorld(); 构造方法的字节码指令 2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数 b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？ 00 01 引用常量池中 #1 项，即【 Method java/lang/Object.”“:()V 】 b1 表示返回 另一个是 public static void main(java.lang.String[]); 主方法的字节码指令 1b2 00 02 12 03 b6 00 04 b1 b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？ 00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】 12 =&gt; ldc 加载参数，哪个参数呢？ 03 引用常量池中 #3 项，即 【String hello world】 b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？ 00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】 b1 表示返回 请参考https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5 javap 工具自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445C:\\Users\\fyp01\\Desktop\\资料-解密JVM\\代码\\jvm\\jvm\\src\\cn\\itcast\\jvm\\t5&gt;javap -v HelloWorld.classClassfile /C:/Users/fyp01/Desktop/资料-解密JVM/代码/jvm/jvm/src/cn/itcast/jvm/t5/HelloWorld.class Last modified 2022-2-27; size 442 bytes MD5 checksum 103606e24ec918e862312533fda15bbc Compiled from &quot;HelloWorld.java&quot;public class cn.itcast.jvm.t5.HelloWorld minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // hello world #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // cn/itcast/jvm/t5/HelloWorld #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 HelloWorld.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 hello world #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 cn/itcast/jvm/t5/HelloWorld #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 6: 0 line 7: 8&#125;SourceFile: &quot;HelloWorld.java&quot; 图解方法执行流程(1) 原始 java 代码123456789101112package cn.itcast.jvm.t3.bytecode;/** * 演示 字节码指令 和 操作数栈、常量池的关系 */public class Demo3_1 &#123; public static void main(String[] args) &#123; int a = 10; int b = Short.MAX_VALUE + 1; int c = a + b; System.out.println(c); &#125;&#125; (2) 编译后的字节码文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576C:\\Users\\fyp01\\Desktop\\资料-解密JVM\\代码\\jvm\\jvm\\src\\cn\\itcast\\jvm\\t3\\bytecode&gt;javap -v Demo3_1.classClassfile /C:/Users/fyp01/Desktop/资料-解密JVM/代码/jvm/jvm/src/cn/itcast/jvm/t3/bytecode/Demo3_1.class Last modified 2022-2-27; size 458 bytes MD5 checksum 9a972eb3f4d5db211d370df006319849 Compiled from &quot;Demo3_1.java&quot;public class cn.itcast.jvm.t3.bytecode.Demo3_1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #7.#16 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #17 // java/lang/Short #3 = Integer 32768 #4 = Fieldref #18.#19 // java/lang/System.out:Ljava/io/PrintStream; #5 = Methodref #20.#21 // java/io/PrintStream.println:(I)V #6 = Class #22 // cn/itcast/jvm/t3/bytecode/Demo3_1 #7 = Class #23 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 main #13 = Utf8 ([Ljava/lang/String;)V #14 = Utf8 SourceFile #15 = Utf8 Demo3_1.java #16 = NameAndType #8:#9 // &quot;&lt;init&gt;&quot;:()V #17 = Utf8 java/lang/Short #18 = Class #24 // java/lang/System #19 = NameAndType #25:#26 // out:Ljava/io/PrintStream; #20 = Class #27 // java/io/PrintStream #21 = NameAndType #28:#29 // println:(I)V #22 = Utf8 cn/itcast/jvm/t3/bytecode/Demo3_1 #23 = Utf8 java/lang/Object #24 = Utf8 java/lang/System #25 = Utf8 out #26 = Utf8 Ljava/io/PrintStream; #27 = Utf8 java/io/PrintStream #28 = Utf8 println #29 = Utf8 (I)V&#123; public cn.itcast.jvm.t3.bytecode.Demo3_1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 5: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: bipush 10 2: istore_1 3: ldc #3 // int 32768 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 7: 0 line 8: 3 line 9: 6 line 10: 10 line 11: 17&#125;SourceFile: &quot;Demo3_1.java&quot; (3) 常量池载入运行时常量池 (4) 方法字节码载入方法区 (5) main 线程开始运行，分配栈帧内存（stack=2，locals=4） (6) 执行引擎开始执行字节码bipush 10 将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） ldc 将一个 int 压入操作数栈 ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节） 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池 istore_1将操作数栈顶数据弹出，存入局部变量表的 slot 1 ldc #3 从常量池加载 #3 数据到操作数栈 注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的 istore_2 iload_1 iload_2 iadd istore_3 getstatic #4 iload_3 invokevirtual #5 找到常量池 #5 项 定位到方法区 java/io/PrintStream.println:(I)V 方法 生成新的栈帧（分配 locals、stack等） 传递参数，执行新栈帧中的字节码 return 完成 main 方法调用，弹出 main 栈帧 程序结束 练习 - 分析 i++目的：从字节码角度分析 a++ 相关题目 源码： 123456789101112package cn.itcast.jvm.t3.bytecode;/** * 从字节码角度分析 a++ 相关题目 */public class Demo3_2 &#123; public static void main(String[] args) &#123; int a = 10; int b = a++ + ++a + a--; System.out.println(a); System.out.println(b); &#125;&#125; 字节码： 123456789101112131415161718192021222324252627282930313233343536public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: bipush 10 2: istore_1 3: iload_1 4: iinc 1, 1 7: iinc 1, 1 10: iload_1 11: iadd 12: iload_1 13: iinc 1, -1 16: iadd 17: istore_2 21: iload_1 22: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 25: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 28: iload_2 29: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 32: return LineNumberTable: line 8: 0 line 9: 3 line 10: 18 line 11: 25 line 12: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 args [Ljava/lang/String; 3 30 1 a I 18 15 2 b I 分析： 注意 iinc 指令是直接在局部变量 slot 上进行运算 a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc 条件判断指令 0x99 ifeq 判断是否 == 0 0x9a ifne 判断是否 != 0 0x9b iflt 判断是否 &lt; 0 0x9c ifge 判断是否 &gt;= 0 0x9d ifgt 判断是否 &gt; 0 0x9e ifle 判断是否 &lt;= 0 0x9f if_icmpeq 两个int是否 == 0xa0 if_icmpne 两个int是否 != 0xa1 if_icmplt 两个int是否 &lt; 0xa2 if_icmpge 两个int是否 &gt;= 0xa3 if_icmpgt 两个int是否 &gt; 0xa4 if_icmple 两个int是否 &lt;= 0xa5 if_acmpeq 两个引用是否 == 0xa6 if_acmpne 两个引用是否 != 0xc6 ifnull 判断是否 == null 0xc7 ifnonnull 判断是否 != null 几点说明： byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节 goto 用来进行跳转到指定行号的字节码 源码： 12345678910public class Demo3_3 &#123; public static void main(String[] args) &#123; int a = 0; if(a == 0) &#123; a = 10; &#125; else &#123; a = 20; &#125; &#125;&#125; 字节码： 123456789100: iconst_01: istore_12: iload_13: ifne 126: bipush 108: istore_19: goto 1512: bipush 2014: istore_115: return 思考 细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎么办？ 参考 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp 循环控制指令其实循环控制还是前面介绍的那些指令，例如 while 循环： 12345678public class Demo3_4 &#123; public static void main(String[] args) &#123; int a = 0; while (a &lt; 10) &#123; a++; &#125; &#125;&#125; 字节码是： 123456780: iconst_01: istore_12: iload_13: bipush 105: if_icmpge 148: iinc 1, 111: goto 214: return 再比如 do while 循环： 12345678public class Demo3_5 &#123; public static void main(String[] args) &#123; int a = 0; do &#123; a++; &#125; while (a &lt; 10); &#125;&#125; 字节码： 12345670: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return 最后再看看 for 循环： 123456public class Demo3_6 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; &#125; &#125;&#125; 字节码是： 123456780: iconst_01: istore_12: iload_13: bipush 105: if_icmpge 148: iinc 1, 111: goto 214: return 注意比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归 联系 - 判断结果请从字节码角度分析，下列代码运行的结果 1234567891011public class Demo3_6_1 &#123; public static void main(String[] args) &#123; int i = 0; int x = 0; while (i &lt; 10) &#123; x = x++; i++; &#125; S ystem.out.println(x); // 结果是 0 &#125;&#125; 构造方法(1) &lt;cinit&gt;()V123456789public class Demo3_8_1 &#123; static int i = 10; static &#123; i = 20; &#125; s tatic &#123; i = 30; &#125;&#125; 编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 &lt;cinit&gt;()V ： 12345670: bipush 102: putstatic #2 // Field i:I5: bipush 207: putstatic #2 // Field i:I10: bipush 3012: putstatic #2 // Field i:I15: return &lt;cinit&gt;()V 方法会在类加载的初始化阶段被调用 **练习**同学们可以自己调整一下 static 变量和静态代码块的位置，观察字节码的改动 (2) &lt;init&gt;()V12345678910111213141516171819202122232425262728package cn.itcast.jvm.t3.bytecode;public class Demo3_8_2 &#123; private String a = &quot;s1&quot;; &#123; b = 20; &#125; private int b = 10; &#123; a = &quot;s2&quot;; &#125; public Demo3_8_2(String a, int b) &#123; this.a = a; this.b = b; &#125; public static void main(String[] args) &#123; Demo3_8_2 d = new Demo3_8_2(&quot;s3&quot;, 30); System.out.println(d.a); System.out.println(d.b); &#125;&#125; 编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后 123456789101112131415161718192021222324252627282930313233public cn.itcast.jvm.t3.bytecode.Demo3_8_2(java.lang.String, int); descriptor: (Ljava/lang/String;I)V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: aload_0 1: invokespecial #1 // super.&lt;init&gt;()V 4: aload_0 5: ldc #2 // &lt;- &quot;s1&quot; 7: putfield #3 // -&gt; this.a 10: aload_0 11: bipush 20 // &lt;- 20 13: putfield #4 // -&gt; this.b 16: aload_0 17: bipush 10 // &lt;- 10 19: putfield #4 // -&gt; this.b 22: aload_0 23: ldc #5 // &lt;- &quot;s2&quot; 25: putfield #3 // -&gt; this.a 28: aload_0 // ------------------------------ 29: aload_1 // &lt;- slot 1(a) &quot;s3&quot; | 30: putfield #3 // -&gt; this.a | 33: aload_0 | 34: iload_2 // &lt;- slot 2(b) 30 | 35: putfield #4 // -&gt; this.b -------------------- 38: return LineNumberTable: ... LocalVariableTable: Start Length Slot Name Signature 0 39 0 this Lcn/itcast/jvm/t3/bytecode/Demo3_8_2; 0 39 1 a Ljava/lang/String; 0 39 2 b I MethodParameters: ... 方法调用看一下几种不同的方法调用对应的字节码指令 1234567891011121314151617181920212223242526272829package cn.itcast.jvm.t3.bytecode;public class Demo3_9 &#123; public Demo3_9() &#123; &#125; private void test1() &#123; &#125; private final void test2() &#123; &#125; public void test3() &#123; &#125; public static void test4() &#123; &#125; @Override public String toString() &#123; return super.toString(); &#125; public static void main(String[] args) &#123; Demo3_9 d = new Demo3_9(); d.test1(); d.test2(); d.test3(); d.test4(); Demo3_9.test4(); d.toString(); &#125;&#125; 字节码： 1234567891011121314151617180: new #3 // class cn/itcast/jvm/t3/bytecode/Demo3_93: dup4: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V7: astore_18: aload_19: invokespecial #5 // Method test1:()V12: aload_113: invokespecial #6 // Method test2:()V16: aload_117: invokevirtual #7 // Method test3:()V20: aload_121: pop22: invokestatic #8 // Method test4:()V25: invokestatic #8 // Method test4:()V28: aload_129: invokevirtual #9 // Method toString:()Ljava/lang/String;32: pop33: return new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈 dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 ““:()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量 最终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了 还有一个执行 invokespecial 的情况是通过 super 调用父类方法 多态的原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.jvm.t3.bytecode;import java.io.IOException;/** * 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩 * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers */public class Demo3_10 &#123; public static void test(Animal animal) &#123; animal.eat(); System.out.println(animal.toString()); &#125; public static void main(String[] args) throws IOException &#123; test(new Cat()); test(new Dog()); System.in.read(); &#125;&#125;abstract class Animal &#123; public abstract void eat(); @Override public String toString() &#123; return &quot;我是&quot; + this.getClass().getSimpleName(); &#125;&#125;class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;啃骨头&quot;); &#125;&#125;class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125;&#125; 1）运行代码停在 System.in.read() 方法上，这时运行 jps 获取进程 id 2）运行 HSDB 工具进入 JDK 安装目录，执行 1java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB 进入图形界面 attach 进程 id 3） 查找某个对象打开 Tools -&gt; Find Object By Query 输入 select d from cn.itcast.jvm.t3.bytecode.Dog d 点击 Execute 执行 4）查看对象内存结构点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是MarkWord，后 8 字节就是对象的 Class 指针 但目前看不到它的实际地址 5) 查看对象 Class 的内存地址可以通过 Windows -&gt; Console 进入命令行模式，执行 1mem 0x00000001299b4978 2 mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）结果中第二行 0x000000001b7d4028 即为 Class 的内存地址 6）查看类的 vtable 方法1：Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面 方法2：或者 Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果 无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态相关的，final，static 不会列入）那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到： 12340x000000001b7d40281b8 +---------------------0x000000001b7d41e0 通过 Windows -&gt; Console 进入命令行模式，执行 1234567mem 0x000000001b7d41e0 60x000000001b7d41e0: 0x000000001b3d1b100x000000001b7d41e8: 0x000000001b3d15e80x000000001b7d41f0: 0x000000001b7d35e80x000000001b7d41f8: 0x000000001b3d15400x000000001b7d4200: 0x000000001b3d16780x000000001b7d4208: 0x000000001b7d3fa8 就得到了 6 个虚方法的入口地址 7）验证方法地址通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知 123456Dog - public void eat() @0x000000001b7d3fa8Animal - public java.lang.String toString() @0x000000001b7d35e8;Object - protected void finalize() @0x000000001b3d1b10;Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;Object - public native int hashCode() @0x000000001b3d1540;Object - protected native java.lang.Object clone() @0x000000001b3d1678; 对号入座，发现 8）小结当执行 invokevirtual 指令时， 先通过栈帧中的对象引用找到对象 分析对象头，找到对象的实际 Class Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了 查表得到方法的具体地址 执行方法的字节码 异常处理1) try-catch12345678910111213package cn.itcast.jvm.t3.bytecode;public class Demo3_11_1 &#123; public static void main(String[] args) &#123; int i = 0; try &#123; i = 10; &#125; catch (Exception e) &#123; i = 20; &#125; &#125;&#125; 注意为了抓住重点，下面的字节码省略了不重要的部分 12345678910111213141516171819202122232425 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: goto 12 8: astore_2 9: bipush 20 11: istore_1 12: return Exception table: from to target type 2 5 8 Class java/lang/Exception LocalVariableTable: Start Length Slot Name Signature 9 3 2 e Ljava/lang/Exception; 0 13 0 args [Ljava/lang/String; 2 11 1 i I StackMapTable: .... MethodParameters: ....&#125; 可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号 8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置 2) 多个 single-catch 块的情况1234567891011121314151617package cn.itcast.jvm.t3.bytecode;public class Demo3_11_2 &#123; public static void main(String[] args) &#123; int i = 0; try &#123; i = 10; &#125; catch (ArithmeticException e) &#123; i = 30; &#125; catch (NullPointerException e) &#123; i = 40; &#125; catch (Exception e) &#123; i = 50; &#125; &#125;&#125; 部分字节码如下： 123456789101112131415161718192021222324252627282930313233343536 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: goto 26 8: astore_2 9: bipush 30 11: istore_1 12: goto 26 15: astore_2 16: bipush 40 18: istore_1 19: goto 26 22: astore_2 23: bipush 50 25: istore_1 26: return Exception table: from to target type 2 5 8 Class java/lang/ArithmeticException 2 5 15 Class java/lang/NullPointerException 2 5 22 Class java/lang/Exception LocalVariableTable: Start Length Slot Name Signature 9 3 2 e Ljava/lang/ArithmeticException; 16 3 2 e Ljava/lang/NullPointerException; 23 3 2 e Ljava/lang/Exception; 0 27 0 args [Ljava/lang/String; 2 25 1 i I StackMapTable: ....&#125; 因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用 3) multi-catch 的情况1234567891011121314151617181920package cn.itcast.jvm.t3.bytecode;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Demo3_11_3 &#123; public static void main(String[] args) &#123; try &#123; Method test = Demo3_11_3.class.getMethod(&quot;test&quot;); test.invoke(null); &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; public static void test() &#123; System.out.println(&quot;ok&quot;); &#125;&#125; 部分字节码如下： 12345678910111213141516171819202122232425262728293031323334public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: ldc #2 // class cn/itcast/jvm/t3/bytecode/Demo3_11_3 2: ldc #3 // String test 4: iconst_0 5: anewarray #4 // class java/lang/Class 8: invokevirtual #5 // Method java/lang/Class.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method; 11: astore_1 12: aload_1 13: aconst_null 14: iconst_0 15: anewarray #6 // class java/lang/Object 18: invokevirtual #7 // Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; 21: pop 22: goto 30 25: astore_1 26: aload_1 27: invokevirtual #11 // Method java/lang/ReflectiveOperationException.printStackTrace:()V 30: return Exception table: from to target type 0 22 25 Class java/lang/NoSuchMethodException 0 22 25 Class java/lang/IllegalAccessException 0 22 25 Class java/lang/reflect/InvocationTargetException LocalVariableTable: Start Length Slot Name Signature 12 10 1 test Ljava/lang/reflect/Method; 26 4 1 e Ljava/lang/ReflectiveOperationException; 0 31 0 args [Ljava/lang/String; StackMapTable: ....&#125; 4) finally123456789101112131415package cn.itcast.jvm.t3.bytecode;public class Demo3_11_4 &#123; public static void main(String[] args) &#123; int i = 0; try &#123; i = 10; &#125; catch (Exception e) &#123; i = 20; &#125; finally &#123; i = 30; &#125; &#125;&#125; 部分字节码如下： 123456789101112131415161718192021222324252627282930313233343536public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=4, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: bipush 30 7: istore_1 8: goto 27 11: astore_2 12: bipush 20 14: istore_1 15: bipush 30 17: istore_1 18: goto 27 21: astore_3 22: bipush 30 24: istore_1 25: aload_3 26: athrow 27: return Exception table: from to target type 2 5 11 Class java/lang/Exception 2 5 21 any 11 15 21 any LocalVariableTable: Start Length Slot Name Signature 12 3 2 e Ljava/lang/Exception; 0 28 0 args [Ljava/lang/String; 2 26 1 i I StackMapTable: ....&#125; 可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程 练习 - finally 面试题1) finally 出现了 return先问问自己，下面的题目输出什么？ 12345678910111213141516package cn.itcast.jvm.t3.bytecode;public class Demo3_12_1 &#123; public static void main(String[] args) &#123; int result = test(); System.out.println(result); &#125; public static int test() &#123; try &#123; return 10; &#125; finally &#123; return 20; &#125; &#125;&#125; 部分字节码如下： 1234567891011121314151617public static int test(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=2, args_size=0 0: bipush 10 2: istore_0 3: bipush 20 5: ireturn 6: astore_1 7: bipush 20 9: ireturn Exception table: from to target type 0 3 6 any StackMapTable: ....&#125; 由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子 跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常，可以试一下下面的代码 1234567891011121314151617package cn.itcast.jvm.t3.bytecode;public class Demo3_12_1 &#123; public static void main(String[] args) &#123; int result = test(); System.out.println(result); &#125; public static int test() &#123; try &#123; int i = 1/0; return 10; &#125; finally &#123; return 20; &#125; &#125;&#125; 部分字节码如下： 123456789101112131415161718192021222324public static int test(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=0 0: iconst_1 1: iconst_0 2: idiv 3: istore_0 4: bipush 10 6: istore_1 7: bipush 20 9: ireturn 10: astore_2 11: bipush 20 13: ireturn Exception table: from to target type 0 7 10 any LocalVariableTable: Start Length Slot Name Signature 4 6 0 i I StackMapTable: ....&#125; 2) finally 对返回值影响同样问问自己，下面的题目输出什么？ 1234567891011121314151617package cn.itcast.jvm.t3.bytecode;public class Demo3_12_2 &#123; public static void main(String[] args) &#123; int result = test(); System.out.println(result); &#125; public static int test() &#123; int i = 10; try &#123; return i; &#125; finally &#123; i = 20; &#125; &#125;&#125; 部分字节码如下： 1234567891011121314151617181920212223242526 public static int test(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=0 0: bipush 10 2: istore_0 3: iload_0 4: istore_1 // 暂存 10 到本地变量表 slot(1) 中，目的为了固定返回值 5: bipush 20 7: istore_0 8: iload_1 // 加载 10，因为有变量需要载入，常量就不需要载入 9: ireturn // 抛出 10 10: astore_2 11: bipush 20 13: istore_0 14: aload_2 15: athrow Exception table: from to target type 3 5 10 any LocalVariableTable: Start Length Slot Name Signature 3 13 0 i I StackMapTable: ....&#125; synchronized1234567891011package cn.itcast.jvm.t3.bytecode;public class Demo3_13 &#123; public static void main(String[] args) &#123; Object lock = new Object(); synchronized (lock) &#123; System.out.println(&quot;ok&quot;); &#125; &#125;&#125; 部分字节码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: new #2 // class java/lang/Object 3: dup 4: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: dup 10: astore_2 11: monitorenter 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: ldc #4 // String ok 17: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: aload_2 21: monitorexit 22: goto 30 25: astore_3 26: aload_2 27: monitorexit 28: aload_3 29: athrow 30: return Exception table: from to target type 12 22 25 any 25 28 25 any LocalVariableTable: Start Length Slot Name Signature 0 31 0 args [Ljava/lang/String; 8 23 1 lock Ljava/lang/Object; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 25 locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4&#125; 注意 方法级别的 synchronized 不会在字节码指令中有所体现 3. 编译器处理所谓的 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。 1) 默认构造器12public class Candy1 &#123;&#125; 编译成class后的代码： 1234567public class Candy1 &#123; // 这个无参构造是编译器帮助我们加上的 public Candy1() &#123; super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;&lt;init&gt;&quot;:()V &#125;&#125; 2) 自动拆装箱这个特性是 JDK 5 开始加入的， 代码片段1 ： 12345678package cn.itcast.jvm.t3.candy;public class Candy2 &#123; public static void main(String[] args) &#123; Integer x = 1; int y = x; &#125;&#125; 这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 : 123456public class Candy2 &#123; public static void main(String[] args) &#123; Integer x = Integer.valueOf(1); int y = x.intValue(); &#125;&#125; 显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在JDK 5 之后都由编译阶段完成。即代码片段1都会在编译阶段被转换为 代码片段2 3) 泛型集合取值泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理： 1234567public class Candy3 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); // 实际调用的是 List.add(Object e) Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index); &#125;&#125; 所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作： 12// 需要将 Object 转为 IntegerInteger x = (Integer)list.get(0); 如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是： 12// 需要将 Object 转为 Integer, 并执行拆箱操作int x = ((Integer)list.get(0)).intValue() 还好这些麻烦事都不用自己做。 擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息 12345678910111213141516171819202122232425262728293031public static void main(java.lang.String[]) throws java.lang.Exception; descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: bipush 10 11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z 19: pop 20: aload_1 21: iconst_0 22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; 27: checkcast #7 // class java/lang/Integer 30: astore_2 31: return LocalVariableTable: Start Length Slot Name Signature 0 32 0 args [Ljava/lang/String; 8 24 1 list Ljava/util/List; 31 1 2 x Ljava/lang/Integer; LocalVariableTypeTable: Start Length Slot Name Signature 8 24 1 list Ljava/util/List&lt;Ljava/lang/Integer;&gt;; Exceptions: throws java.lang.Exception&#125; 使用反射，仍然能够获得这些信息： 12public Set&lt;Integer&gt; test(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map) &#123;&#125; 12345678910111213Method test = Candy3.class.getMethod(&quot;test&quot;, List.class, Map.class);Type[] types = test.getGenericParameterTypes();for (Type type : types) &#123; if (type instanceof ParameterizedType) &#123; ParameterizedType parameterizedType = (ParameterizedType) type; System.out.println(&quot;原始类型 - &quot; + parameterizedType.getRawType()); Type[] arguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i &lt; arguments.length; i++) &#123; System.out.printf(&quot;泛型参数[%d] - %s\\n&quot;, i, arguments[i]); &#125; &#125;&#125; ​ 输出 12345原始类型 - interface java.util.List泛型参数[0] -class java.lang.String原始类型 - interface java.util.Map泛型参数[0] - class java.lang.Integer泛型参数[1] - class java.lang.Object 4) 可变参数可变参数也是 JDK 5 开始加入的新特性： 例如： 1234567891011package cn.itcast.jvm.t3.candy;public class Candy4 &#123; public static void foo(String... args) &#123; String[] array = args; // 直接赋值 System.out.println(array); &#125; public static void main(String[] args) &#123; foo(&quot;hello&quot;, &quot;world&quot;); &#125;&#125; 可变参数 String... args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同样 java 编译器会在编译期间将上述代码变换为： 1234567891011package cn.itcast.jvm.t3.candy;public class Candy4 &#123; public static void foo(String[] args) &#123; String[] array = args; // 直接赋值 System.out.println(array); &#125; public static void main(String[] args) &#123; foo(&quot;hello&quot;, &quot;world&quot;); &#125;&#125; 注意 如果调用了 foo() 则等价代码为 foo(new String[]{}) ，创建了一个空的数组，而不会传递 null 进去 5) foreach 循环仍是 JDK 5 开始引入的语法糖，数组的循环： 12345678910package cn.itcast.jvm.t3.candy;public class Candy5_1 &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 2, 3, 4, 5&#125;; // 数组赋初值的简化写法也是语法糖哦 for (int e : array) &#123; System.out.println(e); &#125; &#125;&#125; 会被编译器抓换为： 123456789101112package cn.itcast.jvm.t3.candy;public class Candy5_1 &#123; public Candy5_1() &#123; &#125; public static void main(String[] args) &#123; int[] array = &#123;1, 2, 3, 4, 5&#125;; // 数组赋初值的简化写法也是语法糖哦 for (int i = 0; i &lt; array.length; ++i) &#123; int e = array[i]; System.out.println(e); &#125; &#125;&#125; 而集合的循环： 12345678910111213package cn.itcast.jvm.t3.candy;import java.util.Arrays;import java.util.List;public class Candy5_2 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); for (Integer i : list) &#123; System.out.println(i); &#125; &#125;&#125; 实际被编译器转换为对迭代器的调用： 123456789101112131415161718package cn.itcast.jvm.t3.candy;import java.util.Arrays;import java.util.List;public class Candy5_2 &#123; public Candy5_2() &#123; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); Iterator iter = list.iterator(); while(iter.hasNext()) &#123; Integer e = (Integer)iter.next(); System.out.println(e); &#125; &#125;&#125; 注意 foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器（ Iterator ） 6) switch 字符串从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如： 12345678910111213141516package cn.itcast.jvm.t3.candy;public class Candy6_1 &#123; public static void choose(String str) &#123; switch (str) &#123; case &quot;hello&quot;: &#123; System.out.println(&quot;h&quot;); break; &#125; case &quot;world&quot;: &#123; System.out.println(&quot;w&quot;); break; &#125; &#125; &#125;&#125; 注意 switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清楚 会被编译器转换为： 123456789101112131415161718192021222324public class Candy6_1 &#123; public Candy6_1() &#123; &#125; public static void choose(String str) &#123; byte x = -1; switch(str.hashCode()) &#123; case 99162322: // hello 的 hashCode if (str.equals(&quot;hello&quot;)) &#123; x = 0; &#125; b reak; case 113318802: // world 的 hashCode if (str.equals(&quot;world&quot;)) &#123; x = 1; &#125; &#125; switch(x) &#123; case 0: System.out.println(&quot;h&quot;); break; case 1: System.out.println(&quot;w&quot;); &#125; &#125;&#125; 可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应byte 类型，第二遍才是利用 byte 执行进行比较。 为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突，例如 BM 和 C. 这两个字符串的hashCode值都是2123 ，如果有如下代码： 12345678910111213141516package cn.itcast.jvm.t3.candy;public class Candy6_2 &#123; public static void choose(String str) &#123; switch (str) &#123; case &quot;BM&quot;: &#123; System.out.println(&quot;h&quot;); break; &#125; case &quot;C.&quot;: &#123; System.out.println(&quot;w&quot;); break; &#125; &#125; &#125;&#125; 会被编译器转换为： 12345678910111213141516171819202122public class Candy6_2 &#123; public Candy6_2() &#123; &#125; public static void choose(String str) &#123; byte x = -1; switch(str.hashCode()) &#123; case 2123: // hashCode 值可能相同，需要进一步用 equals 比较 if (str.equals(&quot;C.&quot;)) &#123; x = 1; &#125; else if (str.equals(&quot;BM&quot;)) &#123; x = 0; &#125; default: // 上一个没有 break; 这里会继续执行 switch(x) &#123; case 0: System.out.println(&quot;h&quot;); break; case 1: System.out.println(&quot;w&quot;); &#125; &#125; &#125;&#125; 7) switch 枚举switch 枚举的例子，原始代码： 123enum Sex &#123; MALE, FEMALE&#125; 12345678910public class Candy7 &#123; public static void foo(Sex sex) &#123; switch (sex) &#123; case MALE: System.out.println(&quot;男&quot;); break; case FEMALE: System.out.println(&quot;女&quot;); break; &#125; &#125;&#125; 转换后代码： 123456789101112131415161718192021222324252627public class Candy7 &#123; /** * 定义一个合成类（仅 jvm 使用，对我们不可见） * 用来映射枚举的 ordinal 与数组元素的关系 * 枚举的 ordinal 表示枚举对象的序号，从 0 开始 * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1 */ static class $MAP &#123; // 数组大小即为枚举元素个数，里面存储case用来对比的数字 static int[] map = new int[2]; static &#123; map[Sex.MALE.ordinal()] = 1; map[Sex.FEMALE.ordinal()] = 2; &#125; &#125; public static void foo(Sex sex) &#123; int x = $MAP.map[sex.ordinal()]; switch (x) &#123; case 1: System.out.println(&quot;男&quot;); break; case 2: System.out.println(&quot;女&quot;); break; &#125; &#125;&#125; 8) 枚举类JDK 7 新增了枚举类，以前面的性别枚举为例： 123enum Sex &#123; ALE, FEMALE&#125; 转换后代码： 12345678910111213141516171819public final class Sex extends Enum&lt;Sex&gt; &#123; public static final Sex MALE; public static final Sex FEMALE; private static final Sex[] $VALUES; static &#123; MALE = new Sex(&quot;MALE&quot;, 0); FEMALE = new Sex(&quot;FEMALE&quot;, 1); $VALUES = new Sex[]&#123;MALE, FEMALE&#125;; &#125; private Sex(String name, int ordinal) &#123; super(name, ordinal); &#125; public static Sex[] values() &#123; return $VALUES.clone(); &#125; public static Sex valueOf(String name) &#123; return Enum.valueOf(Sex.class, name); &#125;&#125; 9) try-with-resourcesDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources`： 12345try(资源变量 = 创建资源对象)&#123; &#125; catch( ) &#123; &#125; 其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如： 123456789public class Candy9 &#123; public static void main(String[] args) &#123; try(InputStream is = new FileInputStream(&quot;d:\\\\1.txt&quot;)) &#123; System.out.println(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 会被转换为： 1234567891011121314151617181920212223242526272829303132333435public class Candy9 &#123; public Candy9() &#123; &#125; public static void main(String[] args) &#123; try &#123; InputStream is = new FileInputStream(&quot;d:\\\\1.txt&quot;); Thread thread = null; try &#123; System.out.println(is); &#125; catch (Throwable e1) &#123; // t 是我们代码出现的异常 t = e1; throw e1; &#125; finally &#123; // 判断了资源不为空 if (is != null) &#123; // 如果我们代码有异常 if (t != null) &#123; try &#123; is.close(); &#125; catch (Throwable e2) &#123; // 如果 close 出现异常，作为被压制异常添加 t.addSuppressed(e2); &#125; &#125; else &#123; // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e is.close(); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）： 1234567891011121314public class Test6 &#123; public static void main(String[] args) &#123; try (MyResource resource = new MyResource()) &#123; int i = 1/0; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyResource implements AutoCloseable &#123; public void close() throws Exception &#123; throw new Exception(&quot;close 异常&quot;); &#125;&#125; 输出： 12345java.lang.ArithmeticException: / by zeroat test.Test6.main(Test6.java:7)Suppressed: java.lang.Exception: close 异常at test.MyResource.close(Test6.java:18)at test.Test6.main(Test6.java:6) 10) 方法重写时的桥接方法我们都知道，方法重写时对返回值分两种情况： 父子类的返回值完全一致 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子） 123456789101112class A &#123; public Number m() &#123; return 1; &#125;&#125; class B extends A &#123; @Override // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 public Integer m() &#123; return 2; &#125;&#125; 对于子类，java 编译器会做如下处理： 12345678910class B extends A &#123; public Integer m() &#123; return 2; &#125; // 此方法才是真正重写了父类 public Number m() 方法 public synthetic bridge Number m() &#123; // 调用 public Integer m() return m(); &#125;&#125; 其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证： 123for (Method m : B.class.getDeclaredMethods()) &#123; System.out.println(m);&#125; 会输出： 12public java.lang.Integer test.candy.B.m()public java.lang.Number test.candy.B.m() 11) 匿名内部类源代码： 12345678910public class Candy11 &#123; public static void main(String args) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;ok&quot;); &#125; &#125;; &#125;&#125; 转换后代码： 123456789// 额外生成的类final class Candy11$1 implements Runnable &#123; Candy11$1() &#123; &#125; public void run() &#123; System.ut.println(&quot;ok&quot;); &#125;&#125; 12345public class Candy11 &#123; public static void main(String[] args) &#123; Runnable runnable = new Candy11$1(); &#125;&#125; 引用局部变量的匿名内部类，源代码： 12345678910public class Candy11 &#123; public static void test(final int x) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;ok:&quot; + x); &#125; &#125; &#125;&#125; 转换后代码： 1234567891011// 额外生成的类final class Candy11$1 implements Runnable &#123; int val$x; Candy11$1(int x) &#123; this.val$x = x; &#125; // run 方法 重写后，是不能传参，故而通过构造器 public void run() &#123; System.out.println(&quot;ok:&quot; + this.val$x); &#125;&#125; 123456public class Candy11 &#123; // final : 为了 与 匿名类 Candy11$1 的成员变量保持一致 public static void test(final int x) &#123; Runnable runnable = new Candy11$1(x); &#125;&#125; 注意 这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val属 性， 所以 x 不应 该再发生变化了 ， 如果变化，那 么 x 属性没有机会再跟着一起变化 4. 类加载阶段1) 加载 将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有： _java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴露给 java 使用 _super 即父类 _fields 即成员变量 _methods 即方法 _constants 即常量池 _class_loader 即类加载器 _vtable 虚方法表 _itable 接口方法表 如果这个类还有父类没有加载，先加载父类 加载和链接可能是交替运行的 注意 instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror是存储在堆中 可以通过前面介绍的 HSDB 工具查看 2) 链接验证验证类是否符合 JVM规范，安全性检查用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行 12345678910111213141516C:\\Users\\fyp01\\Desktop\\资料-解密JVM\\代码\\jvm\\jvm\\src\\cn\\itcast\\jvm\\t5&gt;java HelloWorldError: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 3405691578 in class file HelloWorld at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) at java.net.URLClassLoader.access$100(URLClassLoader.java:73) at java.net.URLClassLoader$1.run(URLClassLoader.java:368) at java.net.URLClassLoader$1.run(URLClassLoader.java:362) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:361) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495) 准备为 static 变量分配空间，设置默认值 static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成 如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成 解析将常量池中的符号引用解析为直接引用 123456789101112131415161718192021222324package cn.itcast.jvm.t3.load;import java.io.IOException;/** * 解析的含义 */public class Load2 &#123; public static void main(String[] args) throws ClassNotFoundException, IOException &#123;// ClassLoader classloader = Load2.class.getClassLoader(); // loadClass 方法不会导致类的解析和初始化// Class&lt;?&gt; c = classloader.loadClass(&quot;cn.itcast.jvm.t3.load.C&quot;); new C(); System.in.read(); &#125;&#125;class C &#123; D d = new D();&#125;class D &#123;&#125; 3) 初始化&lt;cinit&gt;()V 方法初始化即调用 &lt;cinit&gt;()V ，虚拟机会保证这个类的『构造方法』的线程安全 发生的时机概括得说，类初始化是【懒惰的】 main 方法所在的类，总会被首先初始化 首次访问这个类的静态变量或静态方法时 子类初始化，如果父类还没初始化，会引发 子类访问父类的静态变量，只会触发父类的初始化 Class.forName new 会导致初始化 不会导致类初始化的情况 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化 类对象.class 不会触发初始化 创建该类的数组不会触发初始化 类加载器的loadClass 方法 Class.forName 的参数 2 为 false 时 1234567891011121314class A &#123; static int a = 0; static &#123; System.out.println(&quot;a init&quot;); &#125;&#125;class B extends A &#123; final static double b = 5.0; static boolean c = false; static &#123; System.out.println(&quot;b init&quot;); &#125;&#125; 验证（实验时请先全部注释，每次只执行其中一个） 1234567891011121314151617181920212223242526272829303132public class Load3 &#123; static &#123; System.out.println(&quot;main init&quot;); &#125; public static void main(String[] args) throws ClassNotFoundException, IOException &#123;// // 1. 静态常量不会触发初始化// System.out.println(B.b);// // 2. 类对象.class 不会触发初始化// System.out.println(B.class);// // 3. 创建该类的数组不会触发初始化// System.out.println(new B[0]); // 4. 不会初始化类 B，但会加载 B、A ClassLoader cl = Thread.currentThread().getContextClassLoader(); cl.loadClass(&quot;cn.itcast.jvm.t3.load.B&quot;);// // 5. 不会初始化类 B，但会加载 B、A// ClassLoader c2 = Thread.currentThread().getContextClassLoader();// Class.forName(&quot;cn.itcast.jvm.t3.load.B&quot;, false, c2); System.in.read();// // 1. 首次访问这个类的静态变量或静态方法时// System.out.println(A.a);// // 2. 子类初始化，如果父类还没初始化，会引发// System.out.println(B.c);// // 3. 子类访问父类静态变量，只触发父类初始化// System.out.println(B.a);// // 4. 会初始化类 B，并先初始化类 A// Class.forName(&quot;cn.itcast.jvm.t3.load.B&quot;); &#125;&#125; 4) 练习从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化 12345678910111213141516171819package cn.itcast.jvm.t3.load;public class Load4 &#123; public static void main(String[] args) &#123; System.out.println(E.a); System.out.println(E.b); System.out.println(E.c); &#125;&#125;class E &#123; public static final int a = 10; public static final String b = &quot;hello&quot;; public static final Integer c = 20; // Integer.valueOf(20) final 的 基本类型 + String 不会触发的，Integer 不是 static &#123; System.out.println(&quot;init E&quot;); &#125;&#125; 典型应用 - 完成懒惰初始化单例模式 12345678910111213141516171819202122class Singleton &#123; public static void test() &#123; System.out.println(&quot;test&quot;); &#125; private Singleton() &#123;&#125; private static class LazyHolder&#123; // final 可以保证 构造方法执行结束后，final 成员变量 被 其他线程访问 是 可见的 private static final Singleton SINGLETON = new Singleton(); // jvm 保证 类 初始化 在 多线程下 被 同步加锁，静态代码块 在初始化 阶段完成 static &#123; System.out.println(&quot;lazy holder init&quot;); &#125; &#125; public static Singleton getInstance() &#123; return LazyHolder.SINGLETON; &#125;&#125; 以上的实现特点是： 懒惰实例化 初始化时的线程安全是有保障的 5. 类加载器以 JDK 8 为例： 名称 加载哪的类 说明 Bootstrap ClassLoader JAVA_HOME/jre/lib 无法直接访问 Extension ClassLoader JAVA_HOME/jre/lib/ext 上级为 Bootstrap，显示为 null Application ClassLoader classpath 上级为 Extension 自定义类加载器 自定义 上级为 Application 1) 启动类加载器用 Bootstrap 类加载器加载类： 1234567package cn.itcast.jvm.t3.load;public class F &#123; static &#123; System.out.println(&quot;bootstrap F init&quot;); &#125;&#125; 执行 12345678package cn.itcast.jvm.t3.load;public class Load5_1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.F&quot;); System.out.println(aClass.getClassLoader()); // AppClassLoader ExtClassLoader &#125;&#125; 输出 123E:\\git\\jvm\\out\\production\\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5_1bootstrap F initnull -Xbootclasspath 表示设置 bootclasspath 其中 /a:. 表示将当前目录追加至 bootclasspath 之后 可以用这个办法替换核心类 java -Xbootclasspath:&lt;new bootclasspath&gt; java -Xbootclasspath/a:&lt;追加路径&gt; java -Xbootclasspath/p:&lt;追加路径&gt; 2) 扩展类加载器12345678package cn.itcast.jvm.t3.load;public class G &#123; static &#123;// System.out.println(&quot;ext G init&quot;); System.out.println(&quot;classpath G init&quot;); &#125;&#125; 执行 12345678910111213package cn.itcast.jvm.t3.load;/** * 演示 扩展类加载器 * 在 C:\\Program Files\\Java\\jdk1.8.0_91 下有一个 my.jar * 里面也有一个 G 的类，观察到底是哪个类被加载了 */public class Load5_2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.G&quot;); System.out.println(aClass.getClassLoader()); &#125;&#125; 输出 12classpath G initsun.misc.Launcher$AppClassLoader@18b4aac2 写一个同名的类 12345678package cn.itcast.jvm.t3.load;public class G &#123; static &#123; System.out.println(&quot;ext G init&quot;); //System.out.println(&quot;classpath G init&quot;); &#125;&#125; 打个 jar 包 123E:\\git\\jvm\\out\\production\\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class已添加清单正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%) 将 jar 包拷贝到 JAVA_HOME/jre/lib/ext重新执行 Load5_2输出 12ext G initsun.misc.Launcher$ExtClassLoader@29453f44 3) 双亲委派模式所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则 注意 这里的双亲，翻译为上级似乎更加合适，因为他们并没有继承关系 123456789101112131415161718192021222324252627282930313233 protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 1. 检查该类是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; // 2. 有上级的话，委派上级 loadClass c = parent.loadClass(name, false); &#125; else &#123; // 3. 如果没有上级了（ExtClassLoader），则委派 BootstrapClassLoader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; &#125; i f (c == null) &#123; long t1 = System.nanoTime(); // 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载 c = findClass(name); // 5. 记录耗时 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; i f (resolve) &#123; resolveClass(c); &#125; r eturn c; &#125;&#125; 例如： 123456789101112package cn.itcast.jvm.t3.load;import java.util.ServiceLoader;public class Load5_3 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; System.out.println(Load5_3.class.getClassLoader()); Class&lt;?&gt; aClass = Load5_3.class.getClassLoader().loadClass(&quot;cn.itcast.jvm.t3.load.H&quot;); System.out.println(aClass.getClassLoader()); &#125;&#125; 执行流程为： sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有 sun.misc.Launcher$AppClassLoader // 2 处，委派上级sun.misc.Launcher$ExtClassLoader.loadClass() sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有 sun.misc.Launcher$ExtClassLoader // 3 处，没有上级了，则委派 BootstrapClassLoader 查找 BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有 sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader的 // 2 处 继续执行到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在classpath 下查找，找到了 总之就是，先查找自己已加载的类，没有则委派上级查找已加载的类，递归去查找（套娃），没有再去各自类加载器的类路径查找未加载的类，有则把它加载，没有（解娃），让下级继续递归 4) 线程上下文类加载器我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？让我们追踪一下源码： 12345678910public class DriverManager &#123; // 注册驱动的集合 private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); // 初始化驱动 static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;); &#125;&#125; 先不看别的，看看 DriverManager 的类加载器： 1System.out.println(DriverManager.class.getClassLoader()); 打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？ 继续看 loadInitialDrivers() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(&quot;jdbc.drivers&quot;); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; // 1）使用 ServiceLoader 机制加载驱动，即 SPI AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers); // 2）使用 jdbc.drivers 定义的驱动名加载驱动 if (drivers == null || drivers.equals(&quot;&quot;)) &#123; return; &#125; String[] driversList = drivers.split(&quot;:&quot;); println(&quot;number of Drivers:&quot; + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(&quot;DriverManager.Initialize: loading &quot; + aDriver); // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(&quot;DriverManager.Initialize: load failed: &quot; + ex); &#125; &#125;&#125; 先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载 再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI） 约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名 这样就可以使用 12345ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);Iterator&lt;接口类型&gt; iter = allImpls.iterator();while(iter.hasNext()) &#123; iter.next();&#125; 来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想： JDBC Servlet 初始化器 Spring 容器 Dubbo（对 SPI 进行了扩展） 接着看 ServiceLoader.load 方法： 12345public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 获取线程上下文类加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl);&#125; 线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类LazyIterator 中： 123456789101112131415161718192021222324252627private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, &quot;Provider &quot; + cn + &quot; not found&quot;); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, &quot;Provider &quot; + cn + &quot; not a subtype&quot;); &#125; try &#123; S p = service.cast(c.newInstance()); providers.put(cn, p); return p; &#125; catch (Throwable x) &#123; fail(service, &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;, x); &#125; throw new Error(); // This cannot happen&#125; 5) 自定义类加载器问问自己，什么时候需要自定义类加载器 想加载非 classpath 随意路径中的类文件 都是通过接口来使用实现，希望解耦时，常用在框架设计 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器 步骤： 继承 ClassLoader 父类 要遵从双亲委派机制，重写 findClass 方法 注意不是重写 loadClass 方法，否则不会走双亲委派机制 读取类文件的字节码 调用父类的 defineClass 方法来加载类 使用者调用该类加载器的 loadClass 方法 示例： 在当前类的父目录下，创建TestCass类 NIO方式 1234567891011121314151617181920212223class MyClassLoader extends ClassLoader &#123; @Override // name 就是类名称 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = &quot;D:\\\\Users\\\\fyp01\\\\IdeaProjects\\\\jvm\\\\jvm\\\\src\\\\cn\\\\itcast\\\\jvm\\\\t3\\\\load\\\\&quot; + name + &quot;.class&quot;; try &#123; ByteArrayOutputStream os = new ByteArrayOutputStream(); Files.copy(Paths.get(path), os); // 得到字节数组 byte[] bytes = os.toByteArray(); // byte[] -&gt; *.class return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new ClassNotFoundException(&quot;类文件未找到&quot;, e); &#125; &#125;&#125; 传统IO方式 123456789101112131415161718192021222324252627282930public class MyClassLoder1 extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = &quot;D:\\\\Users\\\\fyp01\\\\IdeaProjects\\\\jvm\\\\jvm\\\\src\\\\cn\\\\itcast\\\\jvm\\\\t3\\\\load\\\\&quot; + name + &quot;.class&quot;; try &#123; FileInputStream in = new FileInputStream(new File(path)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len = -1; byte[] b = new byte[1024]; while ((len = in.read(b)) != -1) &#123; baos.write(b, 0, len); &#125; byte[] bytes = baos.toByteArray(); in.close(); baos.close(); return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) throws Exception &#123; MyClassLoder1 myClassLoder1 = new MyClassLoder1(); Class&lt;?&gt; demo = myClassLoder1.loadClass(&quot;com.itheima.Demo&quot;); Object o = demo.newInstance(); System.out.println(o); &#125;&#125; 6) 类加载器的命名空间概念： 每个类加载器都有各自的命名空间，命名空间由该加载器及所有父加载器所加载的类组成 在同一个命名空间中，不会出现全限定类名相同的两个Class对象 在不同的命名空间中，可以出现全限定类名相同的两个Class对象 父加载器加载的类对其子加载器可见，子加载器加载的类对其父加载器不可见 如果两个加载器之间没有直接或间接父子的关系，那么它们各自加载的类相互不可见 如何通过案例佐证？ 验证： 我们可以自定义一个类加载器MyClassLoader去继承ClassLoader，重写父类的 findClass方法 为什么要重写 findClass方法？ 首先我们是使用双亲委派的方式 来实现类加载，findClass方法 在 调用 ClassLoader的 loadClass方法后，会在该方法体 调用 findClass方法，findClass方法是 从 自身加载器所在的 类路径下 加载 class 文件 我们先 用 ClassLoader 去加载 我们自定义的 Student 类，然后再去用自定义的 类加载器去 加载 Studeng类： 1234567891011121314/** * @Auther: fyp * @Date: 2022/3/3 * @Description: * @Package: PACKAGE_NAME * @Version: 1.0 */public class Student&#123; private Student student; //setter方法的参数是Object类型 public void setStudent(Object object) &#123; this.student = (Student) object; &#125;&#125; Demo演示： 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @Auther: fyp * @Date: 2022/3/3 * @Description: * @Package: PACKAGE_NAME * @Version: 1.0 */public class Demo &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException, InvocationTargetException &#123; //通过线程获取线程上下文类加载器,默认是Application ClassLoader ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); /*第二种方式：使用 类.class.getClassLoader 获取 类加载器 ClassLoader classLoader = Demo.class.getClassLoader(); 第三种方式：使用 Class.forName(&quot;全限定类名&quot;) 来获取类加载器 Class&lt;?&gt; sclass = Class.forName(&quot;Student&quot;); ClassLoader classLoader = sclass.getClassLoader(); */ //使用类加载器加载两个Class对象 Class c1 = classLoader.loadClass(&quot;Student&quot;); Class c2 = classLoader.loadClass(&quot;Student&quot;); System.out.println(c1 == c2); //使用两个Class对象分别创建一个新的实例(不使用强行转换) Object o1 = c1.newInstance(); Object o2 = c2.newInstance(); //获取setStudent方法 Method m1 = c1.getMethod(&quot;setStudent&quot;,Object.class); //使用o1对象调用方法，o2对象作为参数传入 m1.invoke(o1,o2); System.out.println(o1); &#125;&#125; 输出： 12trueStudent@677327b6 c1 == c2 返回的结果是true，说明在堆内存中同一个类的Class对象有且仅有一个，第二条得以佐证 接下来通过自定义类加载器 来佐证第三条 自定义类加载器如下： 12345678910111213141516171819class MyClassLoader extends ClassLoader&#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = &quot;e:\\\\myclasspath\\\\&quot; + name + &quot;.class&quot;; try &#123; //创建byte数组输出流 ByteArrayOutputStream os = new ByteArrayOutputStream(); //把字节码文件复制到流中 Files.copy(Paths.get(path),os); //得到字节数组 byte[] bytes = os.toByteArray(); //调用父类的defineClass方法加载类 return defineClass(name,bytes,0,bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ClassNotFoundException(&quot;找不到类文件&quot;); &#125; &#125;&#125; 注意： 之前加载的 Student类的 class字节码文件 是 关联了 Student的 java类动态生成的，上面的 path路径下对应的 字节码文件暂时不管 Demo1演示： 1234567891011121314151617181920212223242526272829import java.io.ByteArrayOutputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;/** * @Auther: fyp * @Date: 2022/3/3 * @Description: * @Package: PACKAGE_NAME * @Version: 1.0 */public class Demo1 &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException, InvocationTargetException &#123; //创建两个自定义类加载器的对线下 MyClassLoader c1 = new MyClassLoader(); MyClassLoader c2 = new MyClassLoader(); //分别使用两个类加载器加载Student类 Class s1 = c1.loadClass(&quot;Student&quot;); Class s2 = c2.loadClass(&quot;Student&quot;); System.out.println(s1 == s2); Object o1 = s1.newInstance(); Object o2 = s2.newInstance(); Method m1 = s1.getMethod(&quot;setStudent&quot;, Object.class); m1.invoke(o1,o2); System.out.println(o1); &#125;&#125; 输出： 12trueStudent@14ae5a5 我们结合双亲委派来看两个Demo的输出，结果都为true 现在我想最大的疑问就是，为什么我把 类加载器 加载的 字节码 路径 转移到 e:\\\\myclasspath\\\\路径下，而且该路径没有 Student的字节码文件，为什么还可以 加载？ 那是因为我们是通过 ClassLoader的双亲委派 来加载的 类加载器，它 加载的类有 一个机制，加载的优先顺序如下： 自定义类加载器 &lt; 应用类加载器 &lt; 拓展类加载器 &lt; 启动类加载器 它会先去上级 加载 Student的 字节码文件，即从 启动类加载器 依次到 自定义类加载器，我们第一次执行程序时，就动态生成了Student字节码，我们 不妨 删除 之前的字节码文件 输出： 12345Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: 找不到类文件 at MyClassLoader.findClass(Demo1.java:47) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at Demo1.main(Demo1.java:20) 说明 我们 是去 加载了 之前的字节码文件，我们把之前的字节码文件 Student.class放到 e:\\\\myclasspath\\\\目录中去，再次执行 输出： 123456falseException in thread &quot;main&quot; java.lang.reflect.InvocationTargetException...Caused by: java.lang.ClassCastException: Student cannot be cast to Student at Student.setStudent(Student.java:13) ... 5 more false说明了 这两个类对象 是不同的 Student cannot be cast to Student 因为我们使用的是 两个 自定义的类加载器，而且两个 类加载后 不在 同一个 命名空间，为什么不在同一个命名空间，根据双亲委派的机制，只有上级的类加载器对下级的类加载器可见，所以之前的自定义类加载器 对 应用类加载器已加载的Student.class可见，后来删了该字节码文件，应用类加载器就不会去加载了，所以两个类相对来说是 不可见的，是两个不同的命名空间，而且两个命名空间可以存在相同全限定类名的对象，佐证了第3、4和5点。 7) 即时编译分层编译（TieredCompilation）先来个例子 12345678910111213141516package cn.itcast.jvm.t3.jit;public class JIT1 &#123; // -XX:+PrintCompilation 指打印编译信息 -XX:-DoEscapeAnalysis 第二个指 关闭 C2 编译器的优化阶段 public static void main(String[] args) &#123; for (int i = 0; i &lt; 200; i++) &#123; long start = System.nanoTime(); for (int j = 0; j &lt; 1000; j++) &#123; new Object(); &#125; long end = System.nanoTime(); System.out.printf(&quot;%d\\t%d\\n&quot;,i,(end - start)); &#125; &#125;&#125; 输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992000 2472001 932002 1129003 824004 861995 882006 929997 851998 902009 17720010 9260111 21130012 22860013 18560014 16299915 14719916 12239917 9179918 8559919 8899920 21140021 19890022 9030023 8850024 25150025 18580126 8379927 9370028 9630029 27550130 21320031 18320032 9140033 9330134 13540135 8990036 8960037 9689938 9040039 9650140 12710041 15019942 9120043 8760044 8450045 9080146 8960047 9170048 8430049 7830050 9160051 8720052 8720053 8230054 8619955 8620056 8660057 8820158 9160159 8800060 11540061 8990162 8400063 8270064 10940165 8730066 7400067 3449968 3850069 3790070 3030071 3070072 3040073 2789974 2750175 2789976 3000177 5710078 3230079 2980080 2580081 3029982 3099983 3800184 2680085 2790086 3290187 2990088 2550089 3209990 3930091 3580092 2650093 3060194 3740095 3160096 5960097 3410198 3119999 31300100 31399101 31399102 90401103 32400104 33100105 31400106 30900107 29001108 31900109 34600110 37401111 27201112 32000113 30500114 31400115 27501116 32300117 31200118 36399119 26001120 30900121 31000122 34701123 30700124 28299125 32500126 32600127 37601128 31100129 31400130 31801131 31400132 32399133 31800134 30600135 36101136 30900137 30901138 25499139 30201140 31801141 29999142 28200143 35000144 31500145 32000146 33000147 32400148 29700149 30200150 29399151 206900152 70300153 1500154 1500155 1499156 1700157 1399158 1499159 1401160 1501161 1499162 1401163 1700164 1401165 1400166 1400167 1500168 1500169 1600170 1400171 1800172 1400173 1501174 1500175 1600176 1499177 1500178 1500179 1601180 1400181 1399182 1399183 1500184 1400185 1500186 1399187 1500188 1500189 1499190 1500191 1501192 1600193 1500194 1599195 1499196 1400197 1600198 1600199 1599 原因是什么呢？ JVM 将执行状态分成了 5 个层次： 0 层，解释执行（Interpreter） 1 层，使用 C1 即时编译器编译执行（不带 profiling） 2 层，使用 C1 即时编译器编译执行（带基本的 profiling） 3 层，使用 C1 即时编译器编译执行（带完全的 profiling） 4 层，使用 C2 即时编译器编译执行 profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等 即时编译器（JIT）与解释器的区别 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译 解释器是将字节码解释为针对所有平台都通用的机器码 JIT 会根据平台类型，生成平台特定的机器码 对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），优化之 刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:-DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果 参考资料：https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4 方法内联（Inlining） 123private static int square(final int i) &#123; return i * i;&#125; 1System.out.println(square(9)); 如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置： 1System.out.println(9 * 9); 还能够进行常量折叠（constant folding）的优化 1System.out.println(81); 实验 1234567891011121314151617181920public class JIT2 &#123; // -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印 inlining 信息 // -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining // -XX:+PrintCompilation 打印编译信息 public static void main(String[] args) &#123; int x = 0; for (int i = 0; i &lt; 500; i++) &#123; long start = System.nanoTime(); for (int j = 0; j &lt; 1000; j++) &#123; x = square(9); &#125; long end = System.nanoTime(); System.out.printf(&quot;%d\\t%d\\t%d\\n&quot;,i,x,(end - start)); &#125; &#125; private static int square(final int i) &#123; return i * i; &#125; &#125; 字段优化JMH 基准测试请参考：http://openjdk.java.net/projects/code-tools/jmh/创建 maven 工程，添加依赖如下 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 编写基准测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package test;import org.openjdk.jmh.annotations.*;import org.openjdk.jmh.runner.Runner;import org.openjdk.jmh.runner.RunnerException;import org.openjdk.jmh.runner.options.Options;import org.openjdk.jmh.runner.options.OptionsBuilder;import java.util.Random;import java.util.concurrent.ThreadLocalRandom;@Warmup(iterations = 2, time = 1)@Measurement(iterations = 5, time = 1)@State(Scope.Benchmark)public class Benchmark1 &#123; int[] elements = randomInts(1_000); private static int[] randomInts(int size) &#123; Random random = ThreadLocalRandom.current(); int[] values = new int[size]; for (int i = 0; i &lt; size; i++) &#123; values[i] = random.nextInt(); &#125; return values; &#125; @Benchmark public void test1() &#123; for (int i = 0; i &lt; elements.length; i++) &#123; doSum(elements[i]); &#125; &#125; @Benchmark public void test2() &#123; int[] local = this.elements; for (int i = 0; i &lt; local.length; i++) &#123; doSum(local[i]); &#125; &#125; @Benchmark public void test3() &#123; for (int element : elements) &#123; doSum(element); &#125; &#125; static int sum = 0; @CompilerControl(CompilerControl.Mode.DONT_INLINE) static void doSum(int x) &#123; sum += x; &#125; public static void main(String[] args) throws RunnerException &#123; Options opt = new OptionsBuilder() .include(Benchmark1.class.getSimpleName()) .forks(1) .build(); new Runner(opt).run(); &#125;&#125; 首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）： 1234Benchmark Mode Samples Score Score error Unitst.Benchmark1.test1 thrpt 5 2420286.539 390747.467 ops/st.Benchmark1.test2 thrpt 5 2544313.594 91304.136 ops/st.Benchmark1.test3 thrpt 5 2469176.697 450570.647 ops/s 接下来禁用 doSum 方法内联 1234@CompilerControl(CompilerControl.Mode.DONT_INLINE) static void doSum(int x) &#123; sum += x; &#125; 测试结果如下： 1234Benchmark Mode Samples Score Score error Unitst.Benchmark1.test1 thrpt 5 296141.478 63649.220 ops/st.Benchmark1.test2 thrpt 5 371262.351 83890.984 ops/st.Benchmark1.test3 thrpt 5 368960.847 60163.391 ops/s 分析： 在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化：如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）： 12345678@Benchmark public void test1() &#123; // elements.length 首次读取会缓存起来 -&gt; int[] local for (int i = 0; i &lt; elements.length; i++) &#123; // 后续 999 次 求长度 &lt;- local sum += elements[i]; // 1000 次取下标 i 的元素 &lt;- local &#125; &#125; 可以节省 1999 次 Field 读取操作但如果 doSum 方法没有内联，则不会进行上面的优化 练习：在内联情况下将 elements 添加 volatile 修饰符，观察测试结果 8) 反射优化12345678910111213141516171819package cn.itcast.jvm.t3.reflect; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect1 &#123; public static void foo() &#123; System.out.println(&quot;foo...&quot;); &#125; public static void main(String[] args) throws Exception &#123; Method foo = Reflect1.class.getMethod(&quot;foo&quot;); for (int i = 0; i &lt;= 16; i++) &#123; System.out.printf(&quot;%d\\t&quot;, i); foo.invoke(null); &#125; System.in.read(); &#125; &#125; foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现 12345678910111213141516171819202122232425262728293031323334353637383940package sun.reflect; import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method; import sun.reflect.misc.ReflectUtil; class NativeMethodAccessorImpl extends MethodAccessorImpl &#123; private final Method method; private DelegatingMethodAccessorImpl parent; private int numInvocations; NativeMethodAccessorImpl(Method method) &#123; this.method = method; &#125; public Object invoke(Object target, Object[] args) throws IllegalArgumentException, InvocationTargetException &#123; // inflationThreshold 膨胀阈值，默认 15 if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123; // 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右 MethodAccessorImpl generatedMethodAccessor = (MethodAccessorImpl) (new MethodAccessorGenerator()) .generateMethod( this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers() ); this.parent.setDelegate(generatedMethodAccessor); &#125; // 调用本地实现 return invoke0(this.method, target, args); &#125; void setParent(DelegatingMethodAccessorImpl parent) &#123; this.parent = parent; &#125; private static native Object invoke0(Method method, Object target, Object[] args); &#125; 当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到类名为 sun.reflect.GeneratedMethodAccessor1 可以使用阿里的 arthas 工具： 1234java -jar arthas-boot.jar[INFO] arthas-boot version: 3.1.1[INFO] Found existing java process, please choose one and hit RETURN.* [1]: 13065 cn.itcast.jvm.t3.reflect.Reflect1 选择 1 回车表示分析该进程 12345678910111213141516[INFO] arthas home: C:\\Users\\fyp01\\.arthas\\lib\\3.5.6\\arthas[INFO] Try to attach process 13012[INFO] Attach process 13012 success.[INFO] arthas-client connect 127.0.0.1 3658 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \\ | .--. &#x27;&#x27;--. .--&#x27;| &#x27;--&#x27; | / O \\ &#x27; .-&#x27;| .-. || &#x27;--&#x27;.&#x27; | | | .--. || .-. |`. `-.| | | || |\\ \\ | | | | | || | | |.-&#x27; |`--&#x27; `--&#x27;`--&#x27; &#x27;--&#x27; `--&#x27; `--&#x27; `--&#x27;`--&#x27; `--&#x27;`-----&#x27;wiki https://arthas.aliyun.com/doctutorials https://arthas.aliyun.com/doc/arthas-tutorials.htmlversion 3.5.6main_classpid 13012time 2022-03-05 13:31:26 再输入【jad + 类名】来进行反编译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[arthas@13012]$ jad sun.reflect.GeneratedMethodAccessor1ClassLoader:+-sun.reflect.DelegatingClassLoader@1d44bcfa +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@5cad8086Location:/* * Decompiled with CFR. * * Could not load the following classes: * cn.itcast.jvm.t3.reflect.Reflect1 */package sun.reflect;import cn.itcast.jvm.t3.reflect.Reflect1;import java.lang.reflect.InvocationTargetException;import sun.reflect.MethodAccessorImpl;public class GeneratedMethodAccessor1extends MethodAccessorImpl &#123; /* * Loose catch block */ public Object invoke(Object object, Object[] objectArray) throws InvocationTargetException &#123; // 比较奇葩的做法，如果有参数，那么抛非法参数异常 block4: &#123; if (objectArray == null || objectArray.length == 0) break block4; throw new IllegalArgumentException(); &#125; try &#123; // 可以看到，已经是直接调用了 Reflect1.foo(); // 因为没有返回值 return null; &#125; catch (Throwable throwable) &#123; throw new InvocationTargetException(throwable); &#125; catch (ClassCastException | NullPointerException runtimeException) &#123; throw new IllegalArgumentException(super.toString()); &#125; &#125;&#125;Affect(row-cnt:1) cost in 609 ms.[arthas@13012]$ 注意通过查看 ReflectionFactory 源码可知 sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算） sun.reflect.inflationThreshold 可以修改膨胀阈值 五、内存模型1. java内存模型1) 原子性原子性在学习线程时讲过，下面来个例子简单回顾一下： 问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？ 2) 问题分析以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。 例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令 1234getstatic i // 获取静态变量i的值iconst_1 // 准备常量1iadd // 加法putstatic i // 将修改后的值存入静态变量i 而对应 i– 也是类似： 1234getstatic i // 获取静态变量i的值iconst_1 // 准备常量1isub // 减法putstatic i // 将修改后的值存入静态变量 而Java的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换 ： 如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题： 123456789// 假设i的初始值为0getstatic i // 线程1-获取静态变量i的值 线程内i=0iconst_1 // 线程1-准备常量1iadd // 线程1-自增 线程内i=1putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1getstatic i // 线程1-获取静态变量i的值 线程内i=1iconst_1 // 线程1-准备常量1isub // 线程1-自减 线程内i=0putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=0 但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况： 123456789// 假设i的初始值为0getstatic i // 线程1-获取静态变量i的值 线程内i=0getstatic i // 线程2-获取静态变量i的值 线程内i=0iconst_1 // 线程1-准备常量1iadd // 线程1-自增 线程内i=1putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1iconst_1 // 线程2-准备常量1isub // 线程2-自减 线程内i=-1putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 出现正数的情况： 123456789/ 假设i的初始值为0getstatic i // 线程1-获取静态变量i的值 线程内i=0getstatic i // 线程2-获取静态变量i的值 线程内i=0iconst_1 // 线程1-准备常量1iadd // 线程1-自增 线程内i=1iconst_1 // 线程2-准备常量1isub // 线程2-自减 线程内i=-1putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 3) 解决方法语法 123synchronized( 对象 ) &#123; //要作为原子操作代码&#125; 用 synchronized 解决并发问题： 1234567891011121314151617181920212223static int i = 0;static Object obj = new Object();public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 5000; j++) &#123; synchronized (obj) &#123; i++; &#125; &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 5000; j++) &#123; synchronized (obj) &#123; i--; &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i);&#125; 如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。 当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行count++ 代码。 这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。 当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count– 代码。 注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。 Java并发之线程八锁链接：https://blog.csdn.net/F15217283411/article/details/122752255?spm=1001.2014.3001.5501 2. 可见性1) 退不出的循环先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止： 12345678910111213141516171819package cn.itcast.jvm.t4.avo;public class Demo4_2 &#123; static boolean run = true; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(()-&gt;&#123; while(run)&#123; // .... //System.out.println(1); &#125; &#125;); t.start(); Thread.sleep(1000); run = false; // 线程t不会如预想的停下来 &#125;&#125; 为什么呢？分析一下： 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值 2) 解决方法volatile（易变关键字） 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存 3) 可见性前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的： 123456getstatic run // 线程 t 获取 run truegetstatic run // 线程 t 获取 run truegetstatic run // 线程 t 获取 run truegetstatic run // 线程 t 获取 run trueputstatic run // 线程 main 修改 run 为 false， 仅此一次getstatic run // 线程 t 获取 run false 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错 12345678getstatic i // 线程1-获取静态变量i的值 线程内i=0getstatic i // 线程2-获取静态变量i的值 线程内i=0iconst_1 // 线程1-准备常量1iadd // 线程1-自增 线程内i=1putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1iconst_1 // 线程2-准备常量1isub // 线程2-自减 线程内i=-1putstatic i //线程2-将修改后的值存入静态变量i 静态变量i=-1 注意： synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于重量级操作，性能相对更低 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？ 3. 有序性1) 诡异的结果1234567891011121314151617int num = 0;boolean ready = false;// 线程1 执行此方法public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125;&#125; // 线程2 执行此方法public void actor2(I_Result r) &#123; num = 2; ready = true;&#125; I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ 有同学这么分析 情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了） 但我告诉你，结果还有可能是 0 ，信不信吧！ 相信很多人已经晕了 这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现： 借助 java 并发压测工具 jcstress：https://hg.openjdk.java.net/code-tools/jcstress/ 创建 maven 项目，提供如下测试类 1234567891011121314151617181920212223242526272829package test;import org.openjdk.jcstress.annotations.*;import org.openjdk.jcstress.infra.results.I_Result;//@JCStressTest@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)@Statepublic class ConcurrencyTest &#123; int num = 0; volatile boolean ready = false; @Actor public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125; &#125; @Actor public void actor2(I_Result r) &#123; num = 2; ready = true; &#125;&#125; 执行 12mvn clean installjava -jar target/jcstress.jar 会输出我们感兴趣的结果，摘录其中一次结果： 12345678910111213141516*** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 2 matching test results. [OK] test.ConcurrencyTest (JVM args: [-XX:-TieredCompilation]) Observed state Occurrences Expectation Interpretation 0 1,729 ACCEPTABLE_INTERESTING !!!! 1 42,617,915 ACCEPTABLE ok 4 5,146,627 ACCEPTABLE ok [OK] test.ConcurrencyTest (JVM args: []) Observed state Occurrences Expectation Interpretation 0 1,652 ACCEPTABLE_INTERESTING !!!! 0 46,460,657 ACCEPTABLE !!!! 0 4,571,072 ACCEPTABLE !!!! 可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。 2) 解决方法volatile 修饰的变量，可以禁用指令重排 1234567891011121314151617181920212223242526272829package test;import org.openjdk.jcstress.annotations.*;import org.openjdk.jcstress.infra.results.I_Result;//@JCStressTest@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)@Statepublic class ConcurrencyTest &#123; int num = 0; boolean ready = false; @Actor public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125; &#125; @Actor public void actor2(I_Result r) &#123; num = 2; ready = true; &#125;&#125; 结果为： 123*** INTERESTING testsSome interesting behaviors observed. This is for the plain curiosity.0 matching test results. 3) 有序性理解JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码 123456static int i;static int j;// 在某个线程内执行如下赋值操作i = ...; // 较为耗时的操作j = ...; 可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是 12i = ...; // 较为耗时的操作j = ... 也可以是 12j = ...;i = ...; // 较为耗时的操作 这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性，例如著名的 double-checked locking 模式实现单例 12345678910111213141516public final class Singleton &#123; private Singleton() &#123; &#125; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; // 实例没创建，才会进入内部的 synchronized代码块 if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; // 也许有其它线程已经创建实例，所以再判断一次 if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 以上的实现特点是： 懒惰实例化 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 但在多线程环境下，上面的代码是有问题的， INSTANCE = new Singleton() 对应的字节码为： 123450: new #2 // class cn/itcast/jvm/t4/Singleton3: dup4: invokespecial #3 // Method &quot;&lt;init&gt;&quot;:()V7: putstatic #4 // FieldINSTANCE:Lcn/itcast/jvm/t4/Singleton; 其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1，t2 按如下时间序列执行： 123456时间1 t1 线程执行到 INSTANCE = new Singleton();时间2 t1 线程分配空间，为Singleton对象生成了引用地址（0 处）时间3 t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE != null（7 处）时间4 t2 线程进入getInstance() 方法，发现 INSTANCE != null（synchronized块外），直接返回 INSTANCE时间5 t1 线程执行Singleton的构造方法（4 处） 这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效 4) happens-beforehappens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见 1234567891011121314static int x;static Object m = new Object();new Thread(()-&gt;&#123; synchronized(m) &#123; x = 10; &#125;&#125;,&quot;t1&quot;).start();new Thread(()-&gt;&#123; synchronized(m) &#123; System.out.println(x); &#125;&#125;,&quot;t2&quot;).start(); 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见 123456789volatile static int x;new Thread(()-&gt;&#123; x = 10;&#125;,&quot;t1&quot;).start();new Thread(()-&gt;&#123; System.out.println(x);&#125;,&quot;t2&quot;).start(); 线程 start 前对变量的写，对该线程开始后对该变量的读可见 1234567static int x;x = 10;new Thread(()-&gt;&#123; System.out.println(x);&#125;,&quot;t2&quot;).start(); 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或t1.join()等待它结束） 12345678static int x;Thread t1 = new Thread(()-&gt;&#123; x = 10;&#125;,&quot;t1&quot;);t1.start();t1.join();System.out.println(x); 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted） 12345678910111213141516171819202122232425static int x;public static void main(String[] args) &#123; Thread t2 = new Thread(()-&gt;&#123; while(true) &#123; if(Thread.currentThread().isInterrupted()) &#123; System.out.println(x); break; &#125; &#125; &#125;,&quot;t2&quot;); t2.start(); new Thread(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; x = 10; t2.interrupt(); &#125;,&quot;t1&quot;).start(); while(!t2.isInterrupted()) &#123; Thread.yield(); &#125; System.out.println(x);&#125; 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z 变量都是指成员变量或静态成员变量 4. CAS 与 原子类CASCAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 +1 操作： 1234567891011121314// 需要不断尝试while(true) &#123; int 旧值 = 共享变量 ; // 比如拿到了当前值 0 int 结果 = 旧值 + 1; // 在旧值 0 的基础上增加 1 ，正确结果是 1 /* 这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候 compareAndSwap 返回 false，重新尝试，直到： compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰 */ if( compareAndSwap ( 旧值, 结果 )) &#123; // 成功，退出循环 &#125;&#125; 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import sun.misc.Unsafe;import java.lang.reflect.Field;public class TestCAS &#123; public static void main(String[] args) throws InterruptedException &#123; DataContainer dc = new DataContainer(); int count = 5; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; count; i++) &#123; dc.increase(); &#125; &#125;); t1.start(); t1.join(); System.out.println(dc.getData()); &#125;&#125;class DataContainer &#123; private volatile int data; static final Unsafe unsafe; static final long DATA_OFFSET; static &#123; try &#123; // Unsafe 对象不能直接调用，只能通过反射获得 Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; throw new Error(e); &#125; try &#123; // data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性 DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(&quot;data&quot;)); &#125; catch (NoSuchFieldException e) &#123; throw new Error(e); &#125; &#125; public void increase() &#123; int oldValue; while(true) &#123; // 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解 oldValue = data; // cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue + 1)) &#123; return; &#125; &#125; &#125; public void decrease() &#123; int oldValue; while(true) &#123; oldValue = data; if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue - 1)) &#123; return; &#125; &#125; &#125; synchronized public int getData() &#123; return data; &#125;&#125; 乐观锁与悲观锁 CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 原子操作类juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。 可以使用 AtomicInteger 改写之前的例子： 1234567891011121314151617181920// 创建原子整数对象private static AtomicInteger i = new AtomicInteger(0);public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 5000; j++) &#123; i.getAndIncrement(); // 获取并且自增 i++ // i.incrementAndGet(); // 自增并且获取 ++i &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 5000; j++) &#123; i.getAndDecrement(); // 获取并且自减 i-- &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i);&#125; 5. synchronized 优化Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word 平时存储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为 标记位 、 线程锁记录指针 、 重量级锁指针 、 线程ID 等内容 轻量级锁如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。这就好比： 学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程A 随即升级为重量级锁，进入重量级锁的流程。 而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁 123456789101112static Object obj = new Object();public static void method1() &#123; synchronized( obj ) &#123; // 同步块 A method2(); &#125;&#125; public static void method2() &#123; synchronized( obj ) &#123; // 同步块 B &#125;&#125; 每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word 线程 1 对象 Mark Word 线程 2 访问同步块 A，把 Mark 复制到 线程 1 的锁记录 01（无锁） - CAS 修改 Mark 为线程 1 锁记录 地址 01（无锁） - 成功（加锁） 00（轻量锁）线程 1 锁记录地址 - 执行同步块 A 00（轻量锁）线程 1 锁记录地址 - 访问同步块 B，把 Mark 复制到 线程 1 的锁记录 00（轻量锁）线程 1 锁记录地址 - CAS 修改 Mark 为线程 1 锁记录 地址 00（轻量锁）线程 1 锁记录地址 - 失败（发现是自己的锁） 00（轻量锁）线程 1 锁记录地址 - 锁重入 00（轻量锁）线程 1 锁记录地址 - 执行同步块 B 00（轻量锁）线程 1 锁记录地址 - 同步块 B 执行完毕 00（轻量锁）线程 1 锁记录地址 - 同步块 A 执行完毕 00（轻量锁）线程 1 锁记录地址 - 成功（解锁） 01（无锁） - - 01（无锁） 访问同步块 A，把 Mark 复制到 线程 2 的锁记录 - 01（无锁） CAS 修改 Mark 为线程 2 锁记录 地址 - 00（轻量锁）线程 2 锁记录地址 成功（加锁） - … … 锁膨胀如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。 123456static Object obj = new Object();public static void method1() &#123; synchronized( obj ) &#123; // 同步块 &#125;&#125; 线程 1 对象 Mark 线程 2 访问同步块，把 Mark 复制到线程 1 的锁记录 01（无锁） - CAS 修改 Mark 为线程 1 锁记录地 址 01（无锁） - 成功（加锁） 00（轻量锁）线程 1 锁 记录地址 - 执行同步块 00（轻量锁）线程 1 锁 记录地址 - 执行同步块 00（轻量锁）线程 1 锁 记录地址 访问同步块，把 Mark 复制 到线程 2 执行同步块 00（轻量锁）线程 1 锁 记录地址 CAS 修改 Mark 为线程 2 锁 记录地址 执行同步块 00（轻量锁）线程 1 锁 记录地址 失败（发现别人已经占了 锁） 执行同步块 00（轻量锁）线程 1 锁 记录地址 CAS 修改 Mark 为重量锁 执行同步块 10（重量锁）重量锁指 针 阻塞中 执行完毕 10（重量锁）重量锁指 针 阻塞中 失败（解锁） 10（重量锁）重量锁指 针 阻塞中 释放重量锁，唤起阻塞线程竞争 01（无锁） 阻塞中 - 10（重量锁） 竞争重量锁 - 10（重量锁） 成功（加锁） - … … 重量级锁重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算） Java 7 之后不能控制是否开启自旋功能 自旋重试成功的情况 线程 1 （cpu 1 上） 对象 Mark 线程 2 （cpu 2 上） - 10（重量锁） - 访问同步块，获取 monitor 10（重量锁）重量锁指针 - 成功（加锁） 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor 执行同步块 10（重量锁）重量锁指针 自旋重试 执行完毕 10（重量锁）重量锁指针 自旋重试 成功（解锁） 01（无锁） 自旋重试 - 10（重量锁）重量锁指针 成功（加锁） - 10（重量锁）重量锁指针 执行同步块 - … … 自旋重试失败的情况 线程 1（cpu 1 上） 对象 Mark 线程 2（cpu 2 上） - 10（重量锁） - 访问同步块，获取 monitor 10（重量锁）重量锁指针 - 成功（加锁） 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 阻塞 - … … 偏向锁量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID是自己的就表示没有竞争，不用重新 CAS. 撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW） 访问对象的 hashCode 也会撤销偏向锁 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 重偏向会重置对象的 Thread ID 撤销偏向和重偏向都是批量进行的，以类为单位 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的 可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁 可以参考这篇论文：https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf 假设有两个方法同步块，利用同一个对象加锁 12345678910111213static Object obj = new Object();public static void method1() &#123; synchronized( obj ) &#123; // 同步块 A method2(); &#125;&#125; public static void method2() &#123; synchronized( obj ) &#123; // 同步块 B &#125;&#125; 线程 1 对象 Mark 访问同步块 A，检查 Mark 中是否有线程 ID 101（无锁可偏向） 尝试加偏向锁 101（无锁可偏向）对象 hashCode 成功 101（无锁可偏向）线程ID 执行同步块 A 101（无锁可偏向）线程ID 访问同步块 B，检查 Mark 中是否有线程 ID 101（无锁可偏向）线程ID 是自己的线程 ID，锁是自己的，无需做更多操作 101（无锁可偏向）线程ID 执行同步块 B 101（无锁可偏向）线程ID 执行完毕 101（无锁可偏向）对象 hashCode 其他优化1) 减少上锁时间同步代码块中尽量短 （有针对性的保护） 2) 减少锁的粒度将一个锁拆分为多个锁提高并发度，例如： ConcurrentHashMap LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值 LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高 3) 锁粗化多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次） 1new StringBuffer().append(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;); 4) 锁消除JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。 5) 读写分离CopyOnWriteArrayList ConyOnWriteSet 参考：Oralce官方 Synchronization java锁优化/ 聊聊并发（二）——Java SE1.6 中的 Synchronized Java锁优化–JVM锁降级 从jvm的角度来看java的多线程 Java 是否曾经重新调整单个锁","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://fyupeng.github.io/tags/jvm/"}],"author":"fyupeng"},{"title":"Netty 入门 - 03","slug":"Netty03","date":"2022-06-25T07:04:15.000Z","updated":"2022-06-25T07:09:42.295Z","comments":true,"path":"2022/06/25/Netty03/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/Netty03/","excerpt":"","text":"一、google-protobuf1. 编码和解码的基本介绍 编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图] codec（编解码器）的组成部分有两个：decoder（解码器）和 encoder（编码器）。encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成业务数据 2. Netty 本身的编码解码的机制和问题分析 Netty 自身提供了一些 codec(编解码器) Netty提供的编码器 StringEncoder：对字符串数据进行编码。 ObjectEncoder：对Java对象进行编码。 Netty提供的解码器 StringDecoder,对字符串数据进行解码 ObjectDecoder，对 Java 对象进行解码 Netty本身自带的ObjectDecoder和ObjectEncoder可以用来实现POJO对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题 无法跨语言 序列化后的体积太大，是二进制编码的5倍多。 序列化性能太低 引出新的解决方案[Google 的 Protobuf] 3. Protobuf Protobuf 基本介绍和使用示意图, protoc下载https://developer.aliyun.com/article/710477 Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC [远程过程调用 remote procedure call ]数据交换格式。目前很多公司 从http + json 转向tcp + protobuf，效率会更高。 参考文档：https://developers.google.com/protocol-buffers/docs/proto 语言指南 Protobuf 是以 message 的方式来管理数据的. 支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 C++、C#、Java、python 等） 高性能，高可靠性 使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用 .proto 文件进行描述。说明，在 idea 中编写 .proto 文件时，会自动提示是否下载 .ptoto 编写插件.可以让语法高亮。 然后通过 protoc.exe 编译器根据 .proto 自动生成 .java 文件 protobuf 使用示意图 4. Protobuf 快速入门实例1编写程序，使用 Protobuf 完成如下功能 客户端可以发送一个 StudentPoJo 对象到服务器(通过 Protobuf 编码) 服务端能接收 StudentPoJo 对象，并显示信息(通过 Protobuf 解码) 12345&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt; Student.proto 1234567syntax = &quot;proto3&quot;; //版本option java_outer_classname = &quot;StudentPOJO&quot;; // 生成的外部类名，同时也是文件名// protobuf 使用message 管理数据message Student &#123; // 会在 StudentPOJO 外部类生成一个内部类 Student, 它是真正发送的 POJO对象 int32 id = 1; // Student 类中有一个 属性 名字为 id类型为 int32(protobuf类型) 1 表示属性序号 string name = 2;&#125; 编译 protoc.exe –java_out=.Student.proto 将生成的 StudentPOJO 放入到项目使用 NettyServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.fyp.netty.codec;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty服务端 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建 BossGroup 和 WorkGroup /* 说明： 1. 创建两个线程组 bossGroup 和 workGroup 2. bossGroup 只是 处理 连接请求， 真正的 和客户端 业务处理， 会交给 workGroup 来完成 3. 两个都是 无限循环 4. bossGroup 和 workerGroup 含有的 子线程 （NioEventLoop）的个数 默认实际 cpu核数 * 2 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; // 创建 服务器端的 启动对象， 配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); // 使用 链式编程 来 进行设置 bootstrap.group(bossGroup, workerGroup) // 设置两个 线程组 .channel(NioServerSocketChannel.class) // 使用 NioSocketChannel 作为 服务器的 通道实现 .option(ChannelOption.SO_BACKLOG, 128) // 设置 线程队列 得到 连接个数 .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置 保持活动 连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; // 创建一个 通道 测试对象 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 在 pipeline 中加入 ProtobufDecoder // 指定对 哪种对象 进行解码 pipeline.addLast(&quot;decoder&quot;, new ProtobufDecoder(StudentPOJO.Student.getDefaultInstance())); pipeline.addLast(new NettyServerHandler()); &#125; &#125;); // 给我们的 workerGroup 的 EventLoop 对应的管道 设置处理器 System.out.println(&quot;... 服务器 is ready...&quot;); // 绑定一个 端口， 并且同步，生成 一个 ChannelFuture 对象 // 启动 服务器并绑定端口 ChannelFuture cf = bootstrap.bind(6667).sync(); // 对 关闭通道 进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; NettyServerHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fyp.netty.codec;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: nettty服务端处理器 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyServerHandler extends SimpleChannelInboundHandler&lt;StudentPOJO.Student&gt; &#123; /** * 读取数据 * @param ctx 上下文对象，含有 管道 pipeline, 通道 channel, 地址 * @param msg 客户端发送的 数据， 默认类型 Object * @throws Exception */ @Override public void channelRead0(ChannelHandlerContext ctx, StudentPOJO.Student msg) throws Exception &#123; System.out.println(&quot;客户端发送的数据 id &quot; + msg.getId() + &quot; name &quot; + msg.getName()); &#125; // 处理读取完毕 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; super.channelReadComplete(ctx); // 将数据 写入到 缓存 并 刷新 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端: 狗&quot;, CharsetUtil.UTF_8)); &#125; // 处理异常， 要关闭 通道 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); ctx.close(); &#125;&#125; NerttyClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.fyp.netty.codec;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.protobuf.ProtobufEncoder;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty客户端 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; // 客户端 需要 一个 事件循环组 NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; // 创建 客户端 启动对象 // 注意客户端 使用的不是 ServerBootStrap, 而是BootStrap Bootstrap bootstrap = new Bootstrap(); // 设置相关 参数 bootstrap.group(group) // 设置 线程组 .channel(NioSocketChannel.class) // 设置 客户端 通道的 实现类（反射) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // 在 pipeline 中 加入 ProtobufEncoder ch.pipeline().addLast(&quot;encoder&quot;, new ProtobufEncoder()); ch.pipeline().addLast(new NettyClientHandler()); // 加入自己的 处理器 &#125; &#125;); System.out.println(&quot;客户端 ok...&quot;); // 启动客户端 去连接 服务器端 // 关于 ChannelFuture 要分析， 涉及到 netty 的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6667).sync(); // 对关闭 通道 进行监听 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; NettyClientHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.fyp.netty.codec;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty客户端处理器 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // 发送一个 Student对象 到服务器 StudentPOJO.Student student = StudentPOJO.Student.newBuilder().setId(4).setName(&quot;豹子头 林冲&quot;).build(); ctx.writeAndFlush(student); &#125; // 当通道 有读取事件 时 ，会触发 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息:&quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址： &quot;+ ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 5. Protobuf 快速入门实例 2 编写程序，使用 Protobuf 完成如下功能 客户端可以随机发送 StudentPoJo / WorkerPoJo 对象到服务器(通过 Protobuf 编码) 服务端能接收 StudentPoJo / WorkerPoJo 对象(需要判断是哪种类型)，并显示信息(通过 Protobuf 解码) 12345&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt; Student.proto 123456789101112131415161718192021222324252627282930syntax = &quot;proto3&quot;;option optimize_for = SPEED; //加快解析option java_package = &quot;com.fyp.netty.codec2&quot;; // 指定生成到哪个包option java_outer_classname = &quot;MyDataInfo&quot;; // 外部类名// protobuf 可以使用 message 管理其他的messagemessage MyMessage &#123; enum DataType &#123; StudentType = 0; // 在 proto3 要求 enum 的编号 从0 开始 WorkerType = 1; &#125; //用 data_type 来标识 传的是 哪一个 枚举类型 DataType data_type = 1; // 表示 每次 枚举类型 最多 只能出现 其中一个，节省空间 oneof dataBody &#123; Student student = 2; Worker worker = 3; &#125;&#125;message Student &#123; int32 id = 1; string name = 2;&#125;message Worker &#123; string name = 1; int32 age = 2;&#125; NettyServer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.fyp.netty.codec2;import com.fyp.netty.codec.StudentPOJO;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty服务端 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建 BossGroup 和 WorkGroup /* 说明： 1. 创建两个线程组 bossGroup 和 workGroup 2. bossGroup 只是 处理 连接请求， 真正的 和客户端 业务处理， 会交给 workGroup 来完成 3. 两个都是 无限循环 4. bossGroup 和 workerGroup 含有的 子线程 （NioEventLoop）的个数 默认实际 cpu核数 * 2 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; // 创建 服务器端的 启动对象， 配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); // 使用 链式编程 来 进行设置 bootstrap.group(bossGroup, workerGroup) // 设置两个 线程组 .channel(NioServerSocketChannel.class) // 使用 NioSocketChannel 作为 服务器的 通道实现 .option(ChannelOption.SO_BACKLOG, 128) // 设置 线程队列 得到 连接个数 .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置 保持活动 连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; // 创建一个 通道 测试对象 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 在 pipeline 中加入 ProtobufDecoder // 指定对 哪种对象 进行解码 pipeline.addLast(&quot;decoder&quot;, new ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance())); pipeline.addLast(new NettyServerHandler()); &#125; &#125;); // 给我们的 workerGroup 的 EventLoop 对应的管道 设置处理器 System.out.println(&quot;... 服务器 is ready...&quot;); // 绑定一个 端口， 并且同步，生成 一个 ChannelFuture 对象 // 启动 服务器并绑定端口 ChannelFuture cf = bootstrap.bind(6667).sync(); // 对 关闭通道 进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; NettyServerHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.fyp.netty.codec2;import com.fyp.netty.codec.StudentPOJO;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: nettty服务端处理器 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyServerHandler extends SimpleChannelInboundHandler&lt;MyDataInfo.MyMessage&gt; &#123; /** * 读取数据 * @param ctx 上下文对象，含有 管道 pipeline, 通道 channel, 地址 * @param msg 客户端发送的 数据， 默认类型 Object * @throws Exception */ @Override public void channelRead0(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg) throws Exception &#123; // 根据 dataType 来显示 不同的信息 MyDataInfo.MyMessage.DataType dataType = msg.getDataType(); if (dataType == MyDataInfo.MyMessage.DataType.StudentType) &#123; MyDataInfo.Student student = msg.getStudent(); System.out.println(&quot;学生id &quot; + student.getId() + &quot;学生名字 &quot; + student.getName()); &#125; else if (dataType == MyDataInfo.MyMessage.DataType.WorkerType) &#123; MyDataInfo.Worker worker = msg.getWorker(); System.out.println(&quot;工人名字&quot; + worker.getName() + &quot;工人年龄&quot; + worker.getAge()); &#125; else &#123; System.out.println(&quot;传输的类型不正确&quot;); &#125; &#125; // 处理读取完毕 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; super.channelReadComplete(ctx); // 将数据 写入到 缓存 并 刷新 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端: 狗&quot;, CharsetUtil.UTF_8)); &#125; // 处理异常， 要关闭 通道 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); ctx.close(); &#125;&#125; NettyClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.fyp.netty.codec2;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.protobuf.ProtobufEncoder;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty客户端 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; // 客户端 需要 一个 事件循环组 NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; // 创建 客户端 启动对象 // 注意客户端 使用的不是 ServerBootStrap, 而是BootStrap Bootstrap bootstrap = new Bootstrap(); // 设置相关 参数 bootstrap.group(group) // 设置 线程组 .channel(NioSocketChannel.class) // 设置 客户端 通道的 实现类（反射) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // 在 pipeline 中 加入 ProtobufEncoder ch.pipeline().addLast(&quot;encoder&quot;, new ProtobufEncoder()); ch.pipeline().addLast(new NettyClientHandler()); // 加入自己的 处理器 &#125; &#125;); System.out.println(&quot;客户端 ok...&quot;); // 启动客户端 去连接 服务器端 // 关于 ChannelFuture 要分析， 涉及到 netty 的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6667).sync(); // 对关闭 通道 进行监听 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; NettyClientHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.fyp.netty.codec2;import com.fyp.netty.codec.StudentPOJO;import com.fyp.netty.heartbeat.MyServer;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import java.util.Random;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty客户端处理器 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // 随机的 发送 Student 或者 Worker 对象 int random = new Random().nextInt(3); MyDataInfo.MyMessage myMessage = null; if (0 == random) &#123; // 发送 student 对象 myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder().setId(5).setName(&quot;玉麒麟 卢俊义&quot;).build()).build(); &#125; else &#123; myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType).setWorker(MyDataInfo.Worker.newBuilder().setName(&quot;老李&quot;).setAge(20).build()).build(); &#125; ctx.writeAndFlush(myMessage); &#125; // 当通道 有读取事件 时 ，会触发 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息:&quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址： &quot;+ ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 二、Netty出入站和调用机制1. 基本说明 Netty 的组件设计：Netty 的主要组件有 Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe 等 ChannelHandler 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 ChannelInboundHandler 接口（或 ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 ChannelInboundHandler 冲刷数据。业务逻辑通常写在一个或者多个 ChannelInboundHandler 中。ChannelOutboundHandler 原理一样，只不过它是用来处理出站数据的 ChannelPipeline 提供了 ChannelHandler 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 pipeline 中的一系列 ChannelOutboundHandler，并被这些 Handler 处理，反之则称为入站的 2. 编码解码器 当 Netty 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 java 对象）；如果是出站消息，它会被编码成字节。 Netty 提供一系列实用的编解码器，他们都实现了 ChannelInboundHadnler 或者 ChannelOutboundHandler 接口。在这些类中，channelRead 方法已经被重写了。以入站为例，对于每个从入站 Channel 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 decode() 方法进行解码，并将已经解码的字节转发给 ChannelPipeline 中的下一个 ChannelInboundHandler。 3. 解码器 - ByteToMessageDecoder 关系继承图 由于不可能知道远程节点是否会一次性发送一个完整的信息，tcp 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.【后面有说TCP的粘包和拆包问题】 一个关于 ByteToMessageDecoder 实例分析 4. Netty的handler链的调用机制实例要求: 使用自定义的编码器和解码器来说明 Netty 的 handler 调用机制 客户端发送 long -&gt; 服务器 服务端发送 long -&gt; 客户端 代码演示MyServer 12345678910111213141516171819202122232425262728293031323334353637package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: 我的服务端 * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyServer &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer()); // 自定义一个 初始化类 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyServerHandler 123456789101112131415161718192021222324252627282930package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: 我的服务端处理器 * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyServerHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123; System.out.println(&quot;从客户端&quot; + ctx.channel().remoteAddress() + &quot;读取到的long &quot; + msg); ctx.writeAndFlush(98765L); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; MyServerInitializer 1234567891011121314151617181920212223242526272829package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: 服务器初始化类 * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 入站的 handler 进行解码 MyByteToLongDecoder pipeline.addLast(new MyByteToLongDecoder()); // 出站的 handler 进行编码 MyLongToByteEncoder pipeline.addLast(new MyLongToByteEncoder()); // 自定义的 handler 处理业务逻辑 pipeline.addLast(new MyServerHandler()); &#125;&#125; MyClient 12345678910111213141516171819202122232425262728293031323334353637383940package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyClient &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer()); // 自定义一个 初始化类 ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; MyClientHandler 1234567891011121314151617181920212223242526272829package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyClientHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123; System.out.println(&quot;服务器端发回的消息：&quot; + msg); &#125; // 发送数据 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;MyClientHandler 发送数据&quot;); //ctx.writeAndFlush(Unpooled.copiedBuffer()) ctx.writeAndFlush(123456L); // 发送的是 一个 Long &#125;&#125; MyClientInitializer 1234567891011121314151617181920212223242526272829package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: 客户端初始化类 * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 加入 一个 入站的 handler 对数据 进行 解码 pipeline.addLast(new MyByteToLongDecoder()); // 加入 一个 出站的 handler 对数据 进行 编码 pipeline.addLast(new MyLongToByteEncoder()); // 加入 一个自定义的 handler 处理业务 pipeline.addLast(new MyClientHandler()); &#125;&#125; MyByteToLongDecoder 1234567891011121314151617181920212223242526272829303132333435363738394041package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ByteToMessageDecoder;import java.util.List;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyByteToLongDecoder extends ByteToMessageDecoder &#123; /** * decode 会根据接受的数据，调用多次，直到 确定没有 新的元素 添加到 list， * 或者是 ByteBuf 没有更多的 可读字节为止 * 如果list out 不为空， 就会将 list 的内容 传递给 下一个 ChannelInBoundHandler * 处理，该处理器的 方法也会被 调用多次 * @param ctx 上下文对象 * @param in 入站的 ByteBuf * @param out list 集合，将解码后的 数据 传给下一个 handler * @throws Exception */ @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; System.out.println(&quot;MyByteToLongDecoder decoder 被调用&quot;); // 因为 long 8个字节 if (in.readableBytes() &gt;= 8) &#123; out.add(in.readLong()); &#125; &#125;&#125; MyLongToByteEncoder 123456789101112131415161718192021222324package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyLongToByteEncoder extends MessageToByteEncoder&lt;Long&gt; &#123; @Override protected void encode(ChannelHandlerContext ctx, Long msg, ByteBuf out) throws Exception &#123; System.out.println(&quot;MyLongToByteEncoder encode 被调用&quot;); System.out.println(&quot;msg &quot; + msg); out.writeLong(msg); &#125;&#125; 效果服务端：handler调用顺序：MyByteToLongDecoder -&gt; MyServerHandler-&gt; MyLongToByteEncoder 客户端：handler调用顺序：MyClientHandler-&gt; MyLongToByteEncoder -&gt; MyByteToLongDecoder 出站入站关于出站入站，很多人可能有点迷糊 1）客户端有出站入站，服务端也有出站入站 2）以客户端为例，如果有服务端传送的数据到达客户端，那么对于客户端来说就是入站； 如果客户端传送数据到服务端，那么对于客户端来说就是出站； 同理，对于服务端来说，也是一样的，有数据来就是入站，有数据输出就是出站 3）为什么服务端和客户端的Serverhandler都是继承SimpleChannelInboundHandler，而没有ChannelOutboundHandler出站类？ 实际上当我们在handler中调用ctx.writeAndFlush()方法后，就会将数据交给ChannelOutboundHandler进行出站处理，只是我们没有去定义出站类而已，若有需求可以自己去实现ChannelOutboundHandler出站类 4）总结就是客户端和服务端都有出站和入站的操作 服务端发数据给客户端：服务端—&gt;出站—&gt;Socket通道—&gt;入站—&gt;客户端 客户端发数据给服务端：客户端—&gt;出站—&gt;Socket通道—&gt;入站—&gt;服务端 理透handler链执行入站出站原理（双链结构）理解：通过对继承的类来过滤是出站的还是入站的，然后再去执行该类的实现方法 head ↔ ServerInitializer(服务端初始化器) ↔ decoder(解码器) ↔ encoder(编码器) ↔ ServerHandler(自定义处理器)↔ tail 通过以下的代码： 过滤后得到： 入站(head-&gt;tail方向)：decoder(解码器) -&gt; ServerHandler(自定义处理器) 出站(tail-&gt;head方向)：ServerHandler(自定义处理器) -&gt; encoder(编码器) 123456789101112131415161718private AbstractChannelHandlerContext findContextInbound(int mask) &#123; AbstractChannelHandlerContext ctx = this; EventExecutor currentExecutor = executor(); do &#123; ctx = ctx.next; &#125; while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND)); return ctx;&#125;private AbstractChannelHandlerContext findContextOutbound(int mask) &#123; AbstractChannelHandlerContext ctx = this; EventExecutor currentExecutor = executor(); do &#123; ctx = ctx.prev; // 会跳过只处理那些入站的 handler &#125; while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND)); return ctx;&#125; 5. ByteToMessageDecoder 不论解码器 handler 还是编码器 handler 即接收的消息类型必须与待处理的消息类型一致，否则该 handler 不会被执行 在解码器进行数据解码时，需要判断缓存区（ByteBuf）的数据是否足够，否则接收到的结果会期望结果可能不一致。 6. 解码器 - ReplayingDecoder public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder ReplayingDecoder 扩展了 ByteToMessageDecoder 类，使用这个类，我们不必调用 readableBytes() 方法，也就不用判断还有没有足够的数据来读取。参数 S 指定了用户状态管理的类型，其中 Void 代表不需要状态管理 应用实例：使用 ReplayingDecoder 编写解码器，对前面的案例进行简化[案例演示] 1234567891011121314151617181920212223242526package com.fyp.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ByteToMessageDecoder;import io.netty.handler.codec.ReplayingDecoder;import java.util.List;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyByteToLongDecoder2 extends ReplayingDecoder&lt;Void&gt; &#123; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; System.out.println(&quot;MyByteToLongDecoder2 被调用&quot;); // 在 ReplayingDecoder 不需要 判断 数据 是否足够 读取，内部会进行 处理判断 out.add(in.readLong()); &#125;&#125; ReplayingDecoder使用方便，但它也有一些局限性： 并不是所有的 ByteBuf 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 UnsupportedOperationException。 ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢 7. 其它编解码器 LineBasedFrameDecoder：这个类在 Netty 内部也有使用，它使用行尾控制字符（\\n或者\\r\\n）作为分隔符来解析数据。 DelimiterBasedFrameDecoder：使用自定义的特殊字符作为消息的分隔符。 HttpObjectDecoder：一个 HTTP 数据的解码器 LengthFieldBasedFrameDecoder：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。 8. Log4j 整合到 Netty 在 Maven 中添加对 Log4j 的依赖在 pom.xml 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置 Log4j，在 resources/log4j.properties 1234log4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%p]%C&#123;1&#125;-%m%n 三、TCP粘包和拆包1. TCP 粘包和拆包基本介绍 TCP 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的 由于 TCP 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图 TCP 粘包、拆包图解 假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况： 服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包 服务端一次接受到了两个数据包，D1 和 D2 粘合在一起，称之为 TCP 粘包 服务端分两次读取到了数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这称之为 TCP 拆包 服务端分两次读取到了数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余部分内容 D1_2 和完整的 D2 包。 2. TCP 粘包和拆包现象实例在编写 Netty 程序时，如果没有做处理，就会发生粘包和拆包的问题 看一个具体的实例： MyServer 12345678910111213141516171819202122232425262728293031323334353637package com.fyp.netty.tcp;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: 我的服务端 * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyServer &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer()); // 自定义一个 初始化类 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyServerInitializer 123456789101112131415161718192021package com.fyp.netty.tcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyServerHandler()); &#125;&#125; MyServerHandler 1234567891011121314151617181920212223242526272829303132333435363738package com.fyp.netty.tcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;import java.util.UUID;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyServerHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; private int count; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123; byte[] buffer = new byte[msg.readableBytes()]; msg.readBytes(buffer); // 将 buffer 转成 字符串 String message = new String(buffer, Charset.forName(&quot;UTF-8&quot;)); System.out.println(&quot;服务器接收到数据 &quot; + message); System.out.println(&quot;服务器接收到数据量= &quot; + (++this.count)); // 服务端 回送数据 给客户端 ，回送一个 随机 id ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + &quot;\\n&quot;, Charset.forName(&quot;utf-8&quot;)); ctx.writeAndFlush(responseByteBuf); &#125;&#125; MyClient 1234567891011121314151617181920212223242526272829303132333435363738package com.fyp.netty.tcp;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyClient &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer()); // 自定义一个 初始化类 ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; MyClientInitializer 1234567891011121314151617181920212223package com.fyp.netty.tcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyClientHandler()); &#125;&#125; MyClientHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fyp.netty.tcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;import java.nio.charset.Charset;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; private int count; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // 使用 客户端 发送 十条 数据，从而模拟 tcp 的 粘包和拆包 for (int i = 0; i &lt;10; i++) &#123; ByteBuf buffer = Unpooled.copiedBuffer(&quot;hello,server&quot; + i, Charset.forName(&quot;utf-8&quot;)); ctx.writeAndFlush(buffer); &#125; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123; byte[] buffer = new byte[msg.readableBytes()]; msg.readBytes(buffer); String message = new String(buffer, Charset.forName(&quot;utf-8&quot;)); System.out.println(&quot;客户端接收到消息=&quot; + message); System.out.println(&quot;客户端接受消息数据= &quot; + (++this.count)); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 3. TCP 粘包和拆包解决方案 常用方案：使用自定义协议+编解码器来解决 关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 TCP 粘包、拆包。 看一个具体的实例 要求客户端发送 5 个 Message 对象，客户端每次发送一个 Message 对象 服务器端每次接收一个 Message，分 5 次进行解码，每读取到一个 Message，会回复一个 Message 对象给客户端。 MessageProtoco 123456789101112131415161718192021222324252627282930package com.fyp.netty.protocoltcp;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: 协议包 * @Package: com.fyp.netty.protocoltcp * @Version: 1.0 */public class MessageProtocol &#123; private int len; private byte[] content; public int getLen() &#123; return len; &#125; public void setLen(int len) &#123; this.len = len; &#125; public byte[] getContent() &#123; return content; &#125; public void setContent(byte[] content) &#123; this.content = content; &#125;&#125; MyServer 12345678910111213141516171819202122232425262728293031323334353637package com.fyp.netty.protocoltcp;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: 我的服务端 * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyServer &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer()); // 自定义一个 初始化类 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyServerInitializer 123456789101112131415161718192021222324package com.fyp.netty.protocoltcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyMessageDecoder()); pipeline.addLast(new MyMessageEncoder()); pipeline.addLast(new MyServerHandler()); &#125;&#125; MyServerHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.fyp.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;import java.util.UUID;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyServerHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123; private int count; @Override protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception &#123; //接收到数据，并处理 int len = msg.getLen(); byte[] content = msg.getContent(); System.out.println(&quot;服务器接收到信息如下&quot;); System.out.println(&quot;长度=&quot; + len); System.out.println(&quot;内容=&quot; + new String(content, Charset.forName(&quot;utf-8&quot;))); System.out.println(&quot;服务器接收到消息包数量=&quot; + (++this.count)); //回复消息 System.out.println(&quot;服务端开始回复消息------&quot;); String responseContent = UUID.randomUUID().toString(); int responseLen = responseContent.getBytes(&quot;utf-8&quot;).length; byte[] responseContent2 = responseContent.getBytes(&quot;utf-8&quot;); //构建一个协议包 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(responseLen); messageProtocol.setContent(responseContent2); ctx.writeAndFlush(messageProtocol); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; //cause.printStackTrace(); ctx.close(); &#125;&#125; MyMessageDecoder 123456789101112131415161718192021222324252627282930313233343536373839package com.fyp.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ReplayingDecoder;import java.util.List;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.protocoltcp * @Version: 1.0 */public class MyMessageDecoder extends ReplayingDecoder&lt;Void&gt; &#123; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; System.out.println(&quot;MyMessageDecoder decode 被调用&quot;); // 需要 将 二进制 字节码 -&gt; MessageProtocol 数据包（对象） /** * 获取 是 在 之前的 编码器写入的 int 和 byte 类型数据 * out.writeInt(msg.getLen()); * out.writeBytes(msg.getContent()); */ int length = in.readInt(); byte[] content = new byte[length]; in.readBytes(content); MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(length); messageProtocol.setContent(content); out.add(messageProtocol); &#125;&#125; MyClient 1234567891011121314151617181920212223242526272829303132333435363738package com.fyp.netty.protocoltcp;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;/** * @Auther: fyp * @Date: 2022/2/16 * @Description: * @Package: com.fyp.netty.inboundhandlerandoutboundhandler * @Version: 1.0 */public class MyClient &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer()); // 自定义一个 初始化类 ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; MyClientInitializer 1234567891011121314151617181920212223242526package com.fyp.netty.protocoltcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyMessageEncoder()); pipeline.addLast(new MyMessageDecoder()); pipeline.addLast(new MyClientHandler()); &#125;&#125; MyClientHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.fyp.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.tcp * @Version: 1.0 */public class MyClientHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123; private int count; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // 使用客户端 发送十条数据，今天天气冷，吃火锅 for (int i = 0; i &lt; 5; i++) &#123; String mes = &quot;abc&quot;; byte[] content = mes.getBytes(Charset.forName(&quot;utf-8&quot;)); int length = content.length; // 创建 协议包 对象 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(length); messageProtocol.setContent(content); ctx.writeAndFlush(messageProtocol); &#125; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception &#123; int len = msg.getLen(); byte[] content = msg.getContent(); System.out.println(&quot;客户端接收到消息如下&quot;); System.out.println(&quot;长度=&quot; + len); System.out.println(&quot;内容=&quot; + new String(content, Charset.forName(&quot;utf-8&quot;))); System.out.println(&quot;客户端接收消息数量=&quot; + (++this.count)); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(&quot;异常提醒=&quot; + cause.getMessage()); ctx.close(); &#125;&#125; MyMessageEncoder 1234567891011121314151617181920212223package com.fyp.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;/** * @Auther: fyp * @Date: 2022/2/17 * @Description: * @Package: com.fyp.netty.protocoltcp * @Version: 1.0 */public class MyMessageEncoder extends MessageToByteEncoder&lt;MessageProtocol&gt; &#123; @Override protected void encode(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out) throws Exception &#123; System.out.println(&quot;MyMessageEncoder encode 方法 被调用&quot;); out.writeInt(msg.getLen()); out.writeBytes(msg.getContent()); &#125;&#125; 四、Netty实现RPC1. RPC 基本介绍 RPC（Remote Procedure Call）—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程 两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图) 过程： 调用者(Caller)，调用远程API(Remote API) 调用远程API会通过一个RPC代理(RpcProxy) RPC代理再去调用RpcInvoker(这个是PRC的调用者) RpcInvoker通过RPC连接器(RpcConnector) RPC连接器用两台机器规定好的PRC协议(RpcProtocol)把数据进行编码 接着RPC连接器通过RpcChannel通道发送到对方的PRC接收器(RpcAcceptor) PRC接收器通过PRC协议进行解码拿到数据 然后将数据传给RpcProcessor RpcProcessor再传给RpcInvoker RpcInvoker调用Remote API 最后推给被调用者(Callee) 常见的 RPC 框架有：比较知名的如阿里的 Dubbo、Google 的 gRPC、Go 语言的 rpcx、Apache 的 thrift，Spring 旗下的 SpringCloud。 2. 我们的RPC 调用流程图 RPC 调用流程说明 服务消费方（client）以本地调用方式调用服务 client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体 client stub 将消息进行编码并发送到服务端 server stub 收到消息后进行解码 server stub 根据解码结果调用本地的服务 本地服务执行并将结果返回给 server stub server stub 将返回导入结果进行编码并发送至消费方 client stub 接收到消息并进行解码 服务消费方（client）得到结果 小结：RPC 的目标就是将 2 - 8 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用 3. 己实现 Dubbo RPC（基于 Netty）需求说明 Dubbo 底层使用了 Netty 作为网络通讯框架，要求用 Netty 实现一个简单的 RPC 框架 模仿 Dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.20 设计说明 创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。 创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。 创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求提供者返回数据 开发的分析图 使用rpc框架打包时，如果是用的是全局库，打包会找不到netty的jar包，需要通过maven引入的方式打包","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://fyupeng.github.io/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://fyupeng.github.io/tags/netty/"}],"author":"fyupeng"},{"title":"Netty 入门 - 02","slug":"Netty02","date":"2022-06-25T07:04:09.000Z","updated":"2022-06-25T07:09:33.572Z","comments":true,"path":"2022/06/25/Netty02/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/Netty02/","excerpt":"","text":"Netty入门02 一、Netty 概述1. 原生 NIO 存在的问题 NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。 需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。 JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU100%。直到 JDK1.7 版本该问题仍旧存在，没有被根本解决。 2. Netty 官网说明官网：https://netty.io/ Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. 3. Netty 的优点Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。 设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。 使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK5（Netty3.x）或 6（Netty4.x）就足够了。 高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。 安全：完整的 SSL/TLS 和 StartTLS 支持。 社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。 4. Netty 版本说明 Netty 版本分为 Netty 3.x 和 Netty 4.x、Netty 5.x 因为 Netty 5 出现重大 bug，已经被官网废弃了，目前推荐使用的是 Netty 4.x的稳定版本 目前在官网可下载的版本 Netty 3.x、Netty 4.0.x 和 Netty 4.1.x 在本套课程中，我们讲解 Netty4.1.x 版本 Netty 下载地址：https://bintray.com/netty/downloads/netty/ 5. Netty Maven 下载5.1 通过官网下载点击进入 Project Structure 点击Library 添加Library From Maven 输入 io.netty:netty-all:4.1.20.Final 后查找 5.2 通过 maven12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;$&#123;netty.version&#125;&lt;/version&gt;&lt;/dependency&gt; 二、Netty 高性能架构设计1. 线程模型基本介绍 不同的线程模式，对程序的性能有很大影响，为了搞清 Netty 线程模式，我们来系统的讲解下各个线程模式，最后看看 Netty 线程模型有什么优越性。 目前存在的线程模型有：传统阻塞 I/O 服务模型 和Reactor 模式 根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现 单 Reactor 单线程； 单 Reactor多线程； 主从 Reactor多线程 Netty 线程模式（Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor） 2. 传统阻塞 I/O 服务模型工作原理图 黄色的框表示对象，蓝色的框表示线程 白色的框表示方法（API） 模型特点 采用阻塞 IO 模式获取输入的数据 每个连接都需要独立的线程完成数据的输入，业务处理，数据返回 问题分析 当并发数很大，就会创建大量的线程，占用很大系统资源 连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 Handler对象中的read 操作，导致上面的处理线程资源浪费 3. Reactor 模式针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：基于 I/O 复用模型：多个连接共用一个阻塞对象ServiceHandler，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。 Reactor 在不同书中的叫法： 反应器模式 分发者模式（Dispatcher） 通知者模式（notifier） 基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。（解决了当并发数很大时，会创建大量线程，占用很大系统资源） 基于 I/O 复用模型：多个客户端进行连接，先把连接请求给ServiceHandler。多个连接共用一个阻塞对象ServiceHandler。假设，当C1连接没有数据要处理时，C1客户端只需要阻塞于ServiceHandler，C1之前的处理线程便可以处理其他有数据的连接，不会造成线程资源的浪费。当C1连接再次有数据时，ServiceHandler根据线程池的空闲状态，将请求分发给空闲的线程来处理C1连接的任务。（解决了线程资源浪费的那个问题） I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图对上图说明： Reactor 模式，通过一个或多个输入同时传递给服务处理器（ServiceHandler）的模式（基于事件驱动） 服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 Reactor 模式也叫 Dispatcher 模式 Reactor 模式使用 IO 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键 原先有多个Handler阻塞，现在只用一个ServiceHandler阻塞 Reactor 模式中核心组成 Reactor（也就是那个ServiceHandler）：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理线程来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人； Handlers（处理线程EventHandler）：处理线程执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理线程来响应 I/O 事件，处理程序执行非阻塞操作。 Reactor 模式分类根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 单 Reactor 单线程 单 Reactor 多线程 主从 Reactor 多线程 4. 单 Reactor 单线程原理图，并使用 NIO 群聊系统验证 方案说明 Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求 Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发 如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理 如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应 Handler 会完成 Read → 业务处理 → Send 的完整业务流程 结合实例：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。 方案优缺点分析 优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成 缺点：性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈 缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障 使用场景：客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1) 的情况 5. 单 Reactor 多线程方案说明 Reactor 对象通过 Select 监控客户端请求事件，收到事件后，通过 Dispatch 进行分发 如果是建立连接请求，则由 Acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理完成连接后的各种事件 如果不是连接请求，则由 Reactor 分发调用连接对应的 handler 来处理（也就是说连接已经建立，后续客户端再来请求，那基本就是数据请求了，直接调用之前为这个连接创建好的handler来处理） handler 只负责响应事件，不做具体的业务处理（这样不会使handler阻塞太久），通过 read 读取数据后，会分发给后面的 worker 线程池的某个线程处理业务。【业务处理是最费时的，所以将业务处理交给线程池去执行】 worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler handler 收到响应后，通过 send 将结果返回给 client 方案优缺点分析 优点：可以充分的利用多核 cpu 的处理能力 缺点：多线程数据共享和访问比较复杂。Reactor 承担所有的事件的监听和响应，它是单线程运行，在高并发场景容易出现性能瓶颈。也就是说Reactor主线程承担了过多的事 6. 主从 Reactor 多线程工作原理图针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行 Reactor 主线程 MainReactor 对象通过 select 监听连接事件，收到事件后，通过 Acceptor 处理连接事件 当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor subreactor 将连接加入到连接队列进行监听，并创建 handler 进行各种事件处理 当有新事件发生时，subreactor 就会调用对应的 handler 处理 handler 通过 read 读取数据，分发给后面的 worker 线程处理 worker 线程池分配独立的 worker 线程进行业务处理，并返回结果 handler 收到响应的结果后，再通过 send 将结果返回给 client Reactor 主线程可以对应多个 Reactor 子线程，即 MainRecator 可以关联多个 SubReactor 方案优缺点说明 优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。 优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。 缺点：编程复杂度较高 结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持 7. Reactor 模式小结3 种模式用生活案例来理解 单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务 单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待 主从 Reactor 多线程，多个前台接待员，多个服务生 Reactor 模式具有如下的优点 响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的（比如你第一个SubReactor阻塞了，我可以调下一个 SubReactor为客户端服务） 可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销 扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源 复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性 8. Netty 模型 讲解netty的时候采用的是先写代码体验一下，再细讲里面的原理。前面看不懂的可以先不用纠结，先往后面看，后面基本都会讲清楚 工作原理示意图1 - 简单版Netty主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor 对上图说明 BossGroup 线程维护 Selector，只关注 Accept 当接收到 Accept 事件，获取到对应的 SocketChannel，封装成 NIOScoketChannel 并注册到 Worker 线程（事件循环），并进行维护 当 Worker 线程监听到 Selector 中通道发生自己感兴趣的事件后，就进行处理（就由 handler），注意 handler 已经加入到通道 工作原理示意图2 - 进阶版 BossGroup有点像主Reactor 可以有多个，WorkerGroup则像SubReactor一样可以有多个。 工作原理示意图3 - 详细版 Netty 抽象出两组线程池 ，BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写 BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 NioEventLoop NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 Selector，用于监听绑定在其上的 socket 的网络通讯 NioEventLoopGroup 可以有多个线程，即可以含有多个 NioEventLoop 每个BossGroup下面的NioEventLoop循环执行的步骤有3步 轮询 accept 事件 处理 accept 事件，与 client 建立连接，生成 NioScocketChannel，并将其注册到某个 workerGroup NIOEventLoop 上的 Selector 继续处理任务队列的任务，即 runAllTasks 每个WorkerGroup、NIOEventLoop循环执行的步骤 轮询 read，write 事件 处理 I/O 事件，即 read，write 事件，在对应 NioScocketChannel 处理 处理任务队列的任务，即 runAllTasks 每个 Worker NIOEventLoop 处理业务时，会使用 pipeline（管道），pipeline 中包含了 channel（通道），即通过 pipeline 可以获取到对应通道，管道中维护了很多的处理器。（这个点目前只是简单的讲，后面重点说） Netty 快速入门实例 - TCP 服务实例要求：使用 IDEA 创建 Netty 项目 Netty 服务器在 6668 端口监听，客户端能发送消息给服务器”hello,服务器~” 服务器可以回复消息给客户端”hello,客户端~” 目的：对 Netty 线程模型有一个初步认识，便于理解 Netty 模型理论 编写服务端 编写客户端 对 netty 程序进行分析，看看 netty 模型特点 说明：创建 Maven 项目，并引入 Netty 包 代码如下 NettyServer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.fyp.netty.simple;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty服务端 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建 BossGroup 和 WorkGroup /* 说明： 1. 创建两个线程组 bossGroup 和 workGroup 2. bossGroup 只是 处理 连接请求， 真正的 和客户端 业务处理， 会交给 workGroup 来完成 3. 两个都是 无限循环 4. bossGroup 和 workerGroup 含有的 子线程 （NioEventLoop）的个数 默认实际 cpu核数 * 2 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; // 创建 服务器端的 启动对象， 配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); // 使用 链式编程 来 进行设置 bootstrap.group(bossGroup, workerGroup) // 设置两个 线程组 .channel(NioServerSocketChannel.class) // 使用 NioSocketChannel 作为 服务器的 通道实现 .option(ChannelOption.SO_BACKLOG, 128) // 设置 线程队列 得到 连接个数 .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置 保持活动 连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; // 创建一个 通道 测试对象 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); // 给我们的 workerGroup 的 EventLoop 对应的管道 设置处理器 System.out.println(&quot;... 服务器 is ready...&quot;); // 绑定一个 端口， 并且同步，生成 一个 ChannelFuture 对象 // 启动 服务器并绑定端口 ChannelFuture cf = bootstrap.bind(6667).sync(); // 对 关闭通道 进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; NettyServerHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.fyp.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import java.nio.charset.Charset;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: nettty服务端处理器 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; /** * 读取数据 * @param ctx 上下文对象，含有 管道 pipeline, 通道 channel, 地址 * @param msg 客户端发送的 数据， 默认类型 Object * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName()); // 不能 调用 父类的 channelRead方法，否则 会报 以下异常： // An exceptionCaught() event was fired, and it reached at the tail of the pipeline. // It usually means the last handler in the pipeline did not handle the exception //super.channelRead(ctx, msg); System.out.println(&quot;server ctx = &quot; + ctx); // 将 msg 转成一个 ByteBuffer ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;客户端发送消息是： &quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;客户端地址：&quot; + ctx.channel().remoteAddress()); &#125; // 处理读取完毕 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; super.channelReadComplete(ctx); // 将数据 写入到 缓存 并 刷新 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端: 狗&quot;, CharsetUtil.UTF_8)); &#125; // 处理异常， 要关闭 通道 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); ctx.close(); &#125;&#125; NettyClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.fyp.netty.simple;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty客户端 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; // 客户端 需要 一个 事件循环组 NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; // 创建 客户端 启动对象 // 注意客户端 使用的不是 ServerBootStrap, 而是BootStrap Bootstrap bootstrap = new Bootstrap(); // 设置相关 参数 bootstrap.group(group) // 设置 线程组 .channel(NioSocketChannel.class) // 设置 客户端 通道的 实现类（反射) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new NettyClientHandler()); // 加入自己的 处理器 &#125; &#125;); System.out.println(&quot;客户端 ok...&quot;); // 启动客户端 去连接 服务器端 // 关于 ChannelFuture 要分析， 涉及到 netty 的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6667).sync(); // 对关闭 通道 进行监听 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; NettyClientHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.fyp.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;/** * @Auther: fyp * @Date: 2022/2/11 * @Description: netty客户端处理器 * @Package: com.fyp.netty.simple * @Version: 1.0 */public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); System.out.println(&quot;client ctx = &quot; + ctx); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,server: (&gt;^ω^&lt;)喵&quot;, CharsetUtil.UTF_8)); &#125; // 当通道 有读取事件 时 ，会触发 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务端回复的消息： &quot; + buf.toString()); System.out.println(&quot;服务端的地址： &quot; + ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 任务队列中的 Task 有 3 种典型使用场景 用户程序自定义的普通任务【举例说明】 用户自定义定时任务 非当前 Reactor 线程调用 Channel 的各种方法 ​ 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被异步消费 前两种的代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.atguigu.netty.simple;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import java.util.concurrent.TimeUnit;/** * 说明 * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范) * 2. 这时我们自定义一个Handler , 才能称为一个handler */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; //读取数据实际(这里我们可以读取客户端发送的消息) /** * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址 * 2. Object msg: 就是客户端发送的数据 默认Object */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的 // NIOEventLoop 的 taskQueue中, // 解决方案1 用户程序自定义的普通任务 ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5 * 1000); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;, CharsetUtil.UTF_8)); System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode()); &#125; catch (Exception ex) &#123; System.out.println(&quot;发生异常&quot; + ex.getMessage()); &#125; &#125; &#125;); ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5 * 1000); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;, CharsetUtil.UTF_8)); System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode()); &#125; catch (Exception ex) &#123; System.out.println(&quot;发生异常&quot; + ex.getMessage()); &#125; &#125; &#125;); //解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中 ctx.channel().eventLoop().schedule(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5 * 1000); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;, CharsetUtil.UTF_8)); System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode()); &#125; catch (Exception ex) &#123; System.out.println(&quot;发生异常&quot; + ex.getMessage()); &#125; &#125; &#125;, 5, TimeUnit.SECONDS); System.out.println(&quot;go on ...&quot;);// System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());// System.out.println(&quot;server ctx =&quot; + ctx);// System.out.println(&quot;看看channel 和 pipeline的关系&quot;);// Channel channel = ctx.channel();// ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站// // //将 msg 转成一个 ByteBuf// //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.// ByteBuf buf = (ByteBuf) msg;// System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));// System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress()); &#125; //数据读取完毕 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //writeAndFlush 是 write + flush //将数据写入到缓存，并刷新 //一般讲，我们对这个发送的数据进行编码 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;, CharsetUtil.UTF_8)); &#125; //处理异常, 一般是需要关闭通道 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125;&#125; 方案再说明 Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负责网络读写操作。 NioEventLoop 表示一个不断循环执行处理任务的线程，每个 NioEventLoop 都有一个 Selector，用于监听绑定在其上的 socket网络通道。 NioEventLoop 内部采用串行化设计，从消息的 读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop 负责 NioEventLoopGroup 下包含多个 NioEventLoop 每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue 每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel 每个 NioChannel 只会绑定在唯一的 NioEventLoop 上 每个 NioChannel 都绑定有一个自己的 ChannelPipeline 9. 异步模型基本介绍 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。 Netty 中的 I/O 操作是异步的，包括 Bind、Write、Connect 等操作会首先简单的返回一个 ChannelFuture。 调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。 Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。重点说 Future，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun 返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future 去监控方法 fun 的处理过程（即：Future-Listener 机制） Future 说明 表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。 ChannelFuture 是一个接口：public interface ChannelFuture extends Future&lt;Void&gt; 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。 工作原理示意图下面第一张图就是管道，中间会经过多个handler 说明： 在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用 future 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。 Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。 Future-Listener 机制 这里看不懂的可以看笔者的并发系列-JUC部分 当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。 常见有如下操作 通过 isDone 方法来判断当前操作是否完成； 通过 isSuccess 方法来判断已完成的当前操作是否成功； 通过 getCause 方法来获取已完成的当前操作失败的原因； 通过 isCancelled 方法来判断已完成的当前操作是否被取消； 通过 addListener 方法来注册监听器，当操作已完成（isDone方法返回完成），将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器 举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑 1234567891011121314//绑定一个端口并且同步,生成了一个ChannelFuture对象//启动服务器(并绑定端口)ChannelFuture cf = bootstrap.bind(6668).sync();//给cf注册监听器，监控我们关心的事件cf.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete (ChannelFuture future) throws Exception &#123; if (future.isSuccess()) &#123; System.out.println(&quot;监听端口6668成功&quot;); &#125; else &#123; System.out.println(&quot;监听端口6668失败&quot;); &#125; &#125;&#125;); 快速入门实例 - HTTP服务 实例要求：使用 IDEA 创建 Netty 项目 Netty 服务器在 9999 端口监听，浏览器发出请求 http://localhost:9999/ 服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。 目的：Netty 可以做 Http 服务开发，并且理解 Handler 实例和客户端及其请求的关系。 代码演示 TestServer 123456789101112131415161718192021222324252627282930313233343536373839package com.fyp.netty.http;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;/** * @Auther: fyp * @Date: 2022/2/12 * @Description: 测试http服务端 * @Package: com.fyp.netty.http * @Version: 1.0 */public class TestServer &#123; public static void main(String[] args) throws Exception&#123; EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new TestServerInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(9999).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; TestHttpServeHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.fyp.netty.http;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.buffer.UnpooledByteBufAllocator;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.*;import io.netty.util.CharsetUtil;import java.net.URI;/** * @Auther: fyp * @Date: 2022/2/12 * @Description: 测试http服务端处理器 * @Package: com.fyp.netty.http * @Version: 1.0 */public class TestHttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123; // 判断 msg 是不是 httpRequest请求 if(msg instanceof HttpRequest) &#123; System.out.println(&quot;pipeline hashcode: &quot; + ctx.pipeline().hashCode() + &quot; TestHttpServerHandler hashcode: &quot; + this.hashCode()); System.out.println(&quot;msg 类型：&quot; + msg.getClass()); System.out.println(&quot;客户端地址：&quot; + ctx.channel().remoteAddress()); // 获取 HttpRequest HttpRequest httpRequest = (HttpRequest) msg; // 获取 uri URI uri = new URI(httpRequest.uri()); System.out.println(&quot;请求路径： &quot; + uri); if (&quot;/favicon.ico&quot;.equals(uri.getPath())) &#123; System.out.println(&quot;请求了favicon.ico, 不做响应&quot;); return; &#125; // 回复信息 给 浏览器 [http 协议] ByteBuf content = Unpooled.copiedBuffer(&quot;hello 我是服务器&quot;, CharsetUtil.UTF_8); // 构造一个 http 响应 FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content); response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/plain;charset=UTF-8&quot;); response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes()); //将构建好 response返回，必要一步，没有客户端 将收不到服务端 发送的数据 ctx.writeAndFlush(response); &#125; &#125;&#125; TestServerInitializer 12345678910111213141516171819202122232425262728293031323334353637package com.fyp.netty.http;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;import io.netty.handler.codec.http.HttpServerCodec;/** * @Auther: fyp * @Date: 2022/2/12 * @Description: 测试http服务端的初始化器 * @Package: com.fyp.netty.http * @Version: 1.0 */public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // 向 管道 加入 处理器 // 得到 管道 ChannelPipeline pipeline = ch.pipeline(); // 加入 一个 netty 提供的 httpServerCodec =&gt; [coder - decoder] /* HttpServerCodec 说明 1. HttpServerCodec 是 netty 提供的 处理 http 的编解码器 2. 增加一个自定义的 handler */ pipeline.addLast(&quot;MyHttpServerCodec&quot;, new HttpServerCodec()); pipeline.addLast(&quot;MyTestHttpServerHandler&quot;, new TestHttpServerHandler()); System.out.println(&quot;ok ~&quot;); &#125;&#125; 三、Netty 核心模块组件Bootstrap、ServerBootstrap Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。 常见的方法有 public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于服务器端，用来设置两个 EventLoop public B group(EventLoopGroup group)，该方法用于客户端，用来设置一个 EventLoop public B channel(Class&lt;? extends C&gt; channelClass)，该方法用来设置一个服务器端的通道实现 public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)，用来给 ServerChannel 添加配置 public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)，用来给接收到的通道添加配置 public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类（自定义的handler） public ChannelFuture bind(int inetPort)，该方法用于服务器端，用来设置占用的端口号 public ChannelFuture connect(String inetHost, int inetPort)，该方法用于客户端，用来连接服务器端 Future、ChannelFutureNetty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件 常见的方法有 Channel channel()，返回当前正在进行 IO 操作的通道 ChannelFuture sync()，等待异步操作执行完毕 Channel Netty 网络通信的组件，能够用于执行网络 I/O 操作。 通过 Channel 可获得当前网络连接的通道的状态 通过 Channel 可获得网络连接的配置参数（例如接收缓冲区大小） Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成 调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方 支持关联 I/O 操作与对应的处理程序 不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型： NioSocketChannel，异步的客户端 TCP Socket 连接。 NioServerSocketChannel，异步的服务器端 TCP Socket 连接。 NioDatagramChannel，异步的 UDP 连接。 NioSctpChannel，异步的客户端 Sctp 连接。 NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。 Selector Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。 当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询（Select）这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel ChannelHandler 及其实现类 ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline（业务处理链）中的下一个处理程序。 ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类 ChannelHandler 及其实现类一览图（后） 我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法 Pipeline 和 ChannelPipelineChannelPipeline 是一个重点： ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。（也可以这样理解：ChannelPipeline 是保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作） ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互 在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下 一个Channel包含了一个ChannelPipeline，而ChannelPipeline中又维护了一个由ChannelHandlerContext组成的双向链表，并且每个ChannelHandlerContext中又关联着一个ChannelHandler 入站事件和出战事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会重链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰 常用方法 ChannelPipeline addFirst(ChannelHandler... handlers)，把一个业务处理类（handler）添加到链中的第一个位置 ChannelPipeline addLast(ChannelHandler... handlers)，把一个业务处理类（handler）添加到链中的最后一个位置 TestServerInitializer和HttpServerCodec这些东西本身也是handler 一般来说事件从客户端往服务器走我们称为出站，反之则是入站。 ChannelHandlerContext 保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象 即 ChannelHandlerContext 中包含一个具体的事件处理器 ChannelHandler，同时 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。 常用方法 ChannelFuture close()，关闭通道 ChannelOutboundInvoker flush()，刷新 ChannelFuture writeAndFlush(Object msg)，将数据写到 ChannelPipeline 中当前 ChannelHandler 的下一个 ChannelHandler 开始处理（出站） ChannelOption Netty 在创建 Channel 实例后，一般都需要设置 ChannelOption 参数。 ChannelOption 参数如下： EventLoopGroup 和其实现类 NioEventLoopGroup EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。 EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup。 通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个 EventLoop 线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示 常用方法 public NioEventLoopGroup()，构造方法 public Future&lt;?&gt; shutdownGracefully()，断开连接，关闭线程 Unpooled 类 Netty 提供一个专门用来操作缓冲区（即 Netty 的数据容器）的工具类 常用方法如下所示 举例说明 Unpooled 获取 Netty 的数据容器 ByteBuf 的基本使用 ~ 案例1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.fyp.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;/** * @Auther: fyp * @Date: 2022/2/13 * @Description: ByteBuf测试 * @Package: com.fyp.netty.buf * @Version: 1.0 */public class NettyByteBuf01 &#123; public static void main(String[] args) &#123; /* 创建一个ByteBuf 说明: 1. 创建对象，该对象 包含一个 数组 arr，是一个 byte[10] 2. 在 netty 的 buffer 中，不需要 使用 flip 进行 反转 底层 维护了 readIndex 和 writeIndex 3. 通过 readerIndex 和 writerIndex 和 capacity 将 buffer 分为 三个 区域 0 - readerIndex 已经 读取的 区域 readrIndex - writeIndex 可读的 区域 writerIndex - capacity 可写的 区域 */ ByteBuf buffer = Unpooled.buffer(10); for (int i =0; i &lt; 10; i++) &#123; buffer.writeByte(i); &#125; System.out.println(&quot;capacity: &quot; + buffer.capacity()); //for (int i = 0; i &lt; buffer.capacity(); i++) &#123; // System.out.println(buffer.getByte(i)); //&#125; for (int i = 0; i &lt; buffer.capacity(); i++) &#123; System.out.println(buffer.readByte()); &#125; &#125;&#125; 案例2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.fyp.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.util.CharsetUtil;/** * @Auther: fyp * @Date: 2022/2/13 * @Description: ByteBuf测试 * @Package: com.fyp.netty.buf * @Version: 1.0 */public class NettyByteBuf02 &#123; public static void main(String[] args) &#123; // 创建 ByteBuf ByteBuf buf = Unpooled.copiedBuffer(&quot;hello,world!&quot;, CharsetUtil.UTF_8); if(buf.hasArray()) &#123; //true byte[] content = buf.array(); // 将 content 转成 字符串 System.out.println(new String(content, CharsetUtil.UTF_8)); System.out.println(&quot;ByteBuf= &quot; + buf); System.out.println(buf.arrayOffset()); System.out.println(buf.readerIndex()); System.out.println(buf.writerIndex()); System.out.println(buf.capacity()); int len = buf.readableBytes(); // 可读的 字节数 System.out.println(&quot;len= &quot; + len); // 使用 for 取出 各个字符 for (int i = 0; i &lt; len; i++) &#123; System.out.println((char) buf.getUnsignedByte(i)); &#125; System.out.println(buf.getCharSequence(0, 4, CharsetUtil.UTF_8)); System.out.println(buf.getCharSequence(4, 6, CharsetUtil.UTF_8)); &#125; &#125;&#125; Netty 应用实例-群聊系统实例要求： 编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞） 实现多人群聊 服务器端：可以监测用户上线，离线，并实现消息转发功能 客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到） 目的：进一步理解 Netty 非阻塞网络编程机制 NioSocketChannel和NioSocketChannel实现的接口 NioSocketChannel和NioSocketChannel继承的类 代码如下： GroupChatServer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.fyp.netty.groupchat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: 群聊系统服务端 * @Package: com.fyp.netty.groupchat * @Version: 1.0 */public class GroupChatServer &#123; private int port; // 监听端口 public GroupChatServer(int port) &#123; this.port = port; &#125; // 编写 run 方法，处理 客户端的 请求 public void run() throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 128) .childOption(ChannelOption.SO_KEEPALIVE, true) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // 获取到 pipeline ChannelPipeline pipeline = ch.pipeline(); // 向 pipeline 加入 解码器 pipeline.addLast(&quot;decoder&quot;, new StringDecoder()); // 向 pipeline 加入 编码器 pipeline.addLast(&quot;encoder&quot;, new StringEncoder()); // 加入自己 业务处理的 handler pipeline.addLast(new GroupChatServerHandler()); &#125; &#125;); System.out.println(&quot;netty 服务器启动...&quot;); ChannelFuture channelFuture = serverBootstrap.bind(port).sync(); // 监听 关闭 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception &#123; new GroupChatServer(7000).run(); &#125;&#125; GroupChatServerHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.fyp.netty.groupchat;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.util.concurrent.GlobalEventExecutor;import java.text.SimpleDateFormat;import java.util.Date;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: 群聊系统服务端处理器 * @Package: com.fyp.netty.groupchat * @Version: 1.0 */public class GroupChatServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; // 定义 一个 channel 组， 管理所有的 channel private static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); /** * handlerAdded 表示连接建立， 一旦连接， 第一个被执行 * 将当前的 channel 加入到 channelGroup * @param ctx * @throws Exception */ @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; Channel channel = ctx.channel(); // 将该客户端加入 聊天的信息 ，推送给 其他 客户端 /* 该方法 不会 将 channelGroup 中 所有的 channel 遍历，并发送 消息 我们 不需要 自己 遍历 */ channelGroup.writeAndFlush(&quot;[客户端]&quot; + channel.remoteAddress() + &quot; 加入聊天 &quot; + sdf.format(new Date()) + &quot;\\t&quot;); channelGroup.add(channel); &#125; // 断开 连接，将 xx 客户端 离开信息 推送给 其他 在线的 客户端 @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; Channel channel = ctx.channel(); channelGroup.writeAndFlush(&quot;[客户端]&quot; + channel.remoteAddress() + &quot; 离开了 \\t&quot;); System.out.println(&quot;channelGroup size &quot; + channelGroup.size()); &#125; // 表示 channel 处于 活动状态，提示 xx 在线 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress() + &quot;上线了~&quot;); &#125; // 表示 channel 处于 不活动状态，提示 xx 下线 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress() + &quot;离线了~&quot;); &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; // 获取到当前的 channel Channel channel = ctx.channel(); // 遍历 channelGroup，根据不同的 情况，回送 不同的 消息 channelGroup.forEach(ch -&gt; &#123; if (channel != ch) &#123; // 不是当前的 channel，转发消息 ch.writeAndFlush(&quot;[客户] &quot; + channel.remoteAddress() + &quot; 发送了消息： &quot; + msg + &quot;\\n&quot;); &#125; else &#123;// 回显 自己发送的消息 给自己 ch.writeAndFlush(&quot;[自己] 发送了消息： &quot; + msg + &quot;\\n&quot;); &#125; &#125;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; // 关闭通道 ctx.close(); &#125;&#125; GroupChatClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.fyp.netty.groupchat;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.util.Scanner;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: 群聊客户端 * @Package: com.fyp.netty.groupchat * @Version: 1.0 */public class GroupChatClient &#123; //属性 private final String host; private final int port; public GroupChatClient(String host, int port) &#123; this.host = host; this.port = port; &#125; public void run() throws InterruptedException &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // 得到 pipeline ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;decoder&quot;, new StringDecoder()); pipeline.addLast(&quot;encoder&quot;, new StringEncoder()); pipeline.addLast(new GroupChatClientHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); Channel channel = channelFuture.channel(); System.out.println(&quot;-----&quot; + channel.localAddress() + &quot;-----&quot;); // 客户端 需要 输入信息， 创建一个 扫描器 Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; String msg = scanner.nextLine(); // 通过 channel 发送到 服务器端 channel.writeAndFlush(msg + &quot;\\r\\n&quot;); &#125; &#125; finally &#123; group.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception&#123; new GroupChatClient(&quot;127.0.0.1&quot;, 7000).run(); &#125;&#125; GroupChatClientHandler 12345678910111213141516171819package com.fyp.netty.groupchat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: 群聊系统客户端处理器 * @Package: com.fyp.netty.groupchat * @Version: 1.0 */public class GroupChatClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; System.out.println(msg.trim()); &#125;&#125; Netty 心跳检测机制案例实例要求： 编写一个 Netty 心跳检测机制案例,当服务器超过 3 秒没有读时，就提示读空闲 当服务器超过 5 秒没有写操作时，就提示写空闲 实现当服务器超过 7 秒没有读或者写操作时，就提示读写空闲 代码如下： MyServer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.fyp.netty.heartbeat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.timeout.IdleStateHandler;import java.util.concurrent.TimeUnit;import java.util.jar.Pack200;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: * @Package: com.fyp.netty.heartbeat * @Version: 1.0 */public class MyServer &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) // 在 bossGroup 中 增加一个 日志 处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 加入一个 netty 提供的 IdleStateHandler /* 说明 1. IdleStateHandler 是 netty 提供的 处理 空闲状态的 处理器 2.readerIdleTime 表示多长时间 没有读，就会发送一个 心跳检测包 检测是否连接 3. writerIdleTime 表示多长时间 没有写，就会发送一个 心跳检测包 检测是否连接 4. allIdleTime 表示多长时间 没有读写，就会发送一个 心跳检测包 检测是否连接 5. 文档说明 Triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed read, write, or both operation for a while. 6. 当 IdleStateEvent 触发后， 就会 传递给管道 的下一个 handler 去处理 通过 调用（触发）下一个 handler 的 userEventTriggered, 在该方法中去处理 IdleStateEvent（读空闲，写空闲，读写空闲） */ pipeline.addLast(new IdleStateHandler(3, 5, 7 , TimeUnit.SECONDS)); // 加入一个 对 空闲检测 进行处理的 handler pipeline.addLast(new MyServerHandler()); &#125; &#125;); ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyServerHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.fyp.netty.heartbeat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.handler.timeout.IdleStateEvent;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: MyServer 处理器 * @Package: com.fyp.netty.heartbeat * @Version: 1.0 */public class MyServerHandler extends ChannelInboundHandlerAdapter &#123; /** * * @param ctx 上下文 * @param evt 事件 * @throws Exception */ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof IdleStateEvent) &#123; // 将 evt 向下转型为 IdleStateEvent IdleStateEvent event = (IdleStateEvent) evt; String eventType = null; switch (event.state()) &#123; case READER_IDLE: eventType = &quot;读空闲&quot;; break; case WRITER_IDLE: eventType = &quot;写空闲&quot;; break; case ALL_IDLE: eventType = &quot;读写空闲&quot;; break; &#125; System.out.println(ctx.channel().remoteAddress() + &quot;--超时事件--&quot; + eventType); System.out.println(&quot;服务器做相应处理&quot;); &#125; &#125;&#125; Netty 通过 WebSocket 编程实现服务器和客户端长连接实例要求： Http 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。 要求：实现基于 WebSocket 的长连接的全双工的交互 改变 Http 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器 客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知 运行界面 MyServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.fyp.netty.websocket;import com.fyp.netty.heartbeat.MyServerHandler;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.stream.ChunkedWriteHandler;import io.netty.handler.timeout.IdleStateHandler;import java.util.concurrent.TimeUnit;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: * @Package: com.fyp.netty.websocket * @Version: 1.0 */public class MyServer &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) // 在 bossGroup 中 增加一个 日志 处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 因为 基于 http协议，使用 http的 编码和解码 pipeline.addLast(new HttpServerCodec()); // 是 以块方式 写，添加 ChunkedWriteHandler 处理器 pipeline.addLast(new ChunkedWriteHandler()); /* 说明 1. http数据 在传输过程中是分段的， HttpObjectAggregator 就是可以将 多个段 聚合 2.这就是为什么 当 浏览器 发送 大量数据时， 就会 发送 多次 http请求 */ pipeline.addLast(new HttpObjectAggregator(8192)); /* 说明 1. 对应的 webSocket, 它的数据 以帧（frame）形式传递 2. 可以看到WebSocketFrame 下面有六个子类 3. 浏览器请求时， ws://localhost:7000/xxx 表示请求的uri 4. WebSocketServerProtocolHandler 核心功能是 将 http协议 升级为 ws 协议，保持长链接 */ pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/hello&quot;)); // 自定义的 handler,处理业务逻辑 pipeline.addLast(new MyTextWebSocketFrameHandler()); &#125; &#125;); ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyTextWebSocketFrameHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.fyp.netty.websocket;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import java.time.LocalDateTime;/** * @Auther: fyp * @Date: 2022/2/14 * @Description: * @Package: com.fyp.netty.websocket * @Version: 1.0 */public class MyTextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; System.out.println(&quot;服务端送到消息 &quot; + msg.text()); // 回复消息 ctx.channel().writeAndFlush(new TextWebSocketFrame(&quot;服务器时间&quot; + LocalDateTime.now() + &quot; &quot; + msg.text())); &#125; // 当 客户端连接后， 触发方法 @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; // id 表示 唯一的值 LongText是唯一的 ShortText不是唯一的 System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asLongText()); System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asShortText()); &#125; @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;handlerRemoved 被调用&quot; + ctx.channel().id().asLongText()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(&quot;异常发生 &quot; + cause.getMessage()); &#125;&#125; hello.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var socket; // 判断当前 浏览器 是否支持 webSocket if (window.WebSocket) &#123; // go on // 相当于 channelRead0, ev收到服务器端回送的消息 socket = new WebSocket(&quot;ws://localhost:7000/hello&quot;); socket.onmessage = function (ev) &#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = rt.value + &quot;\\n&quot; + ev.data; &#125; // 相当于 连接开启（感知到连接开启） socket.onopen = function(ev) &#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = &quot;连接开启了...&quot;; &#125; // 相当于 连接关闭（感知到连接关闭） socket.onclose = function (ev) &#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = rt.value + &quot;\\n&quot; + &quot;连接关闭了...&quot;; &#125; &#125; else &#123; alert(&quot;当前浏览器不支持webSocket&quot;) &#125; // 发送消息到服务器 function send(message) &#123; if(!window.socket) &#123; // 先判断 socket 是否创建好 return; &#125; if (socket.readyState == WebSocket.OPEN) &#123; // 通过 socket 发送消息 socket.send(message); &#125; else &#123; alert(&quot;连接没有开启&quot;); &#125; &#125;&lt;/script&gt; &lt;form onsubmit=&quot;return false&quot;&gt; &lt;textarea name=&quot;message&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;button&quot; value=&quot;发送消息&quot; onclick=&quot;send(this.form.message.value)&quot;&gt;&lt;br&gt; &lt;textarea id=&quot;responseText&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;button&quot; value=&quot;请空内容&quot; onclick=&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://fyupeng.github.io/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://fyupeng.github.io/tags/netty/"}],"author":"fyupeng"},{"title":"Netty 入门 - 01","slug":"Netty01","date":"2022-06-25T07:04:05.000Z","updated":"2022-06-25T07:09:26.824Z","comments":true,"path":"2022/06/25/Netty01/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/Netty01/","excerpt":"","text":"一、 Netty简介1. Netty介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github 上的独立项目。 Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。 Netty 主要针对在 TCP 协议下，面向 Client 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。 Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景。 要透彻理解 Netty，需要先学习 NIO，这样我们才能阅读 Netty 的源码。 2. Netty的应用场景互联网行业 互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。 典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框 架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。 游戏行业 游戏行业 协议栈，方便定制和开发私有协议栈，账号登录服务器。 Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器。 地图服务器之间可以方便的通过 Netty 进行高性能的通信。 大数据领域 经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信。 它的 NettyService 基于 Netty 框架二次封装实现。 大数据行业 经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信。 它的 NettyService 基于 Netty 框架二次封装实现。 二、Java BIO编程1. I/O模型 I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。 Java 共支持 3 种网络编程模型 I/O 模式：BIO、NIO、AIO。 Java BIO：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】 Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理。【简单示意图】 Java AIO(NIO.2)：异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。 2. BIO、NIO、AIO使用场景分析 BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。 NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。 3. Java BIO基本介绍 Java BIO 就是传统的 Java I/O 编程，其相关的类和接口在 java.io。 BIO(BlockingI/O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】 BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。 4. Java BIO工作机制 对 BIO 编程流程的梳理 服务器端启动一个 ServerSocket。 客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。 如果有响应，客户端线程会等待请求结束后，再继续执行。 5. Java BIO应用实例实例说明： 使用 BIO 模型编写一个服务器端，监听 6666 端口，当有客户端连接时，就启动一个线程与之通讯。 要求使用线程池机制改善，可以连接多个客户端。 服务器端可以接收客户端发送的数据（telnet 方式即可）。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.fyp.bio;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @Auther: fyp * @Date: 2022/1/31 * @Description: BIO服务 * @Package: com.fyp.bio * @Version: 1.0 */public class BIOServer &#123; public static void main(String[] args) throws IOException &#123; /** * 思路： * 1. 创建一个线程池 * 2. 如果有客户链接，就创建一个线程，与之通讯（单独写一个方法） */ ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); //创建ServerSocket ServerSocket serverSocket = new ServerSocket(6666); System.out.println(&quot;服务器启动了&quot;); while (true) &#123; System.out.println(&quot;等待连接&quot;); //监听，等待客户端链接 final Socket socket = serverSocket.accept(); System.out.println(&quot;连接到一个客户端&quot;); //创建一个线程，与之通讯（单独写一个方法） newCachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; //可以客户端通讯 handler(socket); &#125; &#125;); &#125; &#125; //编写一个handle方法，和客户端通讯 public static void handler(Socket socket) &#123; try &#123; System.out.println(&quot;线程信息 id = &quot; + Thread.currentThread().getId() + &quot; 名字 = &quot; + Thread.currentThread().getName()); byte[] bytes = new byte[10]; //通过Socket获取输入流 InputStream inputStream = socket.getInputStream(); while (true) &#123; System.out.println(&quot;read....&quot;); //没有读到数据会阻塞 int read = inputStream.read(bytes); if(read != -1) &#123; System.out.println(&quot;线程信息 id = &quot; + Thread.currentThread().getId() + &quot; 名字 = &quot; + Thread.currentThread().getName() + &quot; -- &quot; + new String(bytes, 0, read)); &#125; else &#123; System.out.println(&quot;break&quot;); break; &#125; &#125; System.out.println(&quot;跳出read循环&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;关闭和client的连接&quot;); try &#123; socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 6. 总结 每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write。 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。 三、Java NIO编程1. Java NIO基本介绍 Java NIO 全称 Java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO（即 NewIO），是同步非阻塞的。 NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。【基本案例】 NIO 有三大核心部分：**Channel（通道）、Buffer（缓冲区）、Selector（选择器）** 。 NIO 是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。 Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】 通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 10000 个请求过来,根据实际情况，可以分配 50 或者 100 个线程来处理。不像之前的阻塞 IO 那样，非得分配 10000 个。 HTTP 2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了好几个数量级。 2. NIO和BIO的比较 BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多。 BIO 是阻塞的，NIO 则是非阻塞的。 BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。 Buffer和Channel之间的数据流向是双向的 3. NIO三大核心原理示意图一张图描述 NIO 的 Selector、Channel 和 Buffer 的关系。 Selector、Channel 和 Buffer 关系图（简单版）关系图的说明: 每个 Channel 都会对应一个 Buffer。 Selector 对应一个线程，一个线程对应多个 Channel（连接）。 该图反应了有三个 Channel 注册到该 Selector //程序 程序切换到哪个 Channel 是由事件决定的，Event 就是一个重要的概念。 Selector 会根据不同的事件，在各个通道上切换。 Buffer 就是一个内存块，底层是有一个数组。 数据的读取写入是通过 Buffer，这个和 BIO是不同的，BIO 中要么是输入流，或者是输出流，不能双向，但是 NIO 的 Buffer 是可以读也可以写，需要 flip 方法切换 Channel 是双向的，可以返回底层操作系统的情况，比如 Linux，底层的操作系统通道就是双向的。 4. 缓冲区（Buffer）缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，如图:【后面举例说明】 Buffer 类及其子类 在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，类的层级关系图 Buffer 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息： Buffer 类相关方法一览 ByteBuffer从前面可以看出对于 Java 中的基本数据类型（boolean 除外），都有一个 Buffer 类型与之相对应，最常用的自然是 ByteBuffer 类（二进制数据），该类的主要方法如下： 5. 通道(Channel)基本介绍 NIO的通道类似于流，但有些区别如下： 通道可以同时进行读写，而流只能读或者只能写 通道可以实现异步读写数据 通道可以从缓冲读数据，也可以写数据到缓冲: BIO 中的 Stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道（Channel）是双向的，可以读操作，也可以写操作。 Channel 在 NIO 中是一个接口 public interface Channel extends Closeable&#123;&#125; 常用的 Channel 类有：**FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel**。【ServerSocketChanne 类似 ServerSocket、SocketChannel 类似 Socket】 FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。 图示 FileChannel 类FileChannel 主要用来对本地文件进行 IO 操作，常见的方法有 public int read(ByteBuffer dst)，从通道读取数据并放到缓冲区中 public int write(ByteBuffer src)，把缓冲区的数据写到通道中 public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道 public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道 应用实例1 - 本地文件写数据实例要求： 使用前面学习后的 ByteBuffer（缓冲）和 FileChannel（通道），将 “hello,尚硅谷” 写入到 file01.txt 中 文件不存在就创建 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142package com.fyp.nio;import sun.nio.ByteBuffered;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @Auther: fyp * @Date: 2022/2/4 * @Description: 使用Channel写文件 * @Package: com.fyp.nio * @Version: 1.0 */public class NIOFileChannel01 &#123; public static void main(String[] args) throws IOException &#123; String str = &quot;hello,尚硅谷&quot;; //创建一个输出流 -&gt; Channel FileOutputStream fileOutputStream = new FileOutputStream(&quot;d:\\\\file01.txt&quot;); //通过fileOutStream获取对应的 FileChannel //这个fileChannel 的真是类型是 FileChannelImpl FileChannel fileChannel = fileOutputStream.getChannel(); //创建一个缓冲区 ByteBuffer ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //将str放入byteBuffer byteBuffer.put(str.getBytes()); //对byteBuffer 进行flip byteBuffer.flip(); //将byteBuffer写入到 fileChannel fileChannel.write(byteBuffer); fileOutputStream.close(); &#125;&#125; 应用实例2 - 本地文件读数据实例要求： 使用前面学习后的 ByteBuffer（缓冲）和 FileChannel（通道），将 file01.txt 中的数据读入到程序，并显示在控制台屏幕 假定文件已经存在 代码演示 12345678910111213141516171819202122232425262728293031323334353637package com.fyp.nio;import com.sun.xml.internal.fastinfoset.stax.events.AttributeBase;import java.io.*;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @Auther: fyp * @Date: 2022/2/4 * @Description: 使用Channel读文件 * @Package: com.fyp.nio * @Version: 1.0 */public class NIOFileChannel02 &#123; public static void main(String[] args) throws IOException &#123; //创建文件输入流 File file = new File(&quot;d:\\\\file01.txt&quot;); FileInputStream fileInputStream = new FileInputStream(file); //通过fileInputStream获取对应的FileChannel -&gt; 实际类型 FileChannelImpl FileChannel fileChannel = fileInputStream.getChannel(); //创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); //将通道的数据读入到Buffer fileChannel.read(byteBuffer); //将 byteBuffer 的字节数据转成 String System.out.println(new String(byteBuffer.array())); fileInputStream.close(); &#125;&#125; 应用实例3 - 使用一个 Buffer 完成文件读取、写入实例要求： 使用 FileChannel（通道）和方法 read、write，完成文件的拷贝 拷贝一个文本文件 1.txt，放在项目下即可 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.fyp.nio;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @Auther: fyp * @Date: 2022/2/4 * @Description: 使用Channel读写文件 * @Package: com.fyp.nio * @Version: 1.0 */public class NIOFileChannel03 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fileInputStream = new FileInputStream(&quot;1.txt&quot;); FileChannel fileChannel01 = fileInputStream.getChannel(); FileOutputStream fileOutputStream = new FileOutputStream(&quot;2.txt&quot;); FileChannel fileChannel02 = fileOutputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate(512); while (true) &#123; //循环读数 /* public final Buffer clear() &#123; this.position = 0; this.limit = this.capacity; this.mark = -1; return this; &#125; */ byteBuffer.clear(); int read = fileChannel01.read(byteBuffer); System.out.println(&quot;read= &quot; + read); if (read == -1) &#123; //表示读完 break; &#125; //将buffer 中的数据 写入到 fileChannel02 --- 2.txt byteBuffer.flip(); fileChannel02.write(byteBuffer); &#125; fileInputStream.close(); &#125;&#125; 应用实例4 - 拷贝文件 transferFrom 方法 实例要求： 使用 FileChannel（通道）和方法 transferFrom，完成文件的拷贝 拷贝一张图片 代码演示 12345678910111213141516171819202122232425262728293031323334package com.fyp.nio;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;/** * @Auther: fyp * @Date: 2022/2/4 * @Description: 拷贝文件-transferFrom方法 * @Package: com.fyp.nio * @Version: 1.0 */public class NIOFileChannel04 &#123; public static void main(String[] args) throws IOException &#123; //创建输入流和输出流 FileInputStream fileInputStream = new FileInputStream(&quot;d:\\\\wallhaven.png&quot;); FileOutputStream fileOutputStream = new FileOutputStream(&quot;d:\\\\wallhaven01.png&quot;); //获取各个流对应的Channel FileChannel sourceCh = fileInputStream.getChannel(); FileChannel destCh = fileOutputStream.getChannel(); //使用transferFrom完成拷贝 destCh.transferFrom(sourceCh, 0, sourceCh.size()); //关闭相关通道和流 sourceCh.close(); destCh.close(); fileInputStream.close(); fileOutputStream.close(); &#125;&#125; 关于 Buffer 和 Channel 的注意事项和细节 ByteBuffer 支持类型化的 put 和 get，put 放入的是什么数据类型，get 就应该使用相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。【举例说明】 12345678910111213141516171819202122232425262728293031323334353637package com.fyp.nio;import java.nio.Buffer;import java.nio.ByteBuffer;/** * @Auther: fyp * @Date: 2022/2/4 * @Description: * @Package: com.fyp.nio * @Version: 1.0 */public class NIOByteBufferPutGet &#123; public static void main(String[] args) &#123; //创建一个Buffer ByteBuffer byteBuffer = ByteBuffer.allocate(64); //类型化操作放入数据 byteBuffer.putInt(100); byteBuffer.putLong(9); byteBuffer.putChar(&#x27;尚&#x27;); byteBuffer.putShort((short) 4); //取出 byteBuffer.flip(); System.out.println(); //按通道顺序获取,因为获取会移动position //而获取的数据是从position出发的，根据获取的get类型来定量position移动 System.out.println(byteBuffer.getInt()); System.out.println(byteBuffer.getLong()); System.out.println(byteBuffer.getChar()); System.out.println(byteBuffer.getShort()); &#125;&#125; 可以将一个普通 Buffer 转成只读 Buffer【举例说明】 1234567891011121314151617181920212223242526272829303132333435363738package com.fyp.nio;import java.nio.Buffer;import java.nio.ByteBuffer;/** * @Auther: fyp * @Date: 2022/2/4 * @Description: * @Package: com.fyp.nio * @Version: 1.0 */public class ReadOnlyBuffer &#123; public static void main(String[] args) &#123; //创建一个Buffer ByteBuffer byteBuffer = ByteBuffer.allocate(64); for (int i = 0; i &lt; 64; i++) &#123; byteBuffer.put((byte) i); &#125; //读取 byteBuffer.flip(); //得到一个只读Buffer ByteBuffer readOnlyBuffer = byteBuffer.asReadOnlyBuffer(); System.out.println(readOnlyBuffer.getClass()); //读取 while (readOnlyBuffer.hasRemaining()) &#123; System.out.println(readOnlyBuffer.get()); &#125; //会抛出 ReadOnlyBufferException 异常 //readOnlyBuffer.put((byte) 100); &#125;&#125; NIO 还提供了 MappedByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 NIO 来完成。【举例说明】 1234567891011121314151617181920212223242526272829303132333435363738394041package com.fyp.nio;import java.io.RandomAccessFile;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;/** * @Auther: fyp * @Date: 2022/2/5 * @Description: 直接修改内存 * @Package: com.fyp.nio * @Version: 1.0 *//*说明：1. MappedByteBuffer 可让文件直接在内存修改，操作系统不需要拷贝一次 */public class MappedByteBufferTest &#123; public static void main(String[] args) throws Exception &#123; RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;); FileChannel channel = randomAccessFile.getChannel(); /** * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式 * 参数2: 0: 可以直接修改的初始位置 * 参数3: 5: 是映射到内存的大小，即将 1.txt 的多少个字节映射到内存 * 可以直接修改的范围就是 0-5 */ MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5); mappedByteBuffer.put(0, (byte) &#x27;H&#x27;); mappedByteBuffer.put(3, (byte) &#x27;9&#x27;); //会抛出 IndexOutOfBoundsException 异常 //mappedByteBuffer.put(5, (byte) &#x27;Y&#x27;); randomAccessFile.close(); &#125;&#125; 前面我们讲的读写操作，都是通过一个 Buffer 完成的，NIO 还支持通过多个 Buffer（即 Buffer数组）完成读写操作，即 Scattering 和 Gathering【举例说明】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.fyp.nio;/** * @Auther: fyp * @Date: 2022/2/5 * @Description: Scatter和Gather的使用 * @Package: com.fyp.nio * @Version: 1.0 */import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Arrays;/** * Scattering: 将数据写入到buffer时，可以 采用buffer数组，依次写入[分散] * Gathering: 从buffer读取数据时，可以 采用buffer数组，依次读 */public class ScatteringAndGatheringTest &#123; public static void main(String[] args) throws Exception&#123; //使用ServerSocketChannel 和 SocketChannel 网络 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); InetSocketAddress inetSocketAddress = new InetSocketAddress(7000); //绑定端口到socket, 并启动 serverSocketChannel.socket().bind(inetSocketAddress); ByteBuffer[] byteBuffers = new ByteBuffer[2]; byteBuffers[0] = ByteBuffer.allocate(5); byteBuffers[1] = ByteBuffer.allocate(3); //等待客户端连接 (telnet) SocketChannel socketChannel = serverSocketChannel.accept(); int messageLength = 8; //循环地读数 while (true) &#123; int byteRead = 0; while (byteRead &lt; messageLength) &#123; long l = socketChannel.read(byteBuffers); byteRead += l;//累计读取的字节数 System.out.println(&quot;byteRead= &quot; + byteRead); //使用流打印，查看当前的这个buffer的position 和 limit Arrays.asList(byteBuffers).stream().map(buffer -&gt; &quot;position= &quot; + buffer.position() + &quot;,limit= &quot; + buffer.limit()).forEach(System.out::println); &#125; //将所有的buffer 进行 flip Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip()); //将数据读出显示到客户端 long byteWrite = 0; while (byteWrite &lt; messageLength) &#123; long l = socketChannel.write(byteBuffers); byteWrite += 1; &#125; //将所有的 buffer 进行 clear Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123; buffer.clear(); &#125;); System.out.println(&quot;byteRead= &quot; + byteRead + &quot;,byteWrite= &quot; + byteWrite + &quot;,messageLength= &quot; + messageLength); &#125; &#125;&#125; 6. 选择器（Selector）基本介绍 Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector（选择器）。 Selector 能够检测多个注册的通道上是否有事件发生（注意：多个 Channel 以事件的方式可以注册到同一个 Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。 只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。 避免了多线程之间的上下文切换导致的开销。 Selector 示意图和特点说明 说明如下： Netty 的 IO 线程 NioEventLoop 聚合了 Selector（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。 当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。 线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。 由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。 一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。 Selector 类相关方法 注意事项 NIO 中的 ServerSocketChannel 功能类似 ServerSocket、SocketChannel 功能类似 Socket。 Selector相关方法说明 selector.select(); //阻塞 selector.select(1000); //阻塞 1000 毫秒，在 1000 毫秒后返回 selector.wakeup(); //唤醒 selector selector.selectNow(); //不阻塞，立马返还 7. NIO非阻塞网络编程原理分析图NIO 非阻塞网络编程相关的（Selector、SelectionKey、ServerScoketChannel 和 SocketChannel）关系梳理图 对上图的说明： 当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel。 Selector 进行监听 select 方法，返回有事件发生的通道的个数。 将 socketChannel 注册到 Selector 上，register(Selector sel, int ops)，一个 Selector 上可以注册多个 SocketChannel。 注册后返回一个 SelectionKey，会和该 Selector 关联（集合）。 进一步得到各个 SelectionKey（有事件发生）。 在通过 SelectionKey 反向获取 SocketChannel，方法 channel()。 可以通过得到的 channel，完成业务处理。 直接看后面代码吧 8. NIO非阻塞网络编程快速入门案例： 编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞） 目的：理解 NIO 非阻塞网络编程机制 服务端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.fyp.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Iterator;import java.util.Set;/** * @Auther: fyp * @Date: 2022/2/5 * @Description: NIO服务器 * @Package: com.fyp.nio * @Version: 1.0 */public class NIOServer &#123; public static void main(String[] args) throws IOException &#123; //创建ServerSocketChannel -&gt; ServerSocket ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //得到一个Selector对象 Selector selector = Selector.open(); //绑定一个端口6666，在服务端监听 serverSocketChannel.socket().bind(new InetSocketAddress(6666)); //设置为非阻塞 serverSocketChannel.configureBlocking(false); //把 serverSocketChannel 注册到 selector, 关注事件 为 OP_ACCEPT serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //循环等待客户端连接 while (true) &#123; //这里我们等待1秒，如果没有事件发生（连接事件） if (selector.select(1000) == 0) &#123;//没有事件发生 System.out.println(&quot;服务器等待了1秒，无连接&quot;); continue; &#125; //如果返回的 &gt; 0, 就获取到相关的 selectionKey集合 //1. 如果返回的 &gt; 0, 表示已经获取到关注的事件 //2. selector.selectedKeys() 返回关注事件的集合 //通过 selectionKeys 反向获取通道 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); //遍历 Set&lt;SelectionKey&gt;, 使用迭代器 Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator(); while (keyIterator.hasNext()) &#123; //获取到selectionKey SelectionKey key = keyIterator.next(); //根据key 对应的通道发生的事件做相应处理 if (key.isAcceptable()) &#123; //如果是OP_ACCEPT, 表示新的客户端连接 //给该客户端生成一个 SocketChannel SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(&quot;客户端连接成功！生成了一个socketChannel &quot; + socketChannel.hashCode()); //将 SocketChannel 设置为非阻塞 socketChannel.configureBlocking(false); //将socketChannel注册到 selector上, 关注事件为OP_READ, 同时给socketChannel //关联一个Buffer socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024)); &#125; if (key.isReadable()) &#123; //发生OP_READ // 通过key 反向获取对应的channel SocketChannel channel = (SocketChannel) key.channel(); //获取该channel关联的 buffer,在与客户端连接就已经创建好了 ByteBuffer buffer = (ByteBuffer) key.attachment(); channel.read(buffer); System.out.println(&quot;from 客户端： &quot; + new String(buffer.array())); &#125; //手动从集合中移动当前的selectionKey, 防止重复操作 keyIterator.remove(); &#125; &#125; &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.fyp.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/6 * @Description: 客户端 * @Package: com.fyp.nio * @Version: 1.0 */public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; //得到一个网络通道 SocketChannel socketChannel = SocketChannel.open(); //设置非阻塞 socketChannel.configureBlocking(false); //提供服务端的 ip 和 端口 InetSocketAddress inetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666); /* 连接服务器 1. 为非阻塞模式时，即不会等到方法执行完毕再返回，会立即返回，如果返回前已经连接成功，则返回true 返回false 时，说明未连接成功，所以需要再通过while循环地finishConnect()完成最终的连接 2. 为阻塞模式时，直到连接建立或抛出异常 不会返回false，连接不上就抛异常，不需要借助finishConnect() */ if (!socketChannel.connect(inetSocketAddress)) &#123; while (!socketChannel.finishConnect()) &#123; System.out.println(&quot;因为连接需要时间，客户端不会阻塞，可以做其他工作&quot;); &#125; &#125; //如果连接成功，就发送数据 String str = &quot;hello, 尚硅谷&quot;; ByteBuffer buffer = ByteBuffer.wrap(str.getBytes()); //发送数据，将buffer 写入 channel socketChannel.write(buffer); System.in.read(); &#125;&#125; SelectionKey SelectionKey，表示Selector和网络通道的注册关系，共四种： int OP_ACCEPT：有新的网络连接可以 accept，值为 16 int OP_CONNECT：代表连接已经建立，值为 8 int OP_READ：代表读操作，值为 1 int OP_WRITE：代表写操作，值为 4 源码中： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4; SelectionKey 相关方法 ServerSocketChannel ServerSocketChannel 在服务器端监听新的客户端 Socket 连接，负责监听，不负责实际的读写操作 相关方法如下 SocketChannel SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。 相关方法如下 9. NIO网络编程应用实例-群聊系统实例要求： 编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞） 实现多人群聊 服务器端：可以监测用户上线，离线，并实现消息转发功能 客户端：通过 Channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（由服务器转发得到） 目的：进一步理解 NIO 非阻塞网络编程机制 示意图分析和代码 服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.fyp.nio.groupchat;import java.io.IOException;import java.net.InetSocketAddress;import java.net.Socket;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Iterator;/** * @Auther: fyp * @Date: 2022/2/6 * @Description: 群聊系统服务端 * @Package: com.fyp.nio.groupchat * @Version: 1.0 */public class GroupChatServer &#123; private Selector selector; private ServerSocketChannel listenChannel; private static final int PORT = 6667; public GroupChatServer() &#123; try &#123; selector = Selector.open(); listenChannel = ServerSocketChannel.open(); listenChannel.socket().bind(new InetSocketAddress(PORT)); listenChannel.configureBlocking(false); listenChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void listen() &#123; try &#123; while (true) &#123; // count 获取的是 在阻塞过程中 同时发生的 事件 数，直到有事件 发生，才会执行，否则一直阻塞 /* select 方法在 没有 客户端发起连接时， 会一直阻塞，至少有一个客户端连接，其他 客户端再 发起连接 不再阻塞，会立即返回 */ int count = selector.select(); System.out.println(count); if(count &gt; 0) &#123;// 有事件 处理 // 遍历得到 SelectionKey 集合 Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; //取出SelectionKey SelectionKey key = iterator.next(); //监听到accept if (key.isAcceptable()) &#123; SocketChannel sc = listenChannel.accept(); // 监听到 客户端 的 SocketChannel 总是默认为阻塞方式，需要重新设置 sc.configureBlocking(false); //将该 sc 注册到 selector sc.register(selector, SelectionKey.OP_READ); System.out.println(sc.getRemoteAddress() + &quot; 上线 &quot;); &#125; if (key.isReadable()) &#123; // 通道发送 read 事件， 即通道是可读状态 //处理读 readData(key); &#125; /* 每次 监听到 客户端后， selector会将 连接上的 客户端 选中， 并添加到 selectionKeys 中 要注册到 selector 上，使用该方法，selector 将 不再选中 如果没有移除，selector 不能选中 其他的 客户端连接 iterator.remove() 移除后，将释放 selector 中的 selectionKeys */ iterator.remove(); &#125; &#125; else &#123; //System.out.println(&quot;等待....&quot;); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 发送异常处理 &#125; &#125; public void readData(SelectionKey key) &#123; // 取到关联的 channel SocketChannel channel = null; try &#123; // 得到 channel channel = (SocketChannel) key.channel(); // 创建buffer ByteBuffer buffer = ByteBuffer.allocate(1024); int count = channel.read(buffer); // 根据 count 的值 做 处理 if (count &gt; 0) &#123; // 把 缓冲区 的 数据 转成 字符串 String msg = new String(buffer.array()); // 输出该消息 System.out.println(&quot;from 客户端： &quot; + msg); //想其他客户端转发消息，专门写一个方法来处理 sendInfoToOtherClients(msg, channel); &#125; &#125; catch (IOException e) &#123; //e.printStackTrace(); try &#123; System.out.println(channel.getRemoteAddress() + &quot;离线了&quot;); // 取消 注册 key.cancel(); // 关闭通道 channel.close(); &#125; catch (IOException ioException) &#123; ioException.printStackTrace(); &#125; &#125; &#125; // 转发消息给其他客户端（通道） private void sendInfoToOtherClients(String msg, SocketChannel self) throws IOException &#123; System.out.println(&quot;服务器转发消息中....&quot;); // 遍历所有 注册到 selector 上 的 SockChannel, 并排除 self for (SelectionKey key : selector.keys()) &#123; // 通过 key 取出 对应的 SocketChannel Channel targetChannel = key.channel(); // 排除自己 if (targetChannel instanceof SocketChannel &amp;&amp; targetChannel != self) &#123; // 转型 SocketChannel dest = (SocketChannel) targetChannel; // 将 msg 存储到 buffer ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes()); // 将 buffer 的数据 写入 通道 dest.write(buffer); &#125; &#125; &#125; public static void main(String[] args) &#123; // 创建 服务器 对象 GroupChatServer groupChatServer = new GroupChatServer(); groupChatServer.listen(); &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.fyp.nio.groupchat;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;/** * @Auther: fyp * @Date: 2022/2/7 * @Description: 群聊系统客户端 * @Package: com.fyp.nio.groupchat * @Version: 1.0 */public class GroupChatClient &#123; //定义 相关 属性 private final String HOST = &quot;127.0.0.1&quot;; private final int PORT = 6667; private Selector selector; private SocketChannel socketChannel; private String username; // 构造器，完成初始化工作 public GroupChatClient() throws IOException &#123; selector = Selector.open(); // 连接 服务器 socketChannel = socketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT)); // 设置 非阻塞 socketChannel.configureBlocking(false); // 将 channel 注册到 selector socketChannel.register(selector, SelectionKey.OP_READ); // 得到 username username = socketChannel.getLocalAddress().toString().substring(1); System.out.println(username + &quot; is ok....&quot;); &#125; // 向 服务器 发送 消息 public void sendInfo(String info) &#123; info = username + &quot; 说：&quot; + info; try &#123; socketChannel.write(ByteBuffer.wrap(info.getBytes())); &#125; catch (Exception e) &#123; &#125; &#125; // 读取从 服务器 端 回复的 消息 public void readInfo() &#123; try &#123; int readChannels = selector.select(); if (readChannels &gt; 0) &#123;// 有可以用的 通道 Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; SelectionKey key = iterator.next(); if (key.isReadable()) &#123; // 得到 相关的 通道 SocketChannel sc = (SocketChannel) key.channel(); // 得到一个 Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); // 读取 sc.read(buffer); // 把缓存区的数据 转成 字符串 String msg = new String(buffer.array()); System.out.println(msg.trim()); &#125; &#125; iterator.remove();// 删除当前的selectionKey, 防止重复操作, 没有删除，直接影响到selector.select() &#125; else &#123; //System.out.println(&quot;没有可以用的通道....&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws IOException &#123; // 启动 客户端 GroupChatClient chatClient = new GroupChatClient(); // 启动一个线程，每隔3秒， 读取从 服务器 发送过来的数据 new Thread() &#123; @Override public void run() &#123; while (true) &#123; chatClient.readInfo(); try &#123; Thread.currentThread().sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); // 发送数据给 服务端 Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; String s = scanner.nextLine(); chatClient.sendInfo(s); &#125; &#125;&#125; 10. NIO与零拷贝零拷贝之传统文件IO场景：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。 很明显发生了4次拷贝 第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝是通过 DMA 的。 第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是应用程序就可以使用这部分数据了，这个拷贝是由 CPU 完成的。 第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然由 CPU 完成的。 第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到协议栈里，这个过程又是由 DMA 完成的。发生了4次用户上下文切换，因为发生了两个系统调用read和write。一个系统调用对应两次上下文切换，所以上下文切换次数在一般情况下只可能是偶数。 想要优化文件传输的性能就两个方向 减少上下文切换次数 减少数据拷贝次数 因为这两个是最耗时的 零拷贝之mmapread() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。mmap() 系统调用函数会直接把内核缓冲区里的数据映射到用户空间，这样，操作系统内核与用户空间共享缓冲区，就不需要再进行任何的数据拷贝操作。 总的来说mmap减少了一次数据拷贝，总共4次上下文切换，3次数据拷贝 零拷贝之sendfileLinux2.1 版本提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 SocketBuffer 总的来说有2次上下文切换，3次数据拷贝。 sendfile再优化Linux在2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socketbuffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝 mmap 和 sendFile 的区别（1）mmap 适合小数据量读写，sendFile 适合大文件传输。 （2）mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。 （3）sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket缓冲区）。 NIO 零拷贝案例案例要求： 使用传统的 IO 方法传递一个大文件 使用 NIO 零拷贝方式传递（transferTo）一个大文件 看看两种传递方式耗时时间分别是多少 传统拷贝方式服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.fyp.nio.zerocopy;import java.io.DataInputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @Auther: fyp * @Date: 2022/2/9 * @Description: 传统IO服务端 * @Package: com.fyp.nio.zerocopy * @Version: 1.0 */public class OldIOServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(7001); while (true) &#123; Socket socket = serverSocket.accept(); DataInputStream dataInputStream = new DataInputStream(socket.getInputStream()); try &#123; byte[] byteArray = new byte[4096]; while (true) &#123; int readCount = dataInputStream.read(byteArray, 0, byteArray.length); if (-1 == readCount) &#123; break; &#125; System.out.println(&quot;读取字节数： &quot; + readCount); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.fyp.nio.zerocopy;import java.io.*;import java.net.Socket;/** * @Auther: fyp * @Date: 2022/2/9 * @Description: 传统IO客户端 * @Package: com.fyp.nio.zerocopy * @Version: 1.0 */public class OldIOClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;localhost&quot;, 7001); String fileName = &quot;aiXcoder-3.3.1-2020.zip&quot;; InputStream inputStream = new FileInputStream(fileName); DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream()); byte[] buffer = new byte[4096]; long readCount; long total = 0; long startTime = System.currentTimeMillis(); while ((readCount = inputStream.read(buffer)) &gt; 0) &#123; total += readCount; dataOutputStream.write(buffer, 0 , (int) readCount); &#125; System.out.println(&quot;发送总字节数： &quot; + total + &quot;, 耗时： &quot; + (System.currentTimeMillis() - startTime)); dataOutputStream.close(); socket.close(); inputStream.close(); &#125;&#125; NIO拷贝方式服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fyp.nio.zerocopy;import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/9 * @Description: 新IO服务端 * @Package: com.fyp.nio.zerocopy * @Version: 1.0 */public class NewIOServer &#123; public static void main(String[] args) throws IOException &#123; InetSocketAddress inetSocketAddress = new InetSocketAddress(7001); ServerSocketChannel serverSockChannel = ServerSocketChannel.open(); ServerSocket serverSocket = serverSockChannel.socket(); serverSocket.bind(inetSocketAddress); // 创建 buffer ByteBuffer buffer = ByteBuffer.allocate(4096); while (true) &#123; SocketChannel socketChannel = serverSockChannel.accept(); int readCount = 0; while (-1 != readCount) &#123; try &#123; readCount = socketChannel.read(buffer); &#125; catch (Exception e) &#123; //e.printStackTrace(); break; &#125; // buffer.rewind(); // 倒带 position = 0 , mark 作废 &#125; &#125; &#125;&#125; 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.fyp.nio.zerocopy;import java.io.FileInputStream;import java.io.IOException;import java.net.InetSocketAddress;import java.net.Socket;import java.nio.channels.FileChannel;import java.nio.channels.SocketChannel;/** * @Auther: fyp * @Date: 2022/2/9 * @Description: 新IO客户端 * @Package: com.fyp.nio.zerocopy * @Version: 1.0 */public class NewIOClient &#123; public static void main(String[] args) throws IOException &#123; SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 7001)); String filename = &quot;aiXcoder-3.3.1-2020.zip&quot;; // 得到 一个 文件 channel FileChannel fileChannel = new FileInputStream(filename).getChannel(); // 准备 发送 long startTime = System.currentTimeMillis(); // 在 linux 的 下一个 transferTo 方法就可以 完成 传输 // 在 windows 下一次 调用 transferTo 只能发送 8M // 需要 分段 传输文件，而且 主要 传输时 的位置 transferTo 底层用到零拷贝 long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel); System.out.println(&quot;发送总字节数： &quot; + transferCount + &quot;, 耗时： &quot; + (System.currentTimeMillis() - startTime)); fileChannel.close(); &#125;&#125; 三、Java AIO介绍1. AIO基本介绍 JDK7 引入了 AsynchronousI/O，即 AIO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理 AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用 目前 AIO 还没有广泛应用，Netty 也是基于 NIO，而不是 AIO，因此我们就不详解 AIO 了，有兴趣的同学可以参考《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》 2. BIO、NIO、AIO对比表 BIO NIO AIO IO模型 同步阻塞 同步非阻塞（多路复用） 异步非阻塞 编程难度 简单 复杂 复杂 可靠性 差 好 好 吞吐量 低 高 高 举例说明 同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。 同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己. 异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发 漫画讲IO","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://fyupeng.github.io/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://fyupeng.github.io/tags/netty/"}],"author":"fyupeng"},{"title":"二分查找","slug":"二分查找","date":"2022-06-25T06:45:22.000Z","updated":"2022-06-25T07:00:01.526Z","comments":true,"path":"2022/06/25/二分查找/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"1. 矩阵1.1 1351. 统计有序矩阵中的负数给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。 示例1： 123输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]输出：8解释：矩阵中共有 8 个负数。 示例2： 12输入：grid = [[3,2],[1,0]]输出：0 12345678910111213141516171819202122class Solution &#123; public int countNegatives(int[][] grid) &#123; int count = 0; for(int i = 0 ; i &lt; grid.length; i++) &#123; count += countRowNegatives(grid[i]); &#125; return count; &#125; private int countRowNegatives(int[] row) &#123; int left = 0; int right = row.length; while(left &lt; right) &#123; int mid = left + (right - left) / 2; if(row[mid] &gt;= 0) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return row.length - 1 - left + 1; &#125;&#125; 1.2 74. 搜索二维矩阵编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。 示例1： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true 示例2： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false 提示： m == matrix.lengthn == matrix[i].length1 &lt;= m, n &lt;= 100-104 &lt;= matrix[i] [j], target &lt;= 104 1234567891011121314151617181920212223class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; // 二维 变 一维 // col + row = res // 1 * 4 + 1 = 5 -- 5 / 4 = 1 -- 5 % 4 = 1 int left = 0; int col = matrix[0].length; int row = matrix.length; int right = row * col; while(left &lt; right) &#123; int mid = left + (right - left) / 2; if(matrix[mid / col][mid % col] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; if(left &lt; row * col &amp;&amp; target == matrix[left / col][left % col]) &#123; return true; &#125; return false; &#125;&#125; 1.3 1337. 矩阵中战斗力最弱的 K 行给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例1： 12345678910111213141516输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3输出：[2,0,3]解释：每行中的军人数目：行 0 -&gt; 2 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 2 行 4 -&gt; 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] ​ 示例2： 1234567891011121314输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2输出：[0,2]解释： 每行中的军人数目：行 0 -&gt; 1 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 提示： m == mat.lengthn == mat[i].length2 &lt;= n, m &lt;= 1001 &lt;= k &lt;= mmatrix[i] [j] 不是 0 就是 1 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; mat.length; i++) &#123; int left = 0; int right = mat[i].length; while(left &lt; right) &#123; int mid = left + (right - left) / 2; if(mat[i][mid] == 1) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; // 下标0 表示 军人 数 -- 下标1 表示 索引 list.add(new int[]&#123;left, i&#125;); &#125; PriorityQueue&lt;int[]&gt; heap = new PriorityQueue(new Comparator &lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; if (o1[0] != o2[0]) &#123; return o1[0] - o2[0]; &#125; else &#123; return o1[1] - o2[1]; &#125; &#125; &#125;); for(int i = 0; i &lt; list.size(); i++) &#123; heap.offer(list.get(i)); &#125; int[] res = new int[k]; for(int i = 0; i &lt; k; i++) &#123; res[i] = heap.poll()[1]; &#125; return res; &#125;&#125; 1.4 1346. 检查整数及其两倍数是否存在给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j0 &lt;= i, j &lt; arr.lengtharr[i] == 2 * arr[j] 示例1： 123输入：arr = [10,2,5,3]输出：true解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。 示例2： 123输入：arr = [7,1,14,11]输出：true解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。 示例3： 123输入：arr = [3,1,7,11]输出：false解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。 提示： 2 &lt;= arr.length &lt;= 500-10^3 &lt;= arr[i] &lt;= 10^3 1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean checkIfExist(int[] arr) &#123; Arrays.sort(arr); int poAndNaLine = binarySearch(arr, 0, arr.length, 0); // 处理负数 for(int i = poAndNaLine - 1; i &gt;= 0; i--) &#123; int res = binarySearch(arr, 0, i, arr[i] * 2); if(res &lt; arr.length &amp;&amp; arr[res] == arr[i] * 2) &#123; return true; &#125; &#125; // 处理 正数 for(int i = poAndNaLine; i &lt; arr.length; i++) &#123; int res = binarySearch(arr, i + 1, arr.length, arr[i] * 2); if(res &lt; arr.length &amp;&amp; arr[res] == arr[i] * 2) &#123; return true; &#125; &#125; return false; &#125; private int binarySearch(int[] arr, int left, int right, int target) &#123; while(left &lt; right) &#123; int mid = left + (right - left) / 2; if(arr[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left; &#125;&#125;","categories":[{"name":"leetCode算法","slug":"leetCode算法","permalink":"http://fyupeng.github.io/categories/leetCode%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://fyupeng.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}],"author":"fyupeng"},{"title":"二叉树","slug":"二叉树","date":"2022-06-25T06:45:14.000Z","updated":"2022-06-25T07:00:55.547Z","comments":true,"path":"2022/06/25/二叉树/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"1. 144. 二叉树的前序遍历问题给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例1： 12输入：root = [1,null,2,3]输出：[1,2,3] 示例2： 12输入：root = []输出：[] 示例3： 12输入：root = [1]输出：[1] 示例4： 12输入：root = [1,2]输出：[1,2] 示例5： 12输入：root = [1,null,2]输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 代码 迭代法 123456789101112131415class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root != null) stack.push(root); while(!stack.empty()) &#123; TreeNode cur = stack.pop(); res.add(cur.val); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); &#125; return res; &#125;&#125; 递归法 123456789101112131415class Solution &#123; private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; traversal(root); return res; &#125; private void traversal(TreeNode root) &#123; if(root == null) &#123; return; &#125; res.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); &#125;&#125; 统一迭代法 1234567891011121314151617181920212223242526// 空指针来标记 已访问的节点class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null) &#123; return res; &#125; stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); stack.push(node); stack.push(null); &#125; else &#123; stack.pop(); node = stack.pop(); res.add(node.val); &#125; &#125; return res; &#125;&#125; 2. 94. 二叉树的中序遍历问题给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例1： 12输入：root = [1,null,2,3]输出：[1,3,2] 示例2： 12输入：root = []输出：[] 示例3： 12输入：root = [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 代码 迭代法 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; // 刚开始 循环 有 cur 来保证，后面由 stack 是否为空 来保证（当然访问中间的时候不需要借助 empty()方法 性能有所提高） while(cur != null || !stack.empty()) &#123; if(cur != null) &#123; stack.push(cur); cur = cur.left; &#125; else &#123; cur = stack.pop(); res.add(cur.val); cur = cur.right; &#125; &#125; return res; &#125;&#125; 递归法 123456789101112131415class Solution &#123; private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; traversal(root); return res; &#125; private void traversal(TreeNode root) &#123; if(root == null) &#123; return; &#125; traversal(root.left); res.add(root.val); traversal(root.right); &#125;&#125; 统一迭代法 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null) &#123; return res; &#125; stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); if(node.right != null) stack.push(node.right); stack.push(node); stack.push(null); if(node.left != null) stack.push(node.left); &#125; else &#123; stack.pop(); node = stack.pop(); res.add(node.val); &#125; &#125; return res; &#125;&#125; 3. 145. 二叉树的后序遍历问题给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例1： 12输入：root = [1,null,2,3]输出：[3,2,1] 示例2： 12输入：root = []输出：[] 示例3： 12输入：root = [1]输出：[1] 提示： 树中节点的数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 代码 迭代法 12345678910111213141516class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root != null) stack.push(root); while(!stack.empty()) &#123; TreeNode cur = stack.pop(); res.add(cur.val); if(cur.left != null) stack.push(cur.left); if(cur.right != null) stack.push(cur.right); &#125; Collections.reverse(res); return res; &#125;&#125; 递归法 123456789101112131415class Solution &#123; private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; traversal(root); return res; &#125; private void traversal(TreeNode root) &#123; if(root == null) &#123; return; &#125; traversal(root.left); traversal(root.right); res.add(root.val); &#125;&#125; 统一迭代法 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null) &#123; return res; &#125; stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); stack.push(node); stack.push(null); if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); &#125; else &#123; stack.pop(); node = stack.pop(); res.add(node.val); &#125; &#125; return res; &#125;&#125; 4. 102. 二叉树的层序遍历问题给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例2： 12输入：root = [1]输出：[[1]] 示例3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 代码1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null) &#123; return res; &#125; queue.offer(root); while(!queue.isEmpty()) &#123; int size = queue.size(); while(size-- &gt; 0) &#123; TreeNode node = queue.poll(); tempList.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; res.add(new ArrayList&lt;&gt;(tempList)); tempList.clear(); &#125; return res; &#125;&#125; 5. 226. 翻转二叉树问题给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 示例2： 12输入：root = [2,1,3]输出：[2,3,1] 示例3： 12输入：root = []输出：[] 代码递归和迭代前序遍历和后序可以实现，但中序只能用迭代，用递归不可以是因为父节点翻转后还去翻转已翻转的子节点，导致有些节点没翻转，有些节点翻转两次 但假中序递归可以实现 123invertTree(root-&gt;left); // 左swap(root-&gt;left, root-&gt;right); // 中invertTree(root-&gt;left); // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了 递归法 1234567891011121314151617181920class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root == null) &#123; return root; &#125; invert(root); return root; &#125; private void invert(TreeNode root) &#123; if(root == null) &#123; return; &#125; // 后序遍历的 思想翻转，由下往上 invert(root.left); invert(root.right); TreeNode node = root.left; root.left = root.right; root.right = node; &#125;&#125; 迭代法 1234567891011121314151617181920// 前序遍历 从上往下 翻转class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null) &#123; return root; &#125; stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.pop(); TreeNode tempNode = node.left; node.left = node.right; node.right = tempNode; if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); &#125; return root; &#125;&#125; 6. 101. 对称二叉树问题给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例2： 12输入：root = [1,2,2,null,3,null,3] 输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100 代码 递归法 123456789101112131415161718192021class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return compare(root.left, root.right); &#125; private boolean compare(TreeNode left, TreeNode right) &#123; if(left == null &amp;&amp; right != null) &#123; return false; &#125; else if(left != null &amp;&amp; right == null) &#123; return false; &#125; else if(left == null &amp;&amp; right == null) &#123; return true; &#125; else if(left.val != right.val) &#123; return false; &#125; boolean outside = compare(left.left, right.right); boolean inside = compare(left.right, right.left); boolean isSame = outside &amp;&amp; inside; return isSame; &#125;&#125; 迭代法 123456789101112131415161718192021222324252627class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null) &#123; return true; &#125; queue.offer(root.left); queue.offer(root.right); while(!queue.isEmpty()) &#123; TreeNode leftNode = queue.poll(); TreeNode rightNode = queue.poll(); // leftNode 和 rightNode 都为空 if(leftNode == null &amp;&amp; rightNode == null) &#123; continue; &#125; // leftNode 和 rightNode 有一个 为空，否则两个都不为空时，两者下标的 值不同 if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) &#123; return false; &#125; queue.offer(leftNode.left); queue.offer(rightNode.right); queue.offer(leftNode.right); queue.offer(rightNode.left); &#125; return true; &#125;&#125; 7. 104. 二叉树的最大深度问题给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 12345678910graph TBA((3))B((9))C((20))D((15))E((7))A --- BA --- CC --- DC --- E 返回它的最大深度 3 。 代码 前序遍历回溯法 12345678910111213141516171819202122class Solution &#123; private Integer res = 0; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; getDepth(root, 1); return res; &#125; private void getDepth(TreeNode root, Integer depth) &#123; res = depth &gt; res ? depth : res; if(root.left != null) &#123; depth++; getDepth(root.left, depth); depth--; // 回溯 &#125; if(root.right != null) &#123; depth++; getDepth(root.right, depth); depth--; // 回溯 &#125; return; &#125;&#125; 简化代码 12345678910111213141516class Solution &#123; private Integer res = 0; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; getDepth(root, 1); return res; &#125; private void getDepth(TreeNode root, Integer depth) &#123; res = depth &gt; res ? depth : res; if(root.left != null) getDepth(root.left, depth + 1); if(root.right != null) getDepth(root.right, depth + 1); return; &#125;&#125; 后序遍历递归法 1234567891011121314class Solution &#123; public int maxDepth(TreeNode root) &#123; return getDepth(root); &#125; private int getDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; int leftDepth = getDepth(root.left); int rightDepth = getDepth(root.right); return 1 + Math.max(leftDepth, rightDepth); &#125;&#125; 8. 111. 二叉树的最小深度问题给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例1： 12输入：root = [3,9,20,null,null,15,7]输出：2 示例2： 12输入：root = [2,null,3,null,4,null,5,null,6]输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 代码12345678910111213141516171819class Solution &#123; public int minDepth(TreeNode root) &#123; return getDepth(root); &#125; private int getDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; int leftDepth = getDepth(root.left); int rightDepth = getDepth(root.right); if(root.left == null &amp;&amp; root.right != null) &#123; return 1 + rightDepth; &#125; if(root.left != null &amp;&amp; root.right == null) &#123; return 1 + leftDepth; &#125; return 1 + Math.min(leftDepth, rightDepth); &#125;&#125; 9. 222. 完全二叉树的节点个数问题给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例1： 12输入：root = [1,2,3,4,5,6]输出：6 示例2： 12输入：root = []输出：0 示例3： 12输入：root = [1]输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 代码 层次遍历迭代法 123456789101112131415161718 // 根据完全二叉树的特性，使用层序遍历解决class Solution &#123; public int countNodes(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null) &#123; return 0; &#125; int nodeCount = 0; queue.offer(root); while(!queue.isEmpty()) &#123; nodeCount++; TreeNode node = queue.poll(); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; return nodeCount; &#125;&#125; 后序遍历递归法 1234567891011121314 // 普通二叉树 递归 后序遍历class Solution &#123; public int countNodes(TreeNode root) &#123; return getNoeCounts(root); &#125; private int getNoeCounts(TreeNode node) &#123; if(node == null) &#123; return 0; &#125; int leftNodeCounts = getNoeCounts(node.left); int rightNodeCounts = getNoeCounts(node.right); return leftNodeCounts + rightNodeCounts + 1; &#125;&#125; 10. 110. 平衡二叉树问题给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例1： 12输入：root = [3,9,20,null,null,15,7]输出：true 示例2： 12输入：root = [1,2,2,3,3,null,null,4,4]输出：false 示例3： 12输入：root = []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 代码后序遍历递归法 1234567891011121314151617181920 // 每个节点 的左右两个子树的高度差的绝对值不超过 1class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) &#123; return true; &#125; return NodeHeigh(root) == -1 ? false : true; &#125; // 递归尝试 找到一处 高度差 为 &gt; 1,如有 停止 计算高度，直接 由内到外返回 结果 private int NodeHeigh(TreeNode node) &#123; if(node == null) &#123; return 0; &#125; int leftHeigh = NodeHeigh(node.left); int rightHeigh = NodeHeigh(node.right); if(leftHeigh == -1 || rightHeigh == -1) return -1; int heigh = Math.max(leftHeigh, rightHeigh) + 1; return Math.abs(leftHeigh - rightHeigh) &gt; 1 ? -1 : heigh; &#125;&#125; 前序遍历迭代法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 // 每个节点 的左右两个子树的高度差的绝对值不超过 1// 前序 遍历 求 深度class Solution &#123; public boolean isBalanced(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null) &#123; return true; &#125; stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.pop(); // 获取 两棵 子树 的高度差 if(Math.abs(getDepth(node.left) - getDepth(node.right)) &gt; 1) &#123; return false; &#125; // 大子树 不超过，遍历 小子树 if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); &#125; return true; &#125; // 准确来说 计算的是 节点的高度（该节点到叶子结点） // 后序 遍历 求 高度 private int getDepth(TreeNode root) &#123; Integer depth = 0; Integer res = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null) &#123; return 0; &#125; stack.push(root); while(!stack.empty()) &#123; // 栈存放了 空指针 TreeNode node = stack.peek(); if(node != null) &#123; node = stack.pop(); stack.push(node); stack.push(null); depth++; if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); &#125; else &#123; // 弹出 空指针 stack.pop(); node = stack.pop(); depth--; // 类似 回溯 &#125; res = depth &gt; res ? depth : res; &#125; return res; &#125; &#125; 11. 257. 二叉树的所有路径给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例1: 12输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 实例2： 12输入：root = [1]输出：[&quot;1&quot;] 提示： 树中节点的数目在范围 [1, 100] 内 -100 &lt;= Node.val &lt;= 100 代码 递归法 1234567891011121314151617181920212223class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(root == null) &#123; return res; &#125; backtrack(root, res, &quot;&quot;); return res; &#125; // 前序递归遍历 所有节点 private void backtrack(TreeNode cur,List&lt;String&gt; res, String path) &#123; // 不是空节点 加上 path += cur.val; // 找到 叶子节点 if(cur.left == null &amp;&amp; cur.right == null) &#123; res.add(path); return; &#125; if(cur.left != null) backtrack(cur.left, res, path + &quot;-&gt;&quot;); // 隐藏了 回溯，path 是 String 类型，不可变类 if(cur.right != null) backtrack(cur.right, res, path + &quot;-&gt;&quot;); &#125;&#125; 迭代法 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(root == null) &#123; return res; &#125; Stack&lt;String&gt; pathSt = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); pathSt.push(root.val + &quot;&quot;); stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.pop(); String path = pathSt.pop(); if(node.left == null &amp;&amp; node.right == null) &#123; res.add(path); &#125; if(node.right != null) &#123; pathSt.push(path + &quot;-&gt;&quot; + node.right.val); stack.push(node.right); &#125; if(node.left != null) &#123; pathSt.push(path + &quot;-&gt;&quot; + node.left.val); stack.push(node.left); &#125; &#125; return res; &#125;&#125; 12. 100. 相同的树问题给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例1： 12输入：p = [1,2,3], q = [1,2,3]输出：true 示例2： 12输入：p = [1,2], q = [1,null,2]输出：false 示例3： 12输入：p = [1,2,1], q = [1,1,2]输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 &lt;= Node.val &lt;= 104 代码 递归法 1234567891011121314 // 前序递归遍历class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) return true; else if(p == null &amp;&amp; q != null) return false; else if(p != null &amp;&amp; q == null) return false; else if(p.val != q.val) return false; boolean leftTreeSame = isSameTree(p.left, q.left); boolean rightTreeSame = isSameTree(p.right, q.right); boolean isSame = leftTreeSame &amp;&amp; rightTreeSame; return isSame; &#125;&#125; 迭代法 12345678910111213141516171819202122232425 // 层序迭代遍历class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; // p 和 q 都不等于 null Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(p); stack.push(q); while(!stack.empty()) &#123; TreeNode leftNode = stack.pop(); TreeNode rightNode = stack.pop(); if(leftNode == null &amp;&amp; rightNode == null) continue; if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) &#123; return false; &#125; // leftNode 和 rightNode 都不为 null stack.push(leftNode.left); stack.push(rightNode.left); stack.push(leftNode.right); stack.push(rightNode.right); &#125; return true; &#125;&#125; 13. 112. 路径总和问题给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 1000 &lt;= Node.val &lt;= 1000 1000 &lt;= targetSum &lt;= 1000 代码 前序遍历递归法 1234567891011121314151617class Solution &#123; boolean res = false; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null) &#123; return false; &#125; backtrack(root, targetSum, root.val); return res; &#125; private void backtrack(TreeNode node, int targetSum, int sum) &#123; if(node.left == null &amp;&amp; node.right == null &amp;&amp; sum == targetSum) &#123; res = true; &#125; if(node.left != null) backtrack(node.left, targetSum, sum + node.left.val); if(node.right != null) backtrack(node.right, targetSum, sum + node.right.val); &#125;&#125; 前序遍历迭代法 12345678910111213141516171819202122232425262728class Solution &#123; boolean res = false; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null) &#123; return false; &#125; Stack&lt;TreeNode&gt; tNst = new Stack&lt;&gt;(); Stack&lt;Integer&gt; valSt = new Stack&lt;&gt;(); tNst.push(root); valSt.push(root.val); while(!tNst.empty()) &#123; TreeNode node = tNst.pop(); int sum = valSt.pop(); if(node.left == null &amp;&amp; node.right == null &amp;&amp; sum == targetSum) &#123; return true; &#125; if(node.left != null) &#123; valSt.push(sum + node.left.val); tNst.push(node.left); &#125; if(node.right != null) &#123; valSt.push(sum + node.right.val); tNst.push(node.right); &#125; &#125; return false; &#125;&#125; 14. 106. 从中序与后序遍历序列构造二叉树问题给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例1： 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 示例2： 12输入：inorder = [-1], postorder = [-1]输出：[-1] 提示: 1 &lt;= inorder.length &lt;= 3000 postorder.length == inorder.length -3000 &lt;= inorder[i], postorder[i] &lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 代码 前序遍历递归法 ( DFS 写法 ) 1234567891011121314151617181920212223class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; return backtrack(inorder, 0, inorder.length, postorder, 0, postorder.length); &#125; // 左闭右开区间 private TreeNode backtrack(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123; int index = inLeft; if(inLeft == inRight) return null; TreeNode root = new TreeNode(postorder[postRight - 1]); // 所以for 循环 终止条件是 &lt; 符合 for(int i = inLeft; i &lt; inRight; i++) &#123; if(inorder[i] == postorder[postRight - 1]) &#123; index = i; break; &#125; &#125; // 找的是 左区间，也就是 左节点 root.left = backtrack(inorder, inLeft, index, postorder, postLeft, postLeft + (index - inLeft)); // 找的是 右区间，也就是 右节点 root.right = backtrack(inorder, index + 1, inRight, postorder, postLeft + (index - inLeft), postRight - 1); return root; &#125;&#125; 15. 105. 从前序与中序遍历序列构造二叉树问题给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例1： 12输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 示例2： 12输入: preorder = [-1], inorder = [-1]输出: [-1] 提示: 1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 代码 DFS 递归法 12345678910111213141516171819class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return backtrack(preorder, 0, preorder.length, inorder, 0, inorder.length); &#125; private TreeNode backtrack(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123; if(inLeft == inRight) return null; TreeNode root = new TreeNode(preorder[preLeft]); int index = inLeft; for(int i = inLeft; i &lt; inRight; i++) &#123; if(inorder[i] == preorder[preLeft]) &#123; index = i; break; &#125; &#125; root.left = backtrack(preorder, preLeft + 1, preLeft + 1 + (index - inLeft), inorder, inLeft, index); root.right = backtrack(preorder, preLeft + 1 + (index - inLeft), preRight, inorder, index + 1, inRight); return root; &#125;&#125; 16. 654. 最大二叉树问题给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。递归地在最大值 左边 的 子数组前缀上 构建左子树。递归地在最大值 右边 的 子数组后缀上 构建右子树。返回 nums 构建的 最大二叉树 。 示例1： 123456789101112输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示：- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例2： 12输入：nums = [3,2,1]输出：[3,null,2,null,1] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 代码12345678910111213141516171819202122class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return recursion(nums, 0, nums.length); &#125; private TreeNode recursion(int[] nums, int leftIndex, int rightIndex) &#123; if(leftIndex == rightIndex) &#123; return null; &#125; int maxIndex = leftIndex; int max = nums[maxIndex]; for(int i = leftIndex; i &lt; rightIndex; i++) &#123; if(max &lt; nums[i]) &#123; max = nums[i]; maxIndex = i; &#125; &#125; TreeNode root = new TreeNode(max); root.left = recursion(nums, leftIndex, maxIndex); root.right = recursion(nums, maxIndex + 1, rightIndex); return root; &#125;&#125; 小总结涉及到使用数组递归创建二叉树可以使用以下模板 1234567891011121314151617181920class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return recursion(nums, 0, nums.length, ...); &#125; private TreeNode recursion(int[] nums, int leftIndex, int rightIndex, ...) &#123; if(leftIndex == rightIndex) &#123; return null; &#125; // 初始化 要创建的节点坐标 int rootIndex = 0; for(int i = leftIndex; i &lt; rightIndex; i++) &#123; // 满足创建节点条件 // rootIndex = ? &#125; TreeNode root = new TreeNode(nums[rootIndex]); root.left = recursion(nums, leftIndex, maxIndex, ...); root.right = recursion(nums, maxIndex + 1, rightIndex, ...); return root; &#125;&#125; 17. 617. 合并二叉树问题给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例1： 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 示例2： 12输入：root1 = [1], root2 = [1,2]输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 代码 前序遍历递归法 12345678910class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if(root1 == null) return root2; if(root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; &#125;&#125; 层序遍历迭代法 123456789101112131415161718192021222324252627282930class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if(root1 == null) return root2; if(root2 == null) return root1; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root2); stack.push(root1); while(!stack.empty()) &#123; TreeNode node1 = stack.pop(); TreeNode node2 = stack.pop(); node1.val += node2.val; if(node1.left != null &amp;&amp; node2.left != null) &#123; stack.push(node2.left); stack.push(node1.left); &#125; if(node1.right != null &amp;&amp; node2.right != null) &#123; stack.push(node2.right); stack.push(node1.right); &#125; // 这里 赋值的 是 node2 的子树（子树！） if(node1.left == null &amp;&amp; node2.left != null) &#123; node1.left = node2.left; &#125; if(node1.right == null &amp;&amp; node2.right != null) &#123; node1.right = node2.right; &#125; &#125; return root1; &#125;&#125; 18. 700. 二叉搜索树中的搜索问题给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例1： 12输入：root = [4,2,7,1,3], val = 2输出：[2,1,3] 示例2： 12输入：root = [4,2,7,1,3], val = 5输出：[] 提示： 数中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 代码 前序遍历递归法 123456789101112131415class Solution &#123; private TreeNode res = null; public TreeNode searchBST(TreeNode root, int val) &#123; search(root, val); return res; &#125; private void search(TreeNode root, int val) &#123; if(root.val == val) &#123; res = root; return; &#125; if(root.left != null) search(root.left, val); if(root.right != null) search(root.right, val); &#125;&#125; 19. 700. 二叉搜索树中的搜索问题给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例1： 12输入：root = [4,2,7,1,3], val = 2输出：[2,1,3] 示例2： 12输入：root = [4,2,7,1,3], val = 5输出：[] 提示： 数中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 代码123456789101112131415class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.pop(); if(node.val == val) &#123; return node; &#125; if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); &#125; return null; &#125;&#125; 20. 98. 验证二叉搜索树问题给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例1： 12输入：root = [2,1,3]输出：true 示例2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 代码 中序遍历递归法 12345678910111213141516171819 // 注意 保存上一个值来比较，初始化要小于 int 类型最小值class Solution &#123; private long preVal = ((long)Integer.MIN_VALUE - 1); private boolean isTrue = true; public boolean isValidBST(TreeNode root) &#123; recursion(root); return isTrue; &#125; private void recursion(TreeNode node) &#123; if(node == null) return; if(node.left != null &amp;&amp; isTrue) recursion(node.left); if(node.val &lt;= preVal) &#123; isTrue = false; return; &#125; preVal = node.val; if(node.right != null &amp; isTrue) recursion(node.right); &#125;&#125; 中序遍历迭代法 12345678910111213141516171819202122232425class Solution &#123; public boolean isValidBST(TreeNode root) &#123; long preVal = ((long)Integer.MIN_VALUE - 1); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); if(node.right != null) stack.push(node.right); stack.push(node); stack.push(null); if(node.left != null) stack.push(node.left); &#125; else &#123; stack.pop(); node = stack.pop(); if(node.val &lt;= preVal) &#123; return false; &#125; preVal = node.val; &#125; &#125; return true; &#125;&#125; 21. 530. 二叉搜索树的最小绝对差问题给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例1： 12输入：root = [4,2,6,1,3]输出：1 示例2： 12输入：root = [1,0,48,null,null,12,49]输出：1 提示： 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105 代码 中序遍历递归法 12345678910111213141516171819 // 中序遍历，保存前一元素变量和当前最新差变量class Solution &#123; private int diffVal = Integer.MAX_VALUE; private int preVal = - 100000; public int getMinimumDifference(TreeNode root) &#123; recursion(root); return diffVal; &#125; private void recursion(TreeNode node) &#123; if(node == null) return; if(node.left != null) recursion(node.left); int curDiff = node.val - preVal; if(curDiff &lt; diffVal) &#123; diffVal = curDiff; &#125; preVal = node.val; if(node.right != null) recursion(node.right); &#125;&#125; 中序遍历迭代法 12345678910111213141516171819202122232425262728 // 中序遍历，保存前一元素变量和当前最新差变量class Solution &#123; public int getMinimumDifference(TreeNode root) &#123; int diffVal = Integer.MAX_VALUE; int preVal = - 100000; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); if(node.right != null) stack.push(node.right); stack.push(node); stack.push(null); if(node.left != null) stack.push(node.left); &#125; else &#123; stack.pop(); node = stack.pop(); int curDiff = node.val - preVal; if(curDiff &lt; diffVal) &#123; diffVal = curDiff; &#125; preVal = node.val; &#125; &#125; return diffVal; &#125;&#125; 22. 501. 二叉搜索树中的众数问题给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值结点右子树中所含节点的值 大于等于 当前节点的值左子树和右子树都是二叉搜索树 示例1： 12输入：root = [1,null,2,2]输出：[2] 示例2： 12输入：root = [0]输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 -105 &lt;= Node.val &lt;= 105 代码 中序遍历迭代法 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[] findMode(TreeNode root) &#123; int preVal = - 100000 - 1; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int maxTime = 1; int currentTime = 1; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); if(node.right != null) stack.push(node.right); stack.push(node); stack.push(null); if(node.left != null) stack.push(node.left); &#125; else &#123; stack.pop(); node = stack.pop(); // 先 判断 是否有 相同元素 来 计当前元素 次数 if(node.val == preVal) &#123; currentTime++; &#125; else &#123; currentTime = 1; &#125; // 再 通过 相同元素次数 和最大次数 比较 // 相等就 再加入结果 if(currentTime == maxTime) &#123; res.add(node.val); // 存在 一个元素 比之前 次数还多的，那之前的就不要了,把当前的元素 加入结果 &#125; else if(currentTime &gt; maxTime) &#123; maxTime = currentTime; res.clear(); res.add(node.val); &#125; preVal = node.val; &#125; &#125; return Arrays.stream(res.toArray(new Integer[0])).mapToInt(Integer::intValue).toArray(); &#125;&#125; 中序遍历递归法 12345678910111213141516171819202122232425262728293031323334class Solution &#123; private int preVal = - 100000 - 1; private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); private int maxTime = 1; private int currentTime = 1; public int[] findMode(TreeNode root) &#123; recursion(root); int[] intRes = new int[res.size()]; for(int i = 0; i &lt; res.size(); i++) &#123; intRes[i] = res.get(i); &#125; return intRes; &#125; private void recursion(TreeNode node) &#123; if(node.left != null )recursion(node.left); if(node.val == preVal) &#123; currentTime++; &#125; else &#123; currentTime = 1; &#125; // 再 通过 相同元素次数 和最大次数 比较 // 相等就 再加入结果 if(currentTime == maxTime) &#123; res.add(node.val); // 存在 一个元素 比之前 次数还多的，那之前的就不要了,把当前的元素 加入结果 &#125; else if(currentTime &gt; maxTime) &#123; maxTime = currentTime; res.clear(); res.add(node.val); &#125; preVal = node.val; if(node.right != null) recursion(node.right); &#125;&#125; 23. 236. 二叉树的最近公共祖先问题给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例1： 123输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例2： 123输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例3： 12输入：root = [1,2], p = 1, q = 2输出：1 提示： 树中节点数目在范围 [2, 105] 内。-109 &lt;= Node.val &lt;= 109所有 Node.val 互不相同 。p != qp 和 q 均存在于给定的二叉树中。 代码 后序遍历递归法 12345678910111213141516171819202122class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 终止条件，找不到 返回 null，否则 返回 目标节点 if(root == null || root == p || root == q) return root; // 后序递归 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 由 公共 祖先 找到，而且 公共祖先 不为 left 或 right if(left != null &amp;&amp; right != null) &#123; return root; &#125; // 由 left 子树中 找到，右侧中 没有 p 和 q，而且 找到的 必然是 节点更高的 那个(后序遍历) if(left != null &amp;&amp; right == null) &#123; return left; // 由 right 子树中 找到，左侧中 没有 p 和 q，而且 找到的 必然是 节点更高的 那个(后序遍历) &#125; else if(left == null &amp;&amp; right != null) &#123; return right; &#125; else &#123; return null; &#125; &#125;&#125; 24. 235. 二叉搜索树的最近公共祖先问题给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例1： 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例2： 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 代码 迭代法 1234567891011121314class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; while(root != null) &#123; if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; root = root.right; &#125; else if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; root = root.left; &#125; else &#123; break; &#125; &#125; return root; &#125;&#125; 递归法 12345678910class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &lt; Math.min(p.val, q.val)) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else if (root.val &gt; Math.max(p.val, q.val)) &#123; return lowestCommonAncestor(root.left, p, q); &#125; return root; &#125;&#125; 25. 701. 二叉搜索树中的插入操作问题给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例1： 123输入：root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是： 示例2： 12输入：root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25] 示例3： 12输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5] 提示： 树中的节点数将在 [0, 104]的范围内。 -108 &lt;= Node.val &lt;= 108 所有值 Node.val 是 独一无二 的。 -108 &lt;= val &lt;= 108 保证 val 在原始BST中不存在。 代码 递归法（找到 对应 位置，回溯后 指向解决） 1234567891011class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; // 向下搜索到 指定 空节点位置，回溯后由对应的 父节点的对应 子节点 指向待插入节点就可以了 if(root == null) &#123; return new TreeNode(val); &#125; if(root.val &gt; val) root.left = insertIntoBST(root.left, val); if(root.val &lt; val) root.right = insertIntoBST(root.right, val); return root; &#125;&#125; 迭代法 1234567891011121314151617181920212223class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if(root == null) &#123; return new TreeNode(val); &#125; TreeNode pre = root; TreeNode cur = root; while(cur != null) &#123; pre = cur; if(cur.val &lt; val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; if(pre.val &lt; val) &#123; pre.right = new TreeNode(val); &#125; else &#123; pre.left = new TreeNode(val); &#125; return root; &#125;&#125; 26. 450. 删除二叉搜索树中的节点问题给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点；如果找到了，删除它。 示例1： 12345输入：root = [5,3,6,2,4,null,7], key = 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。 示例2： 123输入: root = [5,3,6,2,4,null,7], key = 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点 示例3： 12输入: root = [], key = 0输出: [] 提示: 节点数的范围 [0, 104]. -105 &lt;= Node.val &lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 &lt;= key &lt;= 105 代码 递归法 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if(root == null) return null; if(root.val == key) &#123; if(root.left == null &amp;&amp; root.right == null) &#123; return null; &#125; else if(root.left == null) &#123; TreeNode target = root.right; // gc 垃圾 回收 root.right = null; return target; &#125; else if(root.right == null) &#123; TreeNode target = root.left; // gc 垃圾 回收 root.left = null; return target; &#125; else &#123; TreeNode cur = root.right; TreeNode target = cur; while(cur.left != null) &#123; cur = cur.left; &#125; cur.left = root.left; // gc 回收 root.left = null; root.right = null; return target; &#125; &#125; if(root.val &gt; key) root.left = deleteNode(root.left, key); if(root.val &lt; key) root.right = deleteNode(root.right, key); return root; &#125;&#125; 小总结涉及到二叉搜索树增加和删除节点操作的，可以使用以下递归模板 12345678910111213141516class Solution &#123; public TreeNode recursion(TreeNode root, int key) &#123; // 查找到 具体位置，但为空 if(root == null) &#123; /*具体操作*/ return /**/; &#125; // 找到 具体 元素位置 if(root.val == key) &#123; &#125; root.left = recursion(root.left, key); root.right = recursion(root.right, key); return root; &#125;&#125; 669. 修剪二叉搜索树问题给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例1： 12输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2] 示例2： 12输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1] 提示： 树中节点数在范围 [1, 104] 内0 &lt;= Node.val &lt;= 104树中每个节点的值都是 唯一 的题目数据保证输入是一棵有效的二叉搜索树0 &lt;= low &lt;= high &lt;= 104 代码 递归法 因为涉及到节点删除，所以还是用之前那一套模板 12345678910111213141516class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null) &#123; return null; &#125; if(root.val &lt; low) &#123; return trimBST(root.right, low, high); &#125; if(root.val &gt; high) &#123; return trimBST(root.left, low, high); &#125; root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125; 迭代法 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null) &#123; return null; &#125; // 遍历二叉搜索树找到第一个节点 处在 区间low - high // 这一步也是在做 修减 while(root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123; if(root.val &lt; low) root = root.right; if(root.val &gt; high) root = root.left; &#125; TreeNode cur = root; // 这样，左边的节点值不可能大于 high，只要修减 小于 low while(cur != null) &#123; while(cur.left != null &amp;&amp; cur.left.val &lt; low) &#123; // 左子树root 节点值小，删除 左子树中的 左子树 cur.left = cur.left.right; &#125; // 遍历比 被修减的节点值更大的 节点 cur = cur.left; &#125; cur = root; // 右边的 节点值 不可能 小于 low，只要修减 大于 high while(cur != null) &#123; while(cur.right != null &amp;&amp; cur.right.val &gt; high) &#123; // 右子树root 节点值大，删除 右子树中的 右子树 cur.right = cur.right.left; &#125; // 遍历比 被修减的节点值更小的 节点 cur = cur.right; &#125; return root; &#125;&#125; 108. 将有序数组转换为二叉搜索树问题给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例1： 123输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案 示例2： 123输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 按 严格递增 顺序排列 代码 递归法 1234567891011121314151617class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; return recursion(nums, 0, nums.length); &#125; // 定义 为左闭右开的区间 private TreeNode recursion(int[] nums, int left, int right) &#123; // 已经取不到值了 if(left == right) &#123; return null; &#125; int rootIndex = left + (right - left) / 2; TreeNode root = new TreeNode(nums[rootIndex]); root.left = recursion(nums, left, rootIndex); root.right = recursion(nums, rootIndex + 1, right); return root; &#125;&#125; 迭代法 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums.length == 0) &#123; return null; &#125; Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; leftQueue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; rightQueue = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(0); nodeQueue.offer(root); leftQueue.offer(0); rightQueue.offer(nums.length); while(!nodeQueue.isEmpty()) &#123; TreeNode curNode = nodeQueue.poll(); int left = leftQueue.poll(); int right = rightQueue.poll(); int mid = left + (right - left) / 2; // 处理每个元素 curNode.val = nums[mid]; // 左闭右开 区间 任由元素 if(left &lt; mid) &#123; curNode.left = new TreeNode(0); nodeQueue.offer(curNode.left); leftQueue.offer(left); rightQueue.offer(mid); &#125; // 左闭右开 区间 仍有元素 if(right &gt; mid + 1) &#123; curNode.right = new TreeNode(0); nodeQueue.offer(curNode.right); leftQueue.offer(mid + 1); rightQueue.offer(right); &#125; &#125; return root; &#125;&#125; 538. 把二叉搜索树转换为累加树问题给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 示例1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例2： 12输入：root = [0,null,1]输出：[1,null,1] 示例3： 12输入：root = [1,0,2]输出：[3,3,2] 示例4： 12输入：root = [3,2,4,1]输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 代码 递归法 其实就是反中序遍历，更通俗就是从大到小遍历 12345678910111213141516class Solution &#123; private int sumWeight = 0; public TreeNode convertBST(TreeNode root) &#123; if(root == null) &#123; return null; &#125; recursion(root); return root; &#125; private void recursion(TreeNode node) &#123; if(node.right != null) recursion(node.right); sumWeight += node.val; node.val = sumWeight; if(node.left != null) recursion(node.left); &#125;&#125; 迭代法 1234567891011121314151617181920212223242526class Solution &#123; private int sumWeight = 0; public TreeNode convertBST(TreeNode root) &#123; if(root == null) &#123; return null; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty()) &#123; TreeNode node = stack.peek(); if(node != null) &#123; stack.pop(); if(node.left != null) stack.push(node.left); stack.push(node); stack.push(null); if(node.right != null) stack.push(node.right); &#125; else &#123; stack.pop(); node = stack.pop(); sumWeight += node.val; node.val = sumWeight; &#125; &#125; return root; &#125;&#125; 二叉树总结二叉树遍历方式：前序遍历、中序遍历、后序遍历、层次遍历 二叉树遍历算法：回溯、单队列、多队列、单栈、多栈 二叉树分类：普通二叉树、完全二叉树、二叉搜索树、二叉平衡搜索树、最大树、最小树 性质： 普通二叉树：普通遍历方式 完全二叉树：层次遍历 + 队列 二叉搜索树：中序遍历 + 递归，中序遍历 + 迭代，添加节点，修改节点 二叉平衡搜索树：有序数组 + 递归 构造平衡搜索树 最大树：第 n 个 最大值 最小树：第 n 个 最小值","categories":[{"name":"leetCode算法","slug":"leetCode算法","permalink":"http://fyupeng.github.io/categories/leetCode%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://fyupeng.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"fyupeng"},{"title":"回溯","slug":"回溯","date":"2022-06-25T06:45:06.000Z","updated":"2022-06-25T06:55:47.792Z","comments":true,"path":"2022/06/25/回溯/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/%E5%9B%9E%E6%BA%AF/","excerpt":"","text":"1. 22. 括号生成问题数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例1： 12输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;] 示例2： 12输入：n = 1输出：[&quot;()&quot;] 提示： 1 &lt;= n &lt;= 8 代码12345678910111213141516171819202122class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); backtracking(n, result, 0, 0, &quot;&quot;); return result; &#125; private static void backtracking(int n, List&lt;String&gt; result, int left, int right, String str) &#123; if(right &gt; left) &#123; return; &#125; if(left == right &amp;&amp; right == n) &#123; result.add(str); return; &#125; if(left &lt; n) &#123; backtracking(n, result, left + 1, right, str + &quot;(&quot;); &#125; if(right &lt; left) &#123; backtracking(n, result, left, right + 1, str + &quot;)&quot;); &#125; &#125;&#125; 2. 77. 组合问题给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例1： 12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 示例2： 12输入：n = 1, k = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= n 代码12345678910111213141516171819202122class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); private List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return result; &#125; private void backtracking(int n, int k, int startIndex) &#123; // 终止条件 if(path.size() == k) &#123; result.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = startIndex; i &lt;= n; i++) &#123; path.add(i); backtracking(n, k, i + 1); // 遍历 下一个 纵向 元素 path.remove(path.size() - 1); // 遍历下一个 横向 元素(言外之意就是纵向元素已经遍历完回溯了，需要移除) &#125; &#125;&#125; 剪枝优化搜索起点的上界 + 接下来要选择的元素个数 - 1 = n其中，接下来要选择的元素个数 = k - path.size()，整理得到： 搜索起点的上界 = n - (k - path.size()) + 1所以，我们的剪枝过程就是：把 i &lt;= n 改成 i &lt;= n - (k - path.size()) + 1 ： 12345for(int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; path.add(i); backtracking(n, k, i + 1); // 遍历 下一个 纵向 元素 path.remove(path.size() - 1); // 遍历下一个 横向 元素 &#125; 3. 216. 组合总和 III问题找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9每个数字 最多使用一次返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例1： 12345输入: k = 3, n = 7输出: [[1,2,4]]解释:1 + 2 + 4 = 7没有其他符合的组合了。 示例2： 1234567输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。 示例3： 1234输入: k = 4, n = 1输出: []解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。 ​ 提示: 2 &lt;= k &lt;= 9 1 &lt;= n &lt;= 60 代码123456789101112131415161718192021222324class Solution &#123; private List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, 0); return result; &#125; private void backtracking(int k, int n, int startIndex, int sum) &#123; if(path.size() == k) &#123; if(sum == n) &#123; result.add(new ArrayList&lt;&gt;(path)); return; &#125; &#125; for(int i = startIndex; i &lt;= 9; i++) &#123; sum += i; path.add(i); backtracking(k, n, i + 1, sum); sum -= i; path.remove(path.size() - 1); &#125; &#125;&#125; 剪枝优化：123456789if(sum &gt; n) &#123; return;&#125;if(path.size() == k) &#123; if(sum == n) &#123; result.add(new ArrayList&lt;&gt;(path)); return; &#125;&#125; 4. 17. 电话号码的字母组合问题给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例1： 12输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] 示例2： 12输入：digits = &quot;&quot;输出：[] 示例3： 12输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; private final String[] letterMap = &#123; &quot;&quot;, // 0 &quot;&quot;, // 1 &quot;abc&quot;, // 2 &quot;def&quot;, // 3 &quot;ghi&quot;, // 4 &quot;jkl&quot;, // 5 &quot;mno&quot;, // 6 &quot;pqrs&quot;, // 7 &quot;tuv&quot;, // 8 &quot;wxyz&quot; // 9 &#125;; private List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) &#123; if(&quot;&quot;.equals(digits)) &#123; return result; &#125; backtracking(digits, 0, new StringBuilder()); return result; &#125; private void backtracking(String digits, int index, StringBuilder subString) &#123; if(index == digits.length()) &#123; result.add(subString.toString()); return; &#125; int digit = digits.charAt(index) - &#x27;0&#x27;; String letters = letterMap[digit]; for(int i = 0; i &lt; letters.length(); i++) &#123; subString.append(letters.charAt(i)); backtracking(digits, index + 1, subString); subString.delete(subString.length() - 1, subString.length()); &#125; &#125;&#125; 5. 39. 组合总和 树枝剪枝或for循环剪枝问题给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 示例2： 12输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 示例3： 12输入: candidates = [2], target = 1输出: [] 代码12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(candiates); backtracking(result, new ArrayList&lt;&gt;(), candidates, target, 0, 0); return result; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] candidates, int target, int startIndex, int sum) &#123; if(sum &gt; target) &#123; return; &#125; if(sum == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = startIndex; i &lt; candidates.length; i++) &#123; sum += candidates[i]; path.add(candidates[i]); backtracking(res, path, candidates, target, i, sum); sum -= candidates[i]; path.remove(path.size() - 1); &#125; &#125;&#125; 剪枝优化12345678910111213/*if(sum &gt; target) &#123; return;&#125;*/for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; sum += candidates[i]; path.add(candidates[i]); backtracking(res, path, candidates, target, i, sum); sum -= candidates[i]; path.remove(path.size() - 1);&#125; 6. 40. 组合总和 II 排序树层去重问题给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例1： 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]] 示例2： 123456输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]] 代码12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtracking(candidates, target, res, new ArrayList&lt;Integer&gt;(), 0, new boolean[candidates.length], 0); return res; &#125; private void backtracking(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int startIndex, boolean[] used, int sum) &#123; if(sum &gt; target) &#123; return; &#125; if(sum == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = startIndex; i &lt; candidates.length; i++) &#123; if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) &#123; continue; &#125; path.add(candidates[i]); used[i] = true; backtracking(candidates, target, res, path, i + 1, used, sum + candidates[i]); path.remove(path.size() - 1); used[i] = false; &#125; &#125;&#125; 剪枝优化12345678/*if(sum &gt; target) &#123; return;&#125;*/for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; &#125; 另一种代码使用 i &gt; startIndex 巧妙 设计 成 深度 可重复 数字， 横向 不允许 重复数字 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtracking(candidates, target, res, new ArrayList&lt;Integer&gt;(), 0, 0); return res; &#125; private void backtracking(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int startIndex, int sum) &#123; if(sum == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123; if(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; path.add(candidates[i]); backtracking(candidates, target, res, path, i + 1, sum + candidates[i]); path.remove(path.size() - 1); &#125; &#125;&#125; 7. 131. 分割回文串 判断剪枝问题给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例1： 12输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] 示例2： 12输入：s = &quot;a&quot;输出：[[&quot;a&quot;]] 提示： 1 &lt;= s.length &lt;= 16 s 仅由小写英文字母组成 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new ArrayList&lt;String&gt;(), s, 0); return res; &#125; private void backtracking(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path, String s, int startIndex) &#123; if(startIndex == s.length()) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = startIndex; i &lt; s.length(); i++) &#123; if(isPartition(s, startIndex, i)) &#123; String substring = s.substring(startIndex, i + 1); path.add(substring); &#125; else &#123; continue; &#125; backtracking(res, path, s, i + 1); path.remove(path.size() - 1); &#125; &#125; private boolean isPartition(String s, int start, int end) &#123; for(int i = start,j = end; i &lt; j; i++, j--) &#123; if(s.charAt(i) != s.charAt(j)) &#123; return false; &#125; &#125; return true; &#125;&#125; 8. 93. 复原 IP 地址 for循环和判断剪枝问题有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “&#49;&#x39;&#x32;&#x2e;&#x31;&#x36;&#56;&#64;&#x31;&#46;&#49;“ 是 无效 IP 地址。给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例1： 12输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;] 示例2： 12输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;] 示例3： 12输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;] 代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new StringBuilder(), s, 0, 0); return res; &#125; private void backtracking(List&lt;String&gt; res, StringBuilder substring, String s, int startIndex, int pointCount) &#123; if(startIndex == s.length() &amp;&amp; pointCount == 4) &#123; String withPointString = substring.toString(); res.add(withPointString.substring(0, withPointString.length() - 1)); return; &#125; // 直接 在 for 循环 剪枝 长度 大于 3 或者 点数 大于等于 4 位的（等于4 位 已经在 前面 判断了） for(int i = startIndex; i &lt; s.length() &amp;&amp; pointCount &lt; 4 &amp;&amp; i - startIndex &lt; 3; i++) &#123; if((i &gt; startIndex &amp;&amp; s.charAt(startIndex) == &#x27;0&#x27;)) &#123; continue; &#125; String str = s.substring(startIndex, i + 1); if(Integer.parseInt(str) &gt;= 0 &amp;&amp; Integer.parseInt(str) &lt;= 255) &#123; substring.append(str).append(&quot;.&quot;); &#125; else &#123; continue; &#125; backtracking(res, substring, s, i + 1, pointCount + 1); substring.deleteCharAt(substring.lastIndexOf(&quot;.&quot;)); substring.delete(substring.lastIndexOf(&quot;.&quot;) + 1, substring.length()); &#125; &#125;&#125; 9. 78. 子集 不剪枝问题给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 代码12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, 0); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path ,int[] nums, int startIndex) &#123; res.add(new ArrayList&lt;&gt;(path)); if(startIndex == nums.length) &#123; return; &#125; for(int i = startIndex; i &lt; nums.length; i++) &#123; path.add(nums[i]); backtracking(res, path, nums, i + 1); path.remove(path.size() - 1); &#125; &#125;&#125; 模板1234result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加 return;&#125; 10. 90. 子集 II 排序树层去重问题给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例1： 12输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例2： 12输入：nums = [0]输出：[[],[0]] 提示 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 代码123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, 0); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] nums, int startIndex) &#123; res.add(new ArrayList&lt;&gt;(path)); if(startIndex == nums.length) &#123; return; &#125; for(int i = startIndex; i &lt; nums.length; i++) &#123; // 去重 条件 只对 广度 有效，也就是 对不同 子集去重 if(i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; path.add(nums[i]); backtracking(res, path, nums, i + 1); path.remove(path.size() - 1); &#125; &#125;&#125; 11. 491. 递增子序列 非排序树层去重问题给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 示例1： 12输入：nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例2： 12输入：nums = [4,4,3,2,1]输出：[[4,4]] 提示 1 &lt;= nums.length &lt;= 15 -100 &lt;= nums[i] &lt;= 100 代码1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, 0); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] nums, int startIndex) &#123; if (path.size() &gt; 1) &#123; res.add(new ArrayList&lt;&gt;(path)); // 注意这里不要加return，要取树上所有的节点 &#125; // 生命周期 存活在 递归函数中，所以对 同一层有效 Set&lt;Integer&gt; uset = new HashSet&lt;&gt;(); for(int i = startIndex; i &lt; nums.length; i++) &#123; // 当 path 有值 时，判断 当前 i 所在下标的 值 是否 小于 path 有序列表最后 一个元素 或者 同一层出现 重复元素 if(path.size() &gt; 0 &amp;&amp; nums[i] &lt; path.get(path.size() - 1) || !uset.add(nums[i])) &#123; continue; &#125; //uset.add(nums[i]); path.add(nums[i]); backtracking(res, path, nums, i + 1); path.remove(path.size() - 1); &#125; &#125;&#125; 12. 46. 全排列 树枝去重问题给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例2： 12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例3： 12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 代码123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, new boolean[nums.length]); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] nums, boolean[] used) &#123; // 全排列，每个元素只能用一次并且全部要用到 if(path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; // 递归（纵向遍历）不能出现重复，一个元素只能用一次 if(used[i]) continue; path.add(nums[i]); used[i] = true; backtracking(res, path, nums, used); path.remove(path.size() - 1); used[i] = false; &#125; &#125;&#125; 13. 47. 全排列 II 树枝和树层去重问题给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例1： 12345输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]] 示例2： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示： 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 代码1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, new boolean[nums.length]); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] nums, boolean[] used) &#123; if(path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; Set&lt;Integer&gt; uset = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; // 纵向 遍历 同一个下标元素 重复，跳过 // 否则 横向 遍历 到 重复元素(不同下标)，跳过 if(used[i] || !uset.add(nums[i])) continue; path.add(nums[i]); used[i] = true; backtracking(res, path, nums, used); path.remove(path.size() - 1); used[i] = false; &#125; &#125;&#125; 14. 404. 左叶子之和问题给定二叉树的根节点 root ，返回所有左叶子之和。 示例1： 123输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例2： 12输入: root = [1]输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 &lt;= Node.val &lt;= 1000 代码 后序遍历递归法 1234567891011121314151617181920// 后序遍历递归class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; return sumRecurision(root); &#125; private int sumRecurision(TreeNode node) &#123; // 终止条件，叶子节点或空节点 if(node == null || node.left == null &amp;&amp; node.right == null) return 0; int sumLeft = sumRecurision(node.left); int sumRight = sumRecurision(node.right); // 存在节点 的左叶子节点 if(node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) &#123; return node.left.val + sumLeft + sumRight; &#125; return sumLeft + sumRight; &#125;&#125; 前序迭代法 12345678910111213141516171819class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); int sum = 0; while(!stack.empty()) &#123; TreeNode node = stack.pop(); if(node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) &#123; sum += node.left.val; &#125; if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); &#125; return sum; &#125;&#125; 15. 513. 找树左下角的值问题给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例1： 12输入: root = [2,1,3]输出: 1 示例2： 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 代码 类层序遍历迭代法 1234567891011121314151617class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode res = root; while(!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if(node == null) &#123; continue; &#125; res = node; queue.offer(node.right); queue.offer(node.left); &#125; return res.val; &#125;&#125; 前序遍历递归法 123456789101112131415161718192021class Solution &#123; TreeNode res = null; int max = 0; public int findBottomLeftValue(TreeNode root) &#123; res = root; // 因为 这里已经说了,根节点 不为空了 reversivion(root, 1); return res.val; &#125; private void reversivion(TreeNode node, int depth) &#123; if(node == null) &#123; return; &#125; if(node != null &amp;&amp; max &lt; depth) &#123; max = depth; res = node; &#125; reversivion(node.left, depth + 1); reversivion(node.right, depth + 1); &#125;&#125;","categories":[{"name":"leetCode算法","slug":"leetCode算法","permalink":"http://fyupeng.github.io/categories/leetCode%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"http://fyupeng.github.io/tags/%E5%9B%9E%E6%BA%AF/"}],"author":"fyupeng"},{"title":"链表","slug":"链表","date":"2022-06-25T06:44:53.000Z","updated":"2022-06-25T06:58:27.847Z","comments":true,"path":"2022/06/25/链表/","link":"","permalink":"http://fyupeng.github.io/2022/06/25/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"1.翻转链表剑指 Offer II 024. 反转链表 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。 示例1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例2： 12输入：head = [1,2]输出：[2,1] 示例3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 1.1 递归1234567891011121314151617181920212223class Solution &#123; public ListNode reverseList(ListNode head) &#123; return reverse(head); &#125; private ListNode reverse(ListNode head) &#123; // 判断 头结点临界 if(head == null) &#123; return head; &#125; // 判断 尾结点临界 if(head.next == null) &#123; return head; &#125; ListNode last = reverse(head.next); // 翻转头结点 与 下一个节点的 next 指向 head.next.next = head; // 置 头结点 的 next 为 null head.next = null; // 返回 最后 一个节点 return last; &#125;&#125; 1.2 双指针123456789101112131415161718192021class Solution &#123; public ListNode reverseList(ListNode head) &#123; // cur 的 前一个 节点 ListNode prev = null; // 当前节点 ListNode cur = head; // 保存 临时节点 ListNode temp = null; while(cur != null) &#123; // 保存 cur 的下一个节点 temp = cur.next; // 翻转 cur 与 prev 节点的 next指向 cur.next = prev; // prev 总是 cur 的前一个节点 prev = cur; // cur 向前 移动 1位 cur = temp; &#125; return prev; &#125;&#125; 2. 两两交换给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例1： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例2： 12输入：head = []输出：[] 示例3： 12输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 2.1 递归12345678910111213141516class Solution &#123; public ListNode swapPairs(ListNode head) &#123; // 处理 头结点 和 尾结点 边界 if(head == null || head.next == null) &#123; return head; &#125; ListNode next = head.next; // 递归 拿到 已经 两两 交换好了的 next的 下一个节点 ListNode newSwapNode = swapPairs(next.next); // 交换 head 与 next 节点 的指针指向 next.next = head; // head 节点 指向 next 往后 已经 两两交换 好的 节点 head.next = newSwapNode; return next; &#125;&#125; 2.2 虚拟头结点123456789101112131415161718192021222324class Solution &#123; public ListNode swapPairs(ListNode head) &#123; // 哑元节点 ListNode dumpNode = new ListNode(0); dumpNode.next = head; // 初始化 前节点 为 哑元 节点 ListNode prev = dumpNode; // 准备 两个要 交换的 节点 且保证 不能为 空 while(head != null &amp;&amp; head.next != null) &#123; // 保存 next 的节点 的 后一个 节点 // head 与 next 交换后 会让 前面和后面的 节点 丢失 ListNode temp = head.next.next; prev.next = head.next; // 交换 两 节点 并 让 头结点 与 后面节点 连接 head.next.next = head; head.next = temp; // 自变量 自增 prev = head; head = head.next; &#125; // 返回 哑元节点 的 后一个节点 即 head 节点 return dumpNode.next; &#125;&#125; 3. 删除倒数第n节点19. 删除链表的倒数第 N 个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 3.1 数学123456789101112131415161718192021222324252627class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; int length = getLenth(head); // 设置 哑元 节点 ListNode dummyNode = new ListNode(0); dummyNode.next = head; // 倒数 第 n 个 即 顺数 第 length - (n - 1) 个 // 找到第 length - (n - 1) - 1个, 删除 它的 下一个节点 int num = length - (n - 1) - 1; ListNode prev = dummyNode; while(num &gt; 0) &#123; prev = prev.next; num -= 1; &#125; prev.next = prev.next.next; return dummyNode.next; &#125; private int getLenth(ListNode head) &#123; ListNode p = head; int length = 0; while(p != null) &#123; length++; p = p.next; &#125; return length; &#125;&#125; 3.2 双指针1234567891011121314151617181920212223class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode fast = dummyNode; ListNode slow = dummyNode; // 循环 n - 1次，让 fast 比 slow 先 n - 1 个节点 while(n &gt; 1) &#123; fast = fast.next; n--; &#125; ListNode prev = null; while(fast != null &amp;&amp; fast.next != null) &#123; prev = slow; fast = fast.next; slow = slow.next; &#125; prev.next = slow.next; slow.next = null; return dummyNode.next; &#125;&#125; 4. 链表相交面试题 02.07. 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 mlistB 中节点数目为 n0 &lt;= m, n &lt;= 3 * 1041 &lt;= Node.val &lt;= 1050 &lt;= skipA &lt;= m0 &lt;= skipB &lt;= n如果 listA 和 listB 没有交点，intersectVal 为 0如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 4.1 指针123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // 定义 链表 A 和 B的长度 int lenA = getLength(headA); int lenB = getLength(headB); // 两表长度 之差 int dfLenAB = lenA - lenB; // 记录 当前 节点位置 ListNode curA = headA; ListNode curB = headB; // A 长 B，让 较长的 遍历 直到 当前位置 到 尾结点 之间距离相同 if(dfLenAB &gt;= 0) &#123; while(dfLenAB &gt; 0) &#123; curA = curA.next; dfLenAB--; &#125; &#125; else &#123; dfLenAB = -dfLenAB; while(dfLenAB &gt; 0) &#123; curB = curB.next; dfLenAB--; &#125; &#125; // 同步 遍历，找到 一个 相同的节点 while(curA != null) &#123; if(curA == curB) &#123; return curA; &#125; curA = curA.next; curB = curB.next; &#125; // 找不到 返回 null return null; &#125; private int getLength(ListNode head) &#123; ListNode p = head; int length = 0; while(p != null) &#123; length++; p = p.next; &#125; return length; &#125;&#125; 5. 环形链表141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 5.1 快慢指针1234567891011121314151617public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null) &#123; return false; &#125; ListNode fast = head.next; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if(fast == slow) &#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"leetCode算法","slug":"leetCode算法","permalink":"http://fyupeng.github.io/categories/leetCode%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://fyupeng.github.io/tags/%E9%93%BE%E8%A1%A8/"}],"author":"fyupeng"}],"categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"http://fyupeng.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"},{"name":"面经","slug":"面经","permalink":"http://fyupeng.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"Java笔记","slug":"Java笔记","permalink":"http://fyupeng.github.io/categories/Java%E7%AC%94%E8%AE%B0/"},{"name":"leetCode算法","slug":"leetCode算法","permalink":"http://fyupeng.github.io/categories/leetCode%E7%AE%97%E6%B3%95/"},{"name":"Java框架","slug":"Java框架","permalink":"http://fyupeng.github.io/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java工具","slug":"Java工具","permalink":"http://fyupeng.github.io/tags/Java%E5%B7%A5%E5%85%B7/"},{"name":"Java脚本","slug":"Java脚本","permalink":"http://fyupeng.github.io/tags/Java%E8%84%9A%E6%9C%AC/"},{"name":"计算机网络面经","slug":"计算机网络面经","permalink":"http://fyupeng.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/"},{"name":"SQL基础","slug":"SQL基础","permalink":"http://fyupeng.github.io/tags/SQL%E5%9F%BA%E7%A1%80/"},{"name":"Java面经","slug":"Java面经","permalink":"http://fyupeng.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"},{"name":"RPC","slug":"RPC","permalink":"http://fyupeng.github.io/tags/RPC/"},{"name":"Java原理","slug":"Java原理","permalink":"http://fyupeng.github.io/tags/Java%E5%8E%9F%E7%90%86/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://fyupeng.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"Spring","slug":"Spring","permalink":"http://fyupeng.github.io/tags/Spring/"},{"name":"MVC","slug":"MVC","permalink":"http://fyupeng.github.io/tags/MVC/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://fyupeng.github.io/tags/MongoDB/"},{"name":"数据库","slug":"数据库","permalink":"http://fyupeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"http://fyupeng.github.io/tags/JDBC/"},{"name":"Oracle","slug":"Oracle","permalink":"http://fyupeng.github.io/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"http://fyupeng.github.io/tags/MySQL/"},{"name":"配置","slug":"配置","permalink":"http://fyupeng.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"数据库、Redis","slug":"数据库、Redis","permalink":"http://fyupeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81Redis/"},{"name":"MySQL、数据库","slug":"MySQL、数据库","permalink":"http://fyupeng.github.io/tags/MySQL%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"juc","slug":"juc","permalink":"http://fyupeng.github.io/tags/juc/"},{"name":"jvm","slug":"jvm","permalink":"http://fyupeng.github.io/tags/jvm/"},{"name":"netty","slug":"netty","permalink":"http://fyupeng.github.io/tags/netty/"},{"name":"二分查找","slug":"二分查找","permalink":"http://fyupeng.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"二叉树","slug":"二叉树","permalink":"http://fyupeng.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"回溯","slug":"回溯","permalink":"http://fyupeng.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"链表","slug":"链表","permalink":"http://fyupeng.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}